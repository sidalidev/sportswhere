(window.webpackJsonp = window.webpackJsonp || []).push([['chunk-vendors'], {
  '014b': function (t, e, n) {
    const i = n('e53d'); const r = n('07e3'); const o = n('8e60'); const s = n('63b6'); const a = n('9138'); const u = n('ebfd').KEY; const c = n('294c'); const h = n('dbdb'); const l = n('45f2'); const f = n('62a0'); const p = n('5168'); const d = n('ccb9'); const v = n('6718'); const g = n('47ee'); const y = n('9003'); const m = n('e4ae'); const _ = n('f772'); const b = n('36c3'); const w = n('1bc3'); const x = n('aebd'); const E = n('a159'); const S = n('0395'); const T = n('bf0b'); const O = n('d9f6'); const C = n('c3a1'); const R = T.f; const I = O.f; const P = S.f; let L = i.Symbol; const A = i.JSON; const F = A && A.stringify; const j = 'prototype'; const k = p('_hidden'); const M = p('toPrimitive'); const N = {}.propertyIsEnumerable; const D = h('symbol-registry'); const $ = h('symbols'); const G = h('op-symbols'); const V = Object[j]; const B = typeof L === 'function'; const U = i.QObject; let z = !U || !U[j] || !U[j].findChild; const Y = o && c(() => E(I({}, 'a', { get() { return I(this, 'a', { value: 7 }).a; } })).a != 7) ? function (t, e, n) { const i = R(V, e); i && delete V[e], I(t, e, n), i && t !== V && I(V, e, i); } : I; const X = function (t) { const e = $[t] = E(L[j]); return e._k = t, e; }; const W = B && typeof L.iterator === 'symbol' ? function (t) { return typeof t === 'symbol'; } : function (t) { return t instanceof L; }; var K = function (t, e, n) { return t === V && K(G, e, n), m(t), e = w(e, !0), m(n), r($, e) ? (n.enumerable ? (r(t, k) && t[k][e] && (t[k][e] = !1), n = E(n, { enumerable: x(0, !1) })) : (r(t, k) || I(t, k, x(1, {})), t[k][e] = !0), Y(t, e, n)) : I(t, e, n); }; const H = function (t, e) { m(t); let n; const i = g(e = b(e)); let r = 0; const o = i.length; while (o > r)K(t, n = i[r++], e[n]); return t; }; const q = function (t, e) { return void 0 === e ? E(t) : H(E(t), e); }; const Z = function (t) { const e = N.call(this, t = w(t, !0)); return !(this === V && r($, t) && !r(G, t)) && (!(e || !r(this, t) || !r($, t) || r(this, k) && this[k][t]) || e); }; const J = function (t, e) { if (t = b(t), e = w(e, !0), t !== V || !r($, e) || r(G, e)) { const n = R(t, e); return !n || !r($, e) || r(t, k) && t[k][e] || (n.enumerable = !0), n; } }; const Q = function (t) { let e; const n = P(b(t)); const i = []; let o = 0; while (n.length > o)r($, e = n[o++]) || e == k || e == u || i.push(e); return i; }; const tt = function (t) { let e; const n = t === V; const i = P(n ? G : b(t)); const o = []; let s = 0; while (i.length > s)!r($, e = i[s++]) || n && !r(V, e) || o.push($[e]); return o; }; B || (L = function () { if (this instanceof L) throw TypeError('Symbol is not a constructor!'); const t = f(arguments.length > 0 ? arguments[0] : void 0); var e = function (n) { this === V && e.call(G, n), r(this, k) && r(this[k], t) && (this[k][t] = !1), Y(this, t, x(1, n)); }; return o && z && Y(V, t, { configurable: !0, set: e }), X(t); }, a(L[j], 'toString', function () { return this._k; }), T.f = J, O.f = K, n('6abf').f = S.f = Q, n('355d').f = Z, n('9aa9').f = tt, o && !n('b8e3') && a(V, 'propertyIsEnumerable', Z, !0), d.f = function (t) { return X(p(t)); }), s(s.G + s.W + s.F * !B, { Symbol: L }); for (let et = 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), nt = 0; et.length > nt;)p(et[nt++]); for (let it = C(p.store), rt = 0; it.length > rt;)v(it[rt++]); s(s.S + s.F * !B, 'Symbol', {
      for(t) { return r(D, t += '') ? D[t] : D[t] = L(t); }, keyFor(t) { if (!W(t)) throw TypeError(`${t} is not a symbol!`); for (const e in D) if (D[e] === t) return e; }, useSetter() { z = !0; }, useSimple() { z = !1; },
    }), s(s.S + s.F * !B, 'Object', {
      create: q, defineProperty: K, defineProperties: H, getOwnPropertyDescriptor: J, getOwnPropertyNames: Q, getOwnPropertySymbols: tt,
    }), A && s(s.S + s.F * (!B || c(() => { const t = L(); return F([t]) != '[null]' || F({ a: t }) != '{}' || F(Object(t)) != '{}'; })), 'JSON', { stringify(t) { let e; let n; const i = [t]; let r = 1; while (arguments.length > r)i.push(arguments[r++]); if (n = e = i[1], (_(e) || void 0 !== t) && !W(t)) return y(e) || (e = function (t, e) { if (typeof n === 'function' && (e = n.call(this, t, e)), !W(e)) return e; }), i[1] = e, F.apply(A, i); } }), L[j][M] || n('35e8')(L[j], M, L[j].valueOf), l(L, 'Symbol'), l(Math, 'Math', !0), l(i.JSON, 'JSON', !0);
  },
  '01f9': function (t, e, n) {
    const i = n('2d00'); const r = n('5ca1'); const o = n('2aba'); const s = n('32e9'); const a = n('84f2'); const u = n('41a0'); const c = n('7f20'); const h = n('38fd'); const l = n('2b4c')('iterator'); const f = !([].keys && 'next' in [].keys()); const p = '@@iterator'; const d = 'keys'; const v = 'values'; const g = function () { return this; }; t.exports = function (t, e, n, y, m, _, b) { u(n, e, y); let w; let x; let E; const S = function (t) { if (!f && t in R) return R[t]; switch (t) { case d: return function () { return new n(this, t); }; case v: return function () { return new n(this, t); }; } return function () { return new n(this, t); }; }; const T = `${e} Iterator`; const O = m == v; let C = !1; var R = t.prototype; const I = R[l] || R[p] || m && R[m]; let P = I || S(m); const L = m ? O ? S('entries') : P : void 0; const A = e == 'Array' && R.entries || I; if (A && (E = h(A.call(new t())), E !== Object.prototype && E.next && (c(E, T, !0), i || typeof E[l] === 'function' || s(E, l, g))), O && I && I.name !== v && (C = !0, P = function () { return I.call(this); }), i && !b || !f && !C && R[l] || s(R, l, P), a[e] = P, a[T] = g, m) if (w = { values: O ? P : S(v), keys: _ ? P : S(d), entries: L }, b) for (x in w)x in R || o(R, x, w[x]); else r(r.P + r.F * (f || C), e, w); return w; };
  },
  '0293': function (t, e, n) { const i = n('241e'); const r = n('53e2'); n('ce7e')('getPrototypeOf', () => function (t) { return r(i(t)); }); },
  '0354': function (t, e, n) {
    t.exports = r, t.exports.default = r; const i = n('61ca'); function r(t, e) { if (!(this instanceof r)) return new r(t, e); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), e && this._initFormat(e), this.clear(); } function o(t, e, n) { if (!n) return e.indexOf(t); for (let i = 0; i < e.length; i++) if (n(t, e[i])) return i; return -1; } function s(t, e) { a(t, 0, t.children.length, e, t); } function a(t, e, n, i, r) { r || (r = y(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0; for (var o, s = e; s < n; s++)o = t.children[s], u(r, t.leaf ? i(o) : o); return r; } function u(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t; } function c(t, e) { return t.minX - e.minX; } function h(t, e) { return t.minY - e.minY; } function l(t) { return (t.maxX - t.minX) * (t.maxY - t.minY); } function f(t) { return t.maxX - t.minX + (t.maxY - t.minY); } function p(t, e) { return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY)); } function d(t, e) { const n = Math.max(t.minX, e.minX); const i = Math.max(t.minY, e.minY); const r = Math.min(t.maxX, e.maxX); const o = Math.min(t.maxY, e.maxY); return Math.max(0, r - n) * Math.max(0, o - i); } function v(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY; } function g(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY; } function y(t) {
      return {
        children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0,
      };
    } function m(t, e, n, r, o) { let s; const a = [e, n]; while (a.length)n = a.pop(), e = a.pop(), n - e <= r || (s = e + Math.ceil((n - e) / r / 2) * r, i(t, s, e, n, o), a.push(e, s, s, n)); }r.prototype = {
      all() { return this._all(this.data, []); }, search(t) { let e = this.data; const n = []; const i = this.toBBox; if (!g(t, e)) return n; let r; let o; let s; let a; const u = []; while (e) { for (r = 0, o = e.children.length; r < o; r++)s = e.children[r], a = e.leaf ? i(s) : s, g(t, a) && (e.leaf ? n.push(s) : v(t, a) ? this._all(s, n) : u.push(s)); e = u.pop(); } return n; }, collides(t) { let e = this.data; const n = this.toBBox; if (!g(t, e)) return !1; let i; let r; let o; let s; const a = []; while (e) { for (i = 0, r = e.children.length; i < r; i++) if (o = e.children[i], s = e.leaf ? n(o) : o, g(t, s)) { if (e.leaf || v(t, s)) return !0; a.push(o); }e = a.pop(); } return !1; }, load(t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, n = t.length; e < n; e++) this.insert(t[e]); return this; } let i = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === i.height) this._splitRoot(this.data, i); else { if (this.data.height < i.height) { const r = this.data; this.data = i, i = r; } this._insert(i, this.data.height - i.height - 1, !0); } else this.data = i; return this; }, insert(t) { return t && this._insert(t, this.data.height - 1), this; }, clear() { return this.data = y([]), this; }, remove(t, e) { if (!t) return this; let n; let i; let r; let s; let a = this.data; const u = this.toBBox(t); const c = []; const h = []; while (a || c.length) { if (a || (a = c.pop(), i = c[c.length - 1], n = h.pop(), s = !0), a.leaf && (r = o(t, a.children, e), r !== -1)) return a.children.splice(r, 1), c.push(a), this._condense(c), this; s || a.leaf || !v(a, u) ? i ? (n++, a = i.children[n], s = !1) : a = null : (c.push(a), h.push(n), n = 0, i = a, a = a.children[0]); } return this; }, toBBox(t) { return t; }, compareMinX: c, compareMinY: h, toJSON() { return this.data; }, fromJSON(t) { return this.data = t, this; }, _all(t, e) { const n = []; while (t)t.leaf ? e.push(...t.children) : n.push(...t.children), t = n.pop(); return e; }, _build(t, e, n, i) { let r; const o = n - e + 1; let a = this._maxEntries; if (o <= a) return r = y(t.slice(e, n + 1)), s(r, this.toBBox), r; i || (i = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, i - 1))), r = y([]), r.leaf = !1, r.height = i; let u; let c; let h; let l; const f = Math.ceil(o / a); const p = f * Math.ceil(Math.sqrt(a)); for (m(t, e, n, p, this.compareMinX), u = e; u <= n; u += p) for (h = Math.min(u + p - 1, n), m(t, u, h, f, this.compareMinY), c = u; c <= h; c += f)l = Math.min(c + f - 1, h), r.children.push(this._build(t, c, l, i - 1)); return s(r, this.toBBox), r; }, _chooseSubtree(t, e, n, i) { let r; let o; let s; let a; let u; let c; let h; let f; while (1) { if (i.push(e), e.leaf || i.length - 1 === n) break; for (h = f = 1 / 0, r = 0, o = e.children.length; r < o; r++)s = e.children[r], u = l(s), c = p(t, s) - u, c < f ? (f = c, h = u < h ? u : h, a = s) : c === f && u < h && (h = u, a = s); e = a || e.children[0]; } return e; }, _insert(t, e, n) { const i = this.toBBox; const r = n ? t : i(t); const o = []; const s = this._chooseSubtree(r, this.data, e, o); s.children.push(t), u(s, r); while (e >= 0) { if (!(o[e].children.length > this._maxEntries)) break; this._split(o, e), e--; } this._adjustParentBBoxes(r, o, e); }, _split(t, e) { const n = t[e]; const i = n.children.length; const r = this._minEntries; this._chooseSplitAxis(n, r, i); const o = this._chooseSplitIndex(n, r, i); const a = y(n.children.splice(o, n.children.length - o)); a.height = n.height, a.leaf = n.leaf, s(n, this.toBBox), s(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a); }, _splitRoot(t, e) { this.data = y([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, s(this.data, this.toBBox); }, _chooseSplitIndex(t, e, n) { let i; let r; let o; let s; let u; let c; let h; let f; for (c = h = 1 / 0, i = e; i <= n - e; i++)r = a(t, 0, i, this.toBBox), o = a(t, i, n, this.toBBox), s = d(r, o), u = l(r) + l(o), s < c ? (c = s, f = i, h = u < h ? u : h) : s === c && u < h && (h = u, f = i); return f; }, _chooseSplitAxis(t, e, n) { const i = t.leaf ? this.compareMinX : c; const r = t.leaf ? this.compareMinY : h; const o = this._allDistMargin(t, e, n, i); const s = this._allDistMargin(t, e, n, r); o < s && t.children.sort(i); }, _allDistMargin(t, e, n, i) { t.children.sort(i); let r; let o; const s = this.toBBox; const c = a(t, 0, e, s); const h = a(t, n - e, n, s); let l = f(c) + f(h); for (r = e; r < n - e; r++)o = t.children[r], u(c, t.leaf ? s(o) : o), l += f(c); for (r = n - e - 1; r >= e; r--)o = t.children[r], u(h, t.leaf ? s(o) : o), l += f(h); return l; }, _adjustParentBBoxes(t, e, n) { for (let i = n; i >= 0; i--)u(e[i], t); }, _condense(t) { for (var e, n = t.length - 1; n >= 0; n--)t[n].children.length === 0 ? n > 0 ? (e = t[n - 1].children, e.splice(e.indexOf(t[n]), 1)) : this.clear() : s(t[n], this.toBBox); }, _initFormat(t) { const e = ['return a', ' - b', ';']; this.compareMinX = new Function('a', 'b', e.join(t[0])), this.compareMinY = new Function('a', 'b', e.join(t[1])), this.toBBox = new Function('a', `return {minX: a${t[0]}, minY: a${t[1]}, maxX: a${t[2]}, maxY: a${t[3]}};`); },
    };
  },
  '0395': function (t, e, n) { const i = n('36c3'); const r = n('6abf').f; const o = {}.toString; const s = typeof window === 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; const a = function (t) { try { return r(t); } catch (e) { return s.slice(); } }; t.exports.f = function (t) { return s && o.call(t) == '[object Window]' ? a(t) : r(i(t)); }; },
  '044b': function (t, e) {
    function n(t) { return !!t.constructor && typeof t.constructor.isBuffer === 'function' && t.constructor.isBuffer(t); } function i(t) { return typeof t.readFloatLE === 'function' && typeof t.slice === 'function' && n(t.slice(0, 0)); }
    /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
    t.exports = function (t) { return t != null && (n(t) || i(t) || !!t._isBuffer); };
  },
  '061b': function (t, e, n) { t.exports = n('fa99'); },
  '07e3': function (t, e) { const n = {}.hasOwnProperty; t.exports = function (t, e) { return n.call(t, e); }; },
  '097d': function (t, e, n) {
    const i = n('5ca1'); const r = n('8378'); const o = n('7726'); const s = n('ebd6'); const a = n('bcaa'); i(i.P + i.R, 'Promise', { finally(t) { const e = s(this, r.Promise || o.Promise); const n = typeof t === 'function'; return this.then(n ? n => a(e, t()).then(() => n) : t, n ? n => a(e, t()).then(() => { throw n; }) : t); } });
  },
  '0a06': function (t, e, n) {
    const i = n('2444'); const r = n('c532'); const o = n('f6b4'); const s = n('5270'); function a(t) { this.defaults = t, this.interceptors = { request: new o(), response: new o() }; }a.prototype.request = function (t) { typeof t === 'string' && (t = r.merge({ url: arguments[0] }, arguments[1])), t = r.merge(i, { method: 'get' }, this.defaults, t), t.method = t.method.toLowerCase(); const e = [s, void 0]; let n = Promise.resolve(t); this.interceptors.request.forEach((t) => { e.unshift(t.fulfilled, t.rejected); }), this.interceptors.response.forEach((t) => { e.push(t.fulfilled, t.rejected); }); while (e.length)n = n.then(e.shift(), e.shift()); return n; }, r.forEach(['delete', 'get', 'head', 'options'], (t) => { a.prototype[t] = function (e, n) { return this.request(r.merge(n || {}, { method: t, url: e })); }; }), r.forEach(['post', 'put', 'patch'], (t) => { a.prototype[t] = function (e, n, i) { return this.request(r.merge(i || {}, { method: t, url: e, data: n })); }; }), t.exports = a;
  },
  '0a90': function (t, e, n) { const i = n('63b6'); const r = n('10ff'); i(i.G + i.F * (parseFloat != r), { parseFloat: r }); },
  '0b64': function (t, e, n) { const i = n('f772'); const r = n('9003'); const o = n('5168')('species'); t.exports = function (t) { let e; return r(t) && (e = t.constructor, typeof e !== 'function' || e !== Array && !r(e.prototype) || (e = void 0), i(e) && (e = e[o], e === null && (e = void 0))), void 0 === e ? Array : e; }; },
  '0d01': function (t, e, n) {
    const i = n('2b0e'); function r(t, e) { t.style.transform = e, t.style.webkitTransform = e; } function o(t, e) { t.style.opacity = e.toString(); } const s = function (t, e) {
      const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const i = e.getBoundingClientRect(); const r = t.clientX - i.left; const o = t.clientY - i.top; let s = 0; let a = 0.3; e._ripple && e._ripple.circle ? (a = 0.15, s = e.clientWidth / 2, s = n.center ? s : s + Math.sqrt(Math.pow(r - s, 2) + Math.pow(o - s, 2)) / 4) : s = Math.sqrt(Math.pow(e.clientWidth, 2) + Math.pow(e.clientHeight, 2)) / 2; const u = `${(e.clientWidth - 2 * s) / 2}px`; const c = `${(e.clientHeight - 2 * s) / 2}px`; const h = n.center ? u : `${r - s}px`; const l = n.center ? c : `${o - s}px`; return {
        radius: s, scale: a, x: h, y: l, centerX: u, centerY: c,
      };
    }; const a = { show(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (e._ripple && e._ripple.enabled) { const i = document.createElement('span'); const a = document.createElement('span'); i.appendChild(a), i.className = 'v-ripple__container', n.class && (i.className += ` ${n.class}`); const u = s(t, e, n); const c = u.radius; const h = u.scale; const l = u.x; const f = u.y; const p = u.centerX; const d = u.centerY; const v = `${2 * c}px`; a.className = 'v-ripple__animation', a.style.width = v, a.style.height = v, e.appendChild(i); const g = window.getComputedStyle(e); g.position === 'static' && (e.style.position = 'relative', e.dataset.previousPosition = 'static'), a.classList.add('v-ripple__animation--enter'), a.classList.add('v-ripple__animation--visible'), r(a, `translate(${l}, ${f}) scale3d(${h},${h},${h})`), o(a, 0), a.dataset.activated = String(performance.now()), setTimeout(() => { a.classList.remove('v-ripple__animation--enter'), a.classList.add('v-ripple__animation--in'), r(a, `translate(${p}, ${d}) scale3d(1,1,1)`), o(a, 0.25), setTimeout(() => { a.classList.remove('v-ripple__animation--in'), a.classList.add('v-ripple__animation--out'), o(a, 0); }, 300); }, 0); } }, hide(t) { if (t && t._ripple && t._ripple.enabled) { const e = t.getElementsByClassName('v-ripple__animation'); if (e.length !== 0) { const n = e[e.length - 1]; if (!n.dataset.isHiding) { n.dataset.isHiding = 'true'; const i = performance.now() - Number(n.dataset.activated); const r = Math.max(200 - i, 0); setTimeout(() => { n.classList.remove('v-ripple__animation--out'), setTimeout(() => { const e = t.getElementsByClassName('v-ripple__animation'); e.length === 1 && t.dataset.previousPosition && (t.style.position = t.dataset.previousPosition, delete t.dataset.previousPosition), n.parentNode && t.removeChild(n.parentNode); }, 300); }, r); } } } } }; function u(t) { return typeof t === 'undefined' || !!t; } function c(t) { const e = {}; const n = t.currentTarget; n && (e.center = n._ripple.centered, n._ripple.class && (e.class = n._ripple.class), a.show(t, n, e)); } function h(t) { a.hide(t.currentTarget); } function l(t, e, n) { const i = u(e.value); i || a.hide(t), t._ripple = t._ripple || {}, t._ripple.enabled = i; const r = e.value || {}; r.center && (t._ripple.centered = !0), r.class && (t._ripple.class = e.value.class), r.circle && (t._ripple.circle = r.circle), i && !n ? ('ontouchstart' in window && (t.addEventListener('touchend', h, !1), t.addEventListener('touchcancel', h, !1)), t.addEventListener('mousedown', c, !1), t.addEventListener('mouseup', h, !1), t.addEventListener('mouseleave', h, !1), t.addEventListener('dragstart', h, !1)) : !i && n && f(t); } function f(t) { t.removeEventListener('mousedown', c, !1), t.removeEventListener('touchend', h, !1), t.removeEventListener('touchcancel', h, !1), t.removeEventListener('mouseup', h, !1), t.removeEventListener('mouseleave', h, !1), t.removeEventListener('dragstart', h, !1); } function p(t, e) { l(t, e, !1); } function d(t) { delete t._ripple, f(t); } function v(t, e) { if (e.value !== e.oldValue) { const n = u(e.oldValue); l(t, e, n); } } const g = { bind: p, unbind: d, update: v }; const y = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; function m(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    }e.a = i.a.extend({
      name: 'routable',
      directives: { Ripple: g },
      props: {
        activeClass: String, append: Boolean, disabled: Boolean, exact: { type: Boolean, default: void 0 }, exactActiveClass: String, href: [String, Object], to: [String, Object], nuxt: Boolean, replace: Boolean, ripple: [Boolean, Object], tag: String, target: String,
      },
      computed: { computedRipple() { return !(!this.ripple || this.disabled) && this.ripple; } },
      methods: {
        click(t) { this.$emit('click', t); },
        generateRouteLink(t) {
          let e = this.exact; let n = void 0; const i = m({
            attrs: { disabled: this.disabled }, class: t, props: {}, directives: [{ name: 'ripple', value: this.computedRipple }],
          }, this.to ? 'nativeOn' : 'on', y({}, this.$listeners, { click: this.click })); if (typeof this.exact === 'undefined' && (e = this.to === '/' || this.to === Object(this.to) && this.to.path === '/'), this.to) {
            let r = this.activeClass; let o = this.exactActiveClass || r; this.proxyClass && (r += ` ${this.proxyClass}`, o += ` ${this.proxyClass}`), n = this.nuxt ? 'nuxt-link' : 'router-link', Object.assign(i.props, {
              to: this.to, exact: e, activeClass: r, exactActiveClass: o, append: this.append, replace: this.replace,
            });
          } else n = (this.href ? 'a' : this.tag) || 'a', n === 'a' && this.href && (i.attrs.href = this.href); return this.target && (i.attrs.target = this.target), { tag: n, data: i };
        },
      },
    });
  },
  '0d58': function (t, e, n) { const i = n('ce10'); const r = n('e11e'); t.exports = Object.keys || function (t) { return i(t, r); }; },
  '0df6': function (t, e, n) {
    t.exports = function (t) { return function (e) { return t(...e); }; };
  },
  '0e8f': function (t, e, n) {
    n('db6d'); const i = n('e8f2'); e.a = Object(i.a)('flex');
  },
  '0fc9': function (t, e, n) { const i = n('3a38'); const r = Math.max; const o = Math.min; t.exports = function (t, e) { return t = i(t), t < 0 ? r(t + e, 0) : o(t, e); }; },
  1069(t, e, n) {},
  '10ff': function (t, e, n) { const i = n('e53d').parseFloat; const r = n('a1ce').trim; t.exports = 1 / i(`${n('e692')}-0`) !== -1 / 0 ? function (t) { const e = r(String(t), 3); const n = i(e); return n === 0 && e.charAt(0) == '-' ? -0 : n; } : i; },
  1173(t, e) { t.exports = function (t, e, n, i) { if (!(t instanceof e) || void 0 !== i && i in t) throw TypeError(`${n}: incorrect invocation!`); return t; }; },
  '12b2': function (t, e, n) {
    const i = n('2b0e'); e.a = i.a.extend({
      name: 'v-card-title', functional: !0, props: { primaryTitle: Boolean }, render(t, e) { const n = e.data; const i = e.props; const r = e.children; return n.staticClass = (`v-card__title ${n.staticClass || ''}`).trim(), i.primaryTitle && (n.staticClass += ' v-card__title--primary'), t('div', n, r); },
    });
  },
  '132d': function (t, e, n) {
    n('44dc'); let i; const r = n('b64a'); const o = n('2b0e'); const s = o.a.extend({
      name: 'sizeable',
      props: {
        large: Boolean, medium: Boolean, size: { type: [Number, String] }, small: Boolean, xLarge: Boolean,
      },
    }); const a = n('6a18'); const u = n('80d2'); const c = n('58df'); const h = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; function l(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function f(t) { return ['fas', 'far', 'fal', 'fab'].some(e => t.includes(e)); }(function (t) { t.small = '16px', t.default = '24px', t.medium = '28px', t.large = '36px', t.xLarge = '40px'; }(i || (i = {}))); const p = Object(c.a)(r.a, s, a.a).extend({
      name: 'v-icon',
      props: { disabled: Boolean, left: Boolean, right: Boolean },
      render(t) {
        let e; const n = {
          small: this.small, medium: this.medium, large: this.large, xLarge: this.xLarge,
        }; const r = Object(u.e)(n).find(t => n[t] && !!t); const o = r && i[r] || Object(u.a)(this.size); const s = []; const a = { staticClass: 'v-icon', attrs: h({ 'aria-hidden': !0 }, this.$attrs), on: this.$listeners }; o && (a.style = { fontSize: o }); let c = ''; this.$slots.default && (c = this.$slots.default[0].text), c = Object(u.f)(this, c); let p = 'material-icons'; const d = c.indexOf('-'); const v = d > -1; return v ? (p = c.slice(0, d), f(p) && (p = '')) : s.push(c), a.class = h((e = {
          'v-icon--disabled': this.disabled, 'v-icon--left': this.left, 'v-icon--link': this.$listeners.click || this.$listeners['!click'], 'v-icon--right': this.right,
        }, l(e, p, !0), l(e, c, v), e), this.themeClasses), t('i', this.setTextColor(this.color, a), s);
      },
    }); e.a = o.a.extend({
      name: 'v-icon', $_wrapperFor: p, functional: !0, render(t, e) { const n = e.data; const i = e.children; let r = ''; return n.domProps && (r = n.domProps.textContent || n.domProps.innerHTML || r, delete n.domProps.textContent, delete n.domProps.innerHTML), t(p, n, r ? [r] : i); },
    });
  },
  '13c8': function (t, e, n) { const i = n('c3a1'); const r = n('36c3'); const o = n('355d').f; t.exports = function (t) { return function (e) { let n; const s = r(e); const a = i(s); const u = a.length; let c = 0; const h = []; while (u > c)o.call(s, n = a[c++]) && h.push(t ? [n, s[n]] : s[n]); return h; }; }; },
  1495(t, e, n) { const i = n('86cc'); const r = n('cb7c'); const o = n('0d58'); t.exports = n('9e1e') ? Object.defineProperties : function (t, e) { r(t); let n; const s = o(e); const a = s.length; let u = 0; while (a > u)i.f(t, n = s[u++], e[n]); return t; }; },
  1654(t, e, n) {
    const i = n('71c1')(!0); n('30f1')(String, 'String', function (t) { this._t = String(t), this._i = 0; }, function () { let t; const e = this._t; const n = this._i; return n >= e.length ? { value: void 0, done: !0 } : (t = i(e, n), this._i += t.length, { value: t, done: !1 }); });
  },
  1691(t, e) { t.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(','); },
  '16c5': function (t, e, n) { const i = n('1772'); const r = function () { return new c(); }; for (const o in i) { r[`${o}Raw`] = (function (t) { return function (e) { return typeof e === 'number' && (e = Array.prototype.slice.call(arguments)), i[t](e); }; }(o)); const s = /(\w+)2(\w+)/.exec(o); const a = s[1]; const u = s[2]; r[a] = r[a] || {}, r[a][u] = r[o] = (function (t) { return function (e) { typeof e === 'number' && (e = Array.prototype.slice.call(arguments)); const n = i[t](e); if (typeof n === 'string' || void 0 === n) return n; for (let r = 0; r < n.length; r++)n[r] = Math.round(n[r]); return n; }; }(o)); } var c = function () { this.convs = {}; }; c.prototype.routeSpace = function (t, e) { let n = e[0]; return void 0 === n ? this.getValues(t) : (typeof n === 'number' && (n = Array.prototype.slice.call(e)), this.setValues(t, n)); }, c.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this; }, c.prototype.getValues = function (t) { let e = this.convs[t]; if (!e) { const n = this.space; const i = this.convs[n]; e = r[n][t](i), this.convs[t] = e; } return e; }, ['rgb', 'hsl', 'hsv', 'cmyk', 'keyword'].forEach((t) => { c.prototype[t] = function (e) { return this.routeSpace(t, arguments); }; }), t.exports = r; },
  1772(t, e) {
    function n(t) { let e; let n; let i; const r = t[0] / 255; const o = t[1] / 255; const s = t[2] / 255; const a = Math.min(r, o, s); const u = Math.max(r, o, s); const c = u - a; return u == a ? e = 0 : r == u ? e = (o - s) / c : o == u ? e = 2 + (s - r) / c : s == u && (e = 4 + (r - o) / c), e = Math.min(60 * e, 360), e < 0 && (e += 360), i = (a + u) / 2, n = u == a ? 0 : i <= 0.5 ? c / (u + a) : c / (2 - u - a), [e, 100 * n, 100 * i]; } function i(t) { let e; let n; let i; const r = t[0]; const o = t[1]; const s = t[2]; const a = Math.min(r, o, s); const u = Math.max(r, o, s); const c = u - a; return n = u == 0 ? 0 : c / u * 1e3 / 10, u == a ? e = 0 : r == u ? e = (o - s) / c : o == u ? e = 2 + (s - r) / c : s == u && (e = 4 + (r - o) / c), e = Math.min(60 * e, 360), e < 0 && (e += 360), i = u / 255 * 1e3 / 10, [e, n, i]; } function o(t) { const e = t[0]; const i = t[1]; let r = t[2]; const o = n(t)[0]; const s = 1 / 255 * Math.min(e, Math.min(i, r)); r = 1 - 1 / 255 * Math.max(e, Math.max(i, r)); return [o, 100 * s, 100 * r]; } function s(t) { let e; let n; let i; let r; const o = t[0] / 255; const s = t[1] / 255; const a = t[2] / 255; return r = Math.min(1 - o, 1 - s, 1 - a), e = (1 - o - r) / (1 - r) || 0, n = (1 - s - r) / (1 - r) || 0, i = (1 - a - r) / (1 - r) || 0, [100 * e, 100 * n, 100 * i, 100 * r]; } function a(t) { return q[JSON.stringify(t)]; } function u(t) { let e = t[0] / 255; let n = t[1] / 255; let i = t[2] / 255; e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92; const r = 0.4124 * e + 0.3576 * n + 0.1805 * i; const o = 0.2126 * e + 0.7152 * n + 0.0722 * i; const s = 0.0193 * e + 0.1192 * n + 0.9505 * i; return [100 * r, 100 * o, 100 * s]; } function c(t) { let e; let n; let i; const r = u(t); let o = r[0]; let s = r[1]; let a = r[2]; return o /= 95.047, s /= 100, a /= 108.883, o = o > 0.008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, s = s > 0.008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, a = a > 0.008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116, e = 116 * s - 16, n = 500 * (o - s), i = 200 * (s - a), [e, n, i]; } function h(t) { return N(c(t)); } function l(t) { let e; let n; let i; let r; let o; const s = t[0] / 360; const a = t[1] / 100; const u = t[2] / 100; if (a == 0) return o = 255 * u, [o, o, o]; n = u < 0.5 ? u * (1 + a) : u + a - u * a, e = 2 * u - n, r = [0, 0, 0]; for (let c = 0; c < 3; c++)i = s + 1 / 3 * -(c - 1), i < 0 && i++, i > 1 && i--, o = 6 * i < 1 ? e + 6 * (n - e) * i : 2 * i < 1 ? n : 3 * i < 2 ? e + (n - e) * (2 / 3 - i) * 6 : e, r[c] = 255 * o; return r; } function f(t) { let e; let n; const i = t[0]; let r = t[1] / 100; let o = t[2] / 100; return o === 0 ? [0, 0, 0] : (o *= 2, r *= o <= 1 ? o : 2 - o, n = (o + r) / 2, e = 2 * r / (o + r), [i, 100 * e, 100 * n]); } function p(t) { return o(l(t)); } function d(t) { return s(l(t)); } function v(t) { return a(l(t)); } function y(t) { const e = t[0] / 60; const n = t[1] / 100; let i = t[2] / 100; const r = Math.floor(e) % 6; const o = e - Math.floor(e); const s = 255 * i * (1 - n); const a = 255 * i * (1 - n * o); const u = 255 * i * (1 - n * (1 - o)); i *= 255; switch (r) { case 0: return [i, u, s]; case 1: return [a, i, s]; case 2: return [s, i, u]; case 3: return [s, a, i]; case 4: return [u, s, i]; case 5: return [i, s, a]; } } function m(t) { let e; let n; const i = t[0]; const r = t[1] / 100; const o = t[2] / 100; return n = (2 - r) * o, e = r * o, e /= n <= 1 ? n : 2 - n, e = e || 0, n /= 2, [i, 100 * e, 100 * n]; } function _(t) { return o(y(t)); } function w(t) { return s(y(t)); } function x(t) { return a(y(t)); } function E(t) { let e; let n; let i; let o; const s = t[0] / 360; let a = t[1] / 100; let u = t[2] / 100; const c = a + u; switch (c > 1 && (a /= c, u /= c), e = Math.floor(6 * s), n = 1 - u, i = 6 * s - e, (1 & e) != 0 && (i = 1 - i), o = a + i * (n - a), e) { default: case 6: case 0: r = n, g = o, b = a; break; case 1: r = o, g = n, b = a; break; case 2: r = a, g = n, b = o; break; case 3: r = a, g = o, b = n; break; case 4: r = o, g = a, b = n; break; case 5: r = n, g = a, b = o; break; } return [255 * r, 255 * g, 255 * b]; } function S(t) { return n(E(t)); } function T(t) { return i(E(t)); } function O(t) { return s(E(t)); } function C(t) { return a(E(t)); } function R(t) { let e; let n; let i; const r = t[0] / 100; const o = t[1] / 100; const s = t[2] / 100; const a = t[3] / 100; return e = 1 - Math.min(1, r * (1 - a) + a), n = 1 - Math.min(1, o * (1 - a) + a), i = 1 - Math.min(1, s * (1 - a) + a), [255 * e, 255 * n, 255 * i]; } function I(t) { return n(R(t)); } function P(t) { return i(R(t)); } function L(t) { return o(R(t)); } function A(t) { return a(R(t)); } function F(t) { let e; let n; let i; const r = t[0] / 100; const o = t[1] / 100; const s = t[2] / 100; return e = 3.2406 * r + -1.5372 * o + -0.4986 * s, n = -0.9689 * r + 1.8758 * o + 0.0415 * s, i = 0.0557 * r + -0.204 * o + 1.057 * s, e = e > 0.0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055 : e *= 12.92, n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n *= 12.92, i = i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i *= 12.92, e = Math.min(Math.max(0, e), 1), n = Math.min(Math.max(0, n), 1), i = Math.min(Math.max(0, i), 1), [255 * e, 255 * n, 255 * i]; } function j(t) { let e; let n; let i; let r = t[0]; let o = t[1]; let s = t[2]; return r /= 95.047, o /= 100, s /= 108.883, r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, o = o > 0.008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, s = s > 0.008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, e = 116 * o - 16, n = 500 * (r - o), i = 200 * (o - s), [e, n, i]; } function k(t) { return N(j(t)); } function M(t) { let e; let n; let i; let r; const o = t[0]; const s = t[1]; const a = t[2]; return o <= 8 ? (n = 100 * o / 903.3, r = n / 100 * 7.787 + 16 / 116) : (n = 100 * Math.pow((o + 16) / 116, 3), r = Math.pow(n / 100, 1 / 3)), e = e / 95.047 <= 0.008856 ? e = 95.047 * (s / 500 + r - 16 / 116) / 7.787 : 95.047 * Math.pow(s / 500 + r, 3), i = i / 108.883 <= 0.008859 ? i = 108.883 * (r - a / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(r - a / 200, 3), [e, n, i]; } function N(t) { let e; let n; let i; const r = t[0]; const o = t[1]; const s = t[2]; return e = Math.atan2(s, o), n = 360 * e / 2 / Math.PI, n < 0 && (n += 360), i = Math.sqrt(o * o + s * s), [r, i, n]; } function D(t) { return F(M(t)); } function $(t) { let e; let n; let i; const r = t[0]; const o = t[1]; const s = t[2]; return i = s / 360 * 2 * Math.PI, e = o * Math.cos(i), n = o * Math.sin(i), [r, e, n]; } function G(t) { return M($(t)); } function V(t) { return D($(t)); } function B(t) { return H[t]; } function U(t) { return n(B(t)); } function z(t) { return i(B(t)); } function Y(t) { return o(B(t)); } function X(t) { return s(B(t)); } function W(t) { return c(B(t)); } function K(t) { return u(B(t)); }t.exports = {
      rgb2hsl: n, rgb2hsv: i, rgb2hwb: o, rgb2cmyk: s, rgb2keyword: a, rgb2xyz: u, rgb2lab: c, rgb2lch: h, hsl2rgb: l, hsl2hsv: f, hsl2hwb: p, hsl2cmyk: d, hsl2keyword: v, hsv2rgb: y, hsv2hsl: m, hsv2hwb: _, hsv2cmyk: w, hsv2keyword: x, hwb2rgb: E, hwb2hsl: S, hwb2hsv: T, hwb2cmyk: O, hwb2keyword: C, cmyk2rgb: R, cmyk2hsl: I, cmyk2hsv: P, cmyk2hwb: L, cmyk2keyword: A, keyword2rgb: B, keyword2hsl: U, keyword2hsv: z, keyword2hwb: Y, keyword2cmyk: X, keyword2lab: W, keyword2xyz: K, xyz2rgb: F, xyz2lab: j, xyz2lch: k, lab2xyz: M, lab2rgb: D, lab2lch: N, lch2lab: $, lch2xyz: G, lch2rgb: V,
    }; var H = {
      aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
    }; var q = {}; for (const Z in H)q[JSON.stringify(H[Z])] = Z;
  },
  1991(t, e, n) { let i; let r; let o; const s = n('9b43'); const a = n('31f4'); const u = n('fab2'); const c = n('230e'); const h = n('7726'); const l = h.process; let f = h.setImmediate; let p = h.clearImmediate; const d = h.MessageChannel; const v = h.Dispatch; let g = 0; const y = {}; const m = 'onreadystatechange'; const _ = function () { const t = +this; if (y.hasOwnProperty(t)) { const e = y[t]; delete y[t], e(); } }; const b = function (t) { _.call(t.data); }; f && p || (f = function (t) { const e = []; let n = 1; while (arguments.length > n)e.push(arguments[n++]); return y[++g] = function () { a(typeof t === 'function' ? t : Function(t), e); }, i(g), g; }, p = function (t) { delete y[t]; }, n('2d95')(l) == 'process' ? i = function (t) { l.nextTick(s(_, t, 1)); } : v && v.now ? i = function (t) { v.now(s(_, t, 1)); } : d ? (r = new d(), o = r.port2, r.port1.onmessage = b, i = s(o.postMessage, o, 1)) : h.addEventListener && typeof postMessage === 'function' && !h.importScripts ? (i = function (t) { h.postMessage(`${t}`, '*'); }, h.addEventListener('message', b, !1)) : i = m in c('script') ? function (t) { u.appendChild(c('script'))[m] = function () { u.removeChild(this), _.call(t); }; } : function (t) { setTimeout(s(_, t, 1), 0); }), t.exports = { set: f, clear: p }; },
  '1af6': function (t, e, n) { const i = n('63b6'); i(i.S, 'Array', { isArray: n('9003') }); },
  '1bc3': function (t, e, n) { const i = n('f772'); t.exports = function (t, e) { if (!i(t)) return t; let n; let r; if (e && typeof (n = t.toString) === 'function' && !i(r = n.call(t))) return r; if (typeof (n = t.valueOf) === 'function' && !i(r = n.call(t))) return r; if (!e && typeof (n = t.toString) === 'function' && !i(r = n.call(t))) return r; throw TypeError("Can't convert object to primitive value"); }; },
  '1cb7': function (t, e, n) { const i = n('bf0b'); const r = n('53e2'); const o = n('07e3'); const s = n('63b6'); const a = n('f772'); const u = n('e4ae'); function c(t, e) { let n; let s; const h = arguments.length < 3 ? t : arguments[2]; return u(t) === h ? t[e] : (n = i.f(t, e)) ? o(n, 'value') ? n.value : void 0 !== n.get ? n.get.call(h) : void 0 : a(s = r(t)) ? c(s, e, h) : void 0; }s(s.S, 'Reflect', { get: c }); },
  '1cf8': function (t, e, n) {
    const i = {}; n.r(i), n.d(i, 'createPointGeom', () => qu), n.d(i, 'createLineGeom', () => Zu), n.d(i, 'createPolygonGeom', () => Ju), n.d(i, 'createMultiPointGeom', () => Qu), n.d(i, 'createMultiLineGeom', () => tc), n.d(i, 'createMultiPolygonGeom', () => ec), n.d(i, 'createGeomCollection', () => nc), n.d(i, 'createCircularPolygon', () => ic), n.d(i, 'isMultiGeom', () => rc), n.d(i, 'toSimpleGeom', () => oc), n.d(i, 'findPointOnSurface', () => sc); const r = {}; n.r(r), n.d(r, 'default', () => ey), n.d(r, 'Source', () => Qg), n.d(r, 'install', () => ty); const o = {}; n.r(o), n.d(o, 'default', () => by), n.d(o, 'Source', () => my), n.d(o, 'install', () => _y); const s = {}; n.r(s), n.d(s, 'default', () => jy), n.d(s, 'Geom', () => Ay), n.d(s, 'install', () => Fy); const a = {}; n.r(a), n.d(a, 'default', () => Wy), n.d(a, 'Style', () => Yy), n.d(a, 'install', () => Xy); const u = {}; n.r(u), n.d(u, 'default', () => Dm), n.d(u, 'Source', () => Mm), n.d(u, 'install', () => Nm); const c = {}; n.r(c), n.d(c, 'default', () => tb), n.d(c, 'Interaction', () => J_), n.d(c, 'install', () => Q_); const h = {}; n.r(h), n.d(h, 'default', () => yb), n.d(h, 'Feature', () => vb), n.d(h, 'install', () => gb); const l = {}; n.r(l), n.d(l, 'default', () => Pb), n.d(l, 'Style', () => Rb), n.d(l, 'install', () => Ib); const f = {}; n.r(f), n.d(f, 'default', () => Zb), n.d(f, 'Geoloc', () => Hb), n.d(f, 'install', () => qb); const p = {}; n.r(p), n.d(p, 'default', () => bw), n.d(p, 'Graticule', () => mw), n.d(p, 'install', () => _w); const d = {}; n.r(d), n.d(d, 'default', () => jw), n.d(d, 'Layer', () => Aw), n.d(d, 'install', () => Fw); const v = {}; n.r(v), n.d(v, 'default', () => Ww), n.d(v, 'Style', () => Yw), n.d(v, 'install', () => Xw); const g = {}; n.r(g), n.d(g, 'default', () => ax), n.d(g, 'Layer', () => ox), n.d(g, 'install', () => sx); const y = {}; n.r(y), n.d(y, 'default', () => Fx), n.d(y, 'Source', () => Lx), n.d(y, 'install', () => Ax); const m = {}; n.r(m), n.d(m, 'default', () => qx), n.d(m, 'Source', () => Kx), n.d(m, 'install', () => Hx); const _ = {}; n.r(_), n.d(_, 'default', () => cE), n.d(_, 'Geom', () => aE), n.d(_, 'install', () => uE); const b = {}; n.r(b), n.d(b, 'default', () => xC), n.d(b, 'Map', () => oC), n.d(b, 'View', () => bC), n.d(b, 'install', () => wC); const w = {}; n.r(w), n.d(w, 'default', () => DC), n.d(w, 'Source', () => MC), n.d(w, 'install', () => NC); const x = {}; n.r(x), n.d(x, 'default', () => uR), n.d(x, 'Interaction', () => sR), n.d(x, 'install', () => aR); const E = {}; n.r(E), n.d(E, 'default', () => wR), n.d(E, 'Geom', () => _R), n.d(E, 'install', () => bR); const S = {}; n.r(S), n.d(S, 'default', () => jR), n.d(S, 'Geom', () => AR), n.d(S, 'install', () => FR); const T = {}; n.r(T), n.d(T, 'default', () => WR), n.d(T, 'Geom', () => YR), n.d(T, 'install', () => XR); const O = {}; n.r(O), n.d(O, 'default', () => lI), n.d(O, 'Source', () => cI), n.d(O, 'install', () => hI); const C = {}; n.r(C), n.d(C, 'default', () => RI), n.d(C, 'Overlay', () => OI), n.d(C, 'install', () => CI); const R = {}; n.r(R), n.d(R, 'default', () => VI), n.d(R, 'Geom', () => $I), n.d(R, 'install', () => GI); const I = {}; n.r(I), n.d(I, 'default', () => tP), n.d(I, 'Geom', () => JI), n.d(I, 'install', () => QI); const P = {}; n.r(P), n.d(P, 'default', () => pP), n.d(P, 'Style', () => lP), n.d(P, 'install', () => fP); const L = {}; n.r(L), n.d(L, 'default', () => MP), n.d(L, 'Interaction', () => jP), n.d(L, 'install', () => kP); const A = {}; n.r(A), n.d(A, 'default', () => QP), n.d(A, 'Interaction', () => ZP), n.d(A, 'install', () => JP); const F = {}; n.r(F), n.d(F, 'default', () => pL), n.d(F, 'Source', () => lL), n.d(F, 'install', () => fL); const j = {}; n.r(j), n.d(j, 'default', () => PL), n.d(j, 'Source', () => RL), n.d(j, 'install', () => IL); const k = {}; n.r(k), n.d(k, 'default', () => UL), n.d(k, 'Style', () => VL), n.d(k, 'install', () => BL); const M = {}; n.r(M), n.d(M, 'default', () => nA), n.d(M, 'Style', () => tA), n.d(M, 'install', () => eA); const N = {}; n.r(N), n.d(N, 'default', () => gA), n.d(N, 'Style', () => dA), n.d(N, 'install', () => vA); const D = {}; n.r(D), n.d(D, 'default', () => IA), n.d(D, 'Style', () => CA), n.d(D, 'install', () => RA); const $ = {}; n.r($), n.d($, 'default', () => zA), n.d($, 'Layer', () => BA), n.d($, 'install', () => UA); const G = {}; n.r(G), n.d(G, 'default', () => iF), n.d(G, 'Layer', () => eF), n.d(G, 'install', () => nF); const V = {}; n.r(V), n.d(V, 'default', () => JF), n.d(V, 'Source', () => qF), n.d(V, 'install', () => ZF); const B = {}; n.r(B), n.d(B, 'default', () => pj), n.d(B, 'Layer', () => lj), n.d(B, 'install', () => fj); const U = {}; n.r(U), n.d(U, 'default', () => jj), n.d(U, 'Source', () => Aj), n.d(U, 'install', () => Fj); const z = {}; n.r(z), n.d(z, 'default', () => Hj), n.d(z, 'Source', () => Wj), n.d(z, 'install', () => Kj); const Y = {}; n.r(Y), n.d(Y, 'default', () => pk), n.d(Y, 'Source', () => lk), n.d(Y, 'install', () => fk); const X = {}; function W() { return (function () { throw new Error('Unimplemented abstract method.'); }()); }n.r(X), n.d(X, 'default', () => Sk), n.d(X, 'Source', () => xk), n.d(X, 'install', () => Ek); let K = 0; function H(t) { return t.ol_uid || (t.ol_uid = String(++K)); } const q = '5.3.0'; const Z = (function (t) { function e(e) { const n = q === 'latest' ? q : `v${q.split('-')[0]}`; const i = `Assertion failed. See https://openlayers.org/en/${n}/doc/errors/#${e} for details.`; t.call(this, i), this.code = e, this.name = 'AssertionError', this.message = i; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Error)); const J = Z; function Q(t, e) { if (!t) throw new J(e); } const tt = {
      BOTTOM_LEFT: 'bottom-left', BOTTOM_RIGHT: 'bottom-right', TOP_LEFT: 'top-left', TOP_RIGHT: 'top-right',
    }; const et = {
      UNKNOWN: 0, INTERSECTING: 1, ABOVE: 2, RIGHT: 4, BELOW: 8, LEFT: 16,
    }; function nt(t) { for (var e = lt(), n = 0, i = t.length; n < i; ++n)_t(e, t[n]); return e; } function it(t, e, n) { const i = Math.min.apply(null, t); const r = Math.min.apply(null, e); const o = Math.max.apply(null, t); const s = Math.max.apply(null, e); return ft(i, r, o, s, n); } function rt(t, e, n) { return n ? (n[0] = t[0] - e, n[1] = t[1] - e, n[2] = t[2] + e, n[3] = t[3] + e, n) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e]; } function ot(t, e) { return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice(); } function st(t, e, n) { let i; let r; return i = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0, r = n < t[1] ? t[1] - n : t[3] < n ? n - t[3] : 0, i * i + r * r; } function at(t, e) { return ct(t, e[0], e[1]); } function ut(t, e) { return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3]; } function ct(t, e, n) { return t[0] <= e && e <= t[2] && t[1] <= n && n <= t[3]; } function ht(t, e) { const n = t[0]; const i = t[1]; const r = t[2]; const o = t[3]; const s = e[0]; const a = e[1]; let u = et.UNKNOWN; return s < n ? u |= et.LEFT : s > r && (u |= et.RIGHT), a < i ? u |= et.BELOW : a > o && (u |= et.ABOVE), u === et.UNKNOWN && (u = et.INTERSECTING), u; } function lt() { return [1 / 0, 1 / 0, -1 / 0, -1 / 0]; } function ft(t, e, n, i, r) { return r ? (r[0] = t, r[1] = e, r[2] = n, r[3] = i, r) : [t, e, n, i]; } function pt(t) { return ft(1 / 0, 1 / 0, -1 / 0, -1 / 0, t); } function dt(t, e) { const n = t[0]; const i = t[1]; return ft(n, i, n, i, e); } function vt(t, e) { const n = pt(e); return bt(n, t); } function gt(t, e, n, i, r) { const o = pt(r); return wt(o, t, e, n, i); } function yt(t, e) { return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3]; } function mt(t, e) { return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t; } function _t(t, e) { e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]); } function bt(t, e) { for (let n = 0, i = e.length; n < i; ++n)_t(t, e[n]); return t; } function wt(t, e, n, i, r) { for (;n < i; n += r)xt(t, e[n], e[n + 1]); return t; } function xt(t, e, n) { t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], n), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], n); } function Et(t, e, n) { let i; return i = e.call(n, Tt(t)), i || (i = e.call(n, Ot(t)), i || (i = e.call(n, Ft(t)), i || (i = e.call(n, At(t)), i || !1))); } function St(t) { let e = 0; return Mt(t) || (e = jt(t) * Pt(t)), e; } function Tt(t) { return [t[0], t[1]]; } function Ot(t) { return [t[2], t[1]]; } function Ct(t) { return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2]; } function Rt(t, e) { let n; return e === tt.BOTTOM_LEFT ? n = Tt(t) : e === tt.BOTTOM_RIGHT ? n = Ot(t) : e === tt.TOP_LEFT ? n = At(t) : e === tt.TOP_RIGHT ? n = Ft(t) : Q(!1, 13), n; } function It(t, e, n, i, r) { const o = e * i[0] / 2; const s = e * i[1] / 2; const a = Math.cos(n); const u = Math.sin(n); const c = o * a; const h = o * u; const l = s * a; const f = s * u; const p = t[0]; const d = t[1]; const v = p - c + f; const g = p - c - f; const y = p + c - f; const m = p + c + f; const _ = d - h - l; const b = d - h + l; const w = d + h + l; const x = d + h - l; return ft(Math.min(v, g, y, m), Math.min(_, b, w, x), Math.max(v, g, y, m), Math.max(_, b, w, x), r); } function Pt(t) { return t[3] - t[1]; } function Lt(t, e, n) { const i = n || lt(); return kt(t, e) ? (t[0] > e[0] ? i[0] = t[0] : i[0] = e[0], t[1] > e[1] ? i[1] = t[1] : i[1] = e[1], t[2] < e[2] ? i[2] = t[2] : i[2] = e[2], t[3] < e[3] ? i[3] = t[3] : i[3] = e[3]) : pt(i), i; } function At(t) { return [t[0], t[3]]; } function Ft(t) { return [t[2], t[3]]; } function jt(t) { return t[2] - t[0]; } function kt(t, e) { return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1]; } function Mt(t) { return t[2] < t[0] || t[3] < t[1]; } function Nt(t, e) { return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t; } function Dt(t, e) { const n = (t[2] - t[0]) / 2 * (e - 1); const i = (t[3] - t[1]) / 2 * (e - 1); t[0] -= n, t[2] += n, t[1] -= i, t[3] += i; } function $t(t, e, n) { let i = !1; const r = ht(t, e); const o = ht(t, n); if (r === et.INTERSECTING || o === et.INTERSECTING)i = !0; else { let s; let a; const u = t[0]; const c = t[1]; const h = t[2]; const l = t[3]; const f = e[0]; const p = e[1]; const d = n[0]; const v = n[1]; const g = (v - p) / (d - f); o & et.ABOVE && !(r & et.ABOVE) && (s = d - (v - l) / g, i = s >= u && s <= h), i || !(o & et.RIGHT) || r & et.RIGHT || (a = v - (d - h) * g, i = a >= c && a <= l), i || !(o & et.BELOW) || r & et.BELOW || (s = d - (v - c) / g, i = s >= u && s <= h), i || !(o & et.LEFT) || r & et.LEFT || (a = v - (d - u) * g, i = a >= c && a <= l); } return i; } function Gt(t, e, n) { const i = [t[0], t[1], t[0], t[3], t[2], t[1], t[2], t[3]]; e(i, i, 2); const r = [i[0], i[2], i[4], i[6]]; const o = [i[1], i[3], i[5], i[7]]; return it(r, o, n); } function Vt(t, e, n) { return Math.min(Math.max(t, e), n); } const Bt = (function () { let t; return t = 'cosh' in Math ? Math.cosh : function (t) { const e = Math.exp(t); return (e + 1 / e) / 2; }, t; }()); function Ut(t, e, n, i, r, o) { const s = r - n; const a = o - i; if (s !== 0 || a !== 0) { const u = ((t - n) * s + (e - i) * a) / (s * s + a * a); u > 1 ? (n = r, i = o) : u > 0 && (n += s * u, i += a * u); } return zt(t, e, n, i); } function zt(t, e, n, i) { const r = n - t; const o = i - e; return r * r + o * o; } function Yt(t) { for (var e = t.length, n = 0; n < e; n++) { for (var i = n, r = Math.abs(t[n][n]), o = n + 1; o < e; o++) { const s = Math.abs(t[o][n]); s > r && (r = s, i = o); } if (r === 0) return null; const a = t[i]; t[i] = t[n], t[n] = a; for (let u = n + 1; u < e; u++) for (let c = -t[u][n] / t[n][n], h = n; h < e + 1; h++)n == h ? t[u][h] = 0 : t[u][h] += c * t[n][h]; } for (var l = new Array(e), f = e - 1; f >= 0; f--) { l[f] = t[f][e] / t[f][f]; for (let p = f - 1; p >= 0; p--)t[p][e] -= t[p][f] * l[f]; } return l; } function Xt(t) { return 180 * t / Math.PI; } function Wt(t) { return t * Math.PI / 180; } function Kt(t, e) { const n = t % e; return n * e < 0 ? n + e : n; } function Ht(t, e, n) { return t + n * (e - t); } const qt = typeof Object.assign === 'function' ? Object.assign : function (t, e) { const n = arguments; if (void 0 === t || t === null) throw new TypeError('Cannot convert undefined or null to object'); for (var i = Object(t), r = 1, o = arguments.length; r < o; ++r) { const s = n[r]; if (void 0 !== s && s !== null) for (const a in s)s.hasOwnProperty(a) && (i[a] = s[a]); } return i; }; function Zt(t) { for (const e in t) delete t[e]; } function Jt(t) { const e = []; for (const n in t)e.push(t[n]); return e; } function Qt(t) { let e; for (e in t) return !1; return !e; } function te(t, e, n) { return void 0 === n && (n = [0, 0]), n[0] = t[0] + 2 * e, n[1] = t[1] + 2 * e, n; } function ee(t) { return t[0] > 0 && t[1] > 0; } function ne(t, e, n) { return void 0 === n && (n = [0, 0]), n[0] = t[0] * e + 0.5 | 0, n[1] = t[1] * e + 0.5 | 0, n; } function ie(t, e) { return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : e[0] = e[1] = t, e); } const re = 0.5; const oe = !0; const se = {
      IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4, ABORT: 5,
    }; function ae(t) { return Math.pow(t, 3); } function ue(t) { return 1 - ae(1 - t); } function ce(t) { return 3 * t * t - 2 * t * t * t; } function he(t) { return t; } const le = function () { this.disposed_ = !1; }; le.prototype.dispose = function () { this.disposed_ || (this.disposed_ = !0, this.disposeInternal()); }, le.prototype.disposeInternal = function () {}; const fe = le; function pe(t) { const e = function (e) { const n = t.listener; const i = t.bindTo || t.target; return t.callOnce && xe(t), n.call(i, e); }; return t.boundListener = e, e; } function de(t, e, n, i) { for (var r, o = 0, s = t.length; o < s; ++o) if (r = t[o], r.listener === e && r.bindTo === n) return i && (r.deleteIndex = o), r; } function ve(t, e) { const n = ge(t); return n ? n[e] : void 0; } function ge(t, e) { let n = t.ol_lm; return !n && e && (n = t.ol_lm = {}), n; } function ye(t) { delete t.ol_lm; } function me(t, e) { const n = ve(t, e); if (n) { for (let i = 0, r = n.length; i < r; ++i)t.removeEventListener(e, n[i].boundListener), Zt(n[i]); n.length = 0; const o = ge(t); o && (delete o[e], Object.keys(o).length === 0 && ye(t)); } } function _e(t, e, n, i, r) {
      const o = ge(t, !0); let s = o[e]; s || (s = o[e] = []); let a = de(s, n, i, !1); return a ? r || (a.callOnce = !1) : (a = {
        bindTo: i, callOnce: !!r, listener: n, target: t, type: e,
      }, t.addEventListener(e, pe(a)), s.push(a)), a;
    } function be(t, e, n, i) { return _e(t, e, n, i, !0); } function we(t, e, n, i) { const r = ve(t, e); if (r) { const o = de(r, n, i, !0); o && xe(o); } } function xe(t) { if (t && t.target) { t.target.removeEventListener(t.type, t.boundListener); const e = ve(t.target, t.type); if (e) { const n = 'deleteIndex' in t ? t.deleteIndex : e.indexOf(t); n !== -1 && e.splice(n, 1), e.length === 0 && me(t.target, t.type); }Zt(t); } } function Ee(t) { const e = ge(t); if (e) for (const n in e)me(t, n); } function Se() { return !0; } function Te() { return !1; } function Oe() {} const Ce = function (t) { this.propagationStopped, this.type = t, this.target = null; }; function Re(t) { t.stopPropagation(); }Ce.prototype.preventDefault = function () { this.propagationStopped = !0; }, Ce.prototype.stopPropagation = function () { this.propagationStopped = !0; }; const Ie = Ce; const Pe = (function (t) { function e() { t.call(this), this.pendingRemovals_ = {}, this.dispatching_ = {}, this.listeners_ = {}; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.addEventListener = function (t, e) { let n = this.listeners_[t]; n || (n = this.listeners_[t] = []), n.indexOf(e) === -1 && n.push(e); }, e.prototype.dispatchEvent = function (t) { const e = typeof t === 'string' ? new Ie(t) : t; const n = e.type; e.target = this; let i; const r = this.listeners_[n]; if (r) { n in this.dispatching_ || (this.dispatching_[n] = 0, this.pendingRemovals_[n] = 0), ++this.dispatching_[n]; for (let o = 0, s = r.length; o < s; ++o) if (!1 === r[o].call(this, e) || e.propagationStopped) { i = !1; break; } if (--this.dispatching_[n], this.dispatching_[n] === 0) { let a = this.pendingRemovals_[n]; delete this.pendingRemovals_[n]; while (a--) this.removeEventListener(n, Oe); delete this.dispatching_[n]; } return i; } }, e.prototype.disposeInternal = function () { Ee(this); }, e.prototype.getListeners = function (t) { return this.listeners_[t]; }, e.prototype.hasListener = function (t) { return t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0; }, e.prototype.removeEventListener = function (t, e) { const n = this.listeners_[t]; if (n) { const i = n.indexOf(e); t in this.pendingRemovals_ ? (n[i] = Oe, ++this.pendingRemovals_[t]) : (n.splice(i, 1), n.length === 0 && delete this.listeners_[t]); } }, e; }(fe)); const Le = Pe; const Ae = {
      CHANGE: 'change', CLEAR: 'clear', CONTEXTMENU: 'contextmenu', CLICK: 'click', DBLCLICK: 'dblclick', DRAGENTER: 'dragenter', DRAGOVER: 'dragover', DROP: 'drop', ERROR: 'error', KEYDOWN: 'keydown', KEYPRESS: 'keypress', LOAD: 'load', MOUSEDOWN: 'mousedown', MOUSEMOVE: 'mousemove', MOUSEOUT: 'mouseout', MOUSEUP: 'mouseup', MOUSEWHEEL: 'mousewheel', MSPOINTERDOWN: 'MSPointerDown', RESIZE: 'resize', TOUCHSTART: 'touchstart', TOUCHMOVE: 'touchmove', TOUCHEND: 'touchend', WHEEL: 'wheel',
    }; const Fe = (function (t) { function e(e, n, i) { t.call(this); const r = i || {}; this.tileCoord = e, this.state = n, this.interimTile = null, this.key = '', this.transition_ = void 0 === r.transition ? 250 : r.transition, this.transitionStarts_ = {}; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.changed = function () { this.dispatchEvent(Ae.CHANGE); }, e.prototype.getKey = function () { return `${this.key}/${this.tileCoord}`; }, e.prototype.getInterimTile = function () { if (!this.interimTile) return this; let t = this.interimTile; do { if (t.getState() == se.LOADED) return t; t = t.interimTile; } while (t);return this; }, e.prototype.refreshInterimChain = function () { if (this.interimTile) { let t = this.interimTile; let e = this; do { if (t.getState() == se.LOADED) { t.interimTile = null; break; }t.getState() == se.LOADING ? e = t : t.getState() == se.IDLE ? e.interimTile = t.interimTile : e = t, t = e.interimTile; } while (t); } }, e.prototype.getTileCoord = function () { return this.tileCoord; }, e.prototype.getState = function () { return this.state; }, e.prototype.setState = function (t) { this.state = t, this.changed(); }, e.prototype.load = function () {}, e.prototype.getAlpha = function (t, e) { if (!this.transition_) return 1; let n = this.transitionStarts_[t]; if (n) { if (n === -1) return 1; } else n = e, this.transitionStarts_[t] = n; const i = e - n + 1e3 / 60; return i >= this.transition_ ? 1 : ae(i / this.transition_); }, e.prototype.inTransition = function (t) { return !!this.transition_ && this.transitionStarts_[t] !== -1; }, e.prototype.endTransition = function (t) { this.transition_ && (this.transitionStarts_[t] = -1); }, e; }(Le)); const je = Fe; function ke(t, e) { const n = document.createElement('canvas'); return t && (n.width = t), e && (n.height = e), n.getContext('2d'); } function Me(t) { let e = t.offsetWidth; const n = getComputedStyle(t); return e += parseInt(n.marginLeft, 10) + parseInt(n.marginRight, 10), e; } function Ne(t) { let e = t.offsetHeight; const n = getComputedStyle(t); return e += parseInt(n.marginTop, 10) + parseInt(n.marginBottom, 10), e; } function De(t, e) { const n = e.parentNode; n && n.replaceChild(t, e); } function $e(t) { return t && t.parentNode ? t.parentNode.removeChild(t) : null; } function Ge(t) { while (t.lastChild)t.removeChild(t.lastChild); } const Ve = (function (t) { function e(e, n, i, r, o, s) { t.call(this, e, n, s), this.crossOrigin_ = r, this.src_ = i, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.imageListenerKeys_ = null, this.tileLoadFunction_ = o; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.state == se.LOADING && (this.unlistenImage_(), this.image_ = Be()), this.interimTile && this.interimTile.dispose(), this.state = se.ABORT, this.changed(), t.prototype.disposeInternal.call(this); }, e.prototype.getImage = function () { return this.image_; }, e.prototype.getKey = function () { return this.src_; }, e.prototype.handleImageError_ = function () { this.state = se.ERROR, this.unlistenImage_(), this.image_ = Be(), this.changed(); }, e.prototype.handleImageLoad_ = function () { const t = this.image_; t.naturalWidth && t.naturalHeight ? this.state = se.LOADED : this.state = se.EMPTY, this.unlistenImage_(), this.changed(); }, e.prototype.load = function () { this.state == se.ERROR && (this.state = se.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == se.IDLE && (this.state = se.LOADING, this.changed(), this.imageListenerKeys_ = [be(this.image_, Ae.ERROR, this.handleImageError_, this), be(this.image_, Ae.LOAD, this.handleImageLoad_, this)], this.tileLoadFunction_(this, this.src_)); }, e.prototype.unlistenImage_ = function () { this.imageListenerKeys_.forEach(xe), this.imageListenerKeys_ = null; }, e; }(je)); function Be() { const t = ke(1, 1); return t.fillStyle = 'rgba(0,0,0,0)', t.fillRect(0, 0, 1, 1), t.canvas; } const Ue = Ve; const ze = (function (t) {
      function e(e) { t.call(this), this.highWaterMark = void 0 !== e ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.canExpireCache = function () { return this.getCount() > this.highWaterMark; }, e.prototype.clear = function () { this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null, this.dispatchEvent(Ae.CLEAR); }, e.prototype.containsKey = function (t) { return this.entries_.hasOwnProperty(t); }, e.prototype.forEach = function (t, e) { let n = this.oldest_; while (n)t.call(e, n.value_, n.key_, this), n = n.newer; }, e.prototype.get = function (t) { const e = this.entries_[t]; return Q(void 0 !== e, 15), e === this.newest_ ? e.value_ : (e === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (e.newer.older = e.older, e.older.newer = e.newer), e.newer = null, e.older = this.newest_, this.newest_.newer = e, this.newest_ = e, e.value_); }, e.prototype.remove = function (t) { const e = this.entries_[t]; return Q(void 0 !== e, 15), e === this.newest_ ? (this.newest_ = e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_; }, e.prototype.getCount = function () { return this.count_; }, e.prototype.getKeys = function () { let t; const e = new Array(this.count_); let n = 0; for (t = this.newest_; t; t = t.older)e[n++] = t.key_; return e; }, e.prototype.getValues = function () { let t; const e = new Array(this.count_); let n = 0; for (t = this.newest_; t; t = t.older)e[n++] = t.value_; return e; }, e.prototype.peekLast = function () { return this.oldest_.value_; }, e.prototype.peekLastKey = function () { return this.oldest_.key_; }, e.prototype.peekFirstKey = function () { return this.newest_.key_; }, e.prototype.pop = function () { const t = this.oldest_; return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_; }, e.prototype.replace = function (t, e) { this.get(t), this.entries_[t].value_ = e; }, e.prototype.set = function (t, e) {
        Q(!(t in this.entries_), 16); const n = {
          key_: t, newer: null, older: this.newest_, value_: e,
        }; this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[t] = n, ++this.count_;
      }, e.prototype.setSize = function (t) { this.highWaterMark = t; }, e.prototype.prune = function () { while (this.canExpireCache()) this.pop(); }, e;
    }(Le)); const Ye = ze; function Xe(t, e, n, i) { return void 0 !== i ? (i[0] = t, i[1] = e, i[2] = n, i) : [t, e, n]; } function We(t, e, n) { return `${t}/${e}/${n}`; } function Ke(t) { return We(t[0], t[1], t[2]); } function He(t) { return t.split('/').map(Number); } function qe(t) { return (t[1] << t[0]) + t[2]; } function Ze(t) { let e; let n; const i = t[0]; const r = new Array(i); let o = 1 << i - 1; for (e = 0; e < i; ++e)n = 48, t[1] & o && (n += 1), t[2] & o && (n += 2), r[e] = String.fromCharCode(n), o >>= 1; return r.join(''); } function Je(t, e) { const n = t[0]; const i = t[1]; const r = t[2]; if (e.getMinZoom() > n || n > e.getMaxZoom()) return !1; let o; const s = e.getExtent(); return o = s ? e.getTileRangeForExtentAndZ(s, n) : e.getFullTileRange(n), !o || o.containsXY(i, r); } const Qe = (function (t) { function e(e) { t.call(this, e); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.expireCache = function (t) { while (this.canExpireCache()) { const e = this.peekLast(); const n = e.tileCoord[0].toString(); if (n in t && t[n].contains(e.tileCoord)) break; this.pop().dispose(); } }, e.prototype.pruneExceptNewestZ = function () { if (this.getCount() !== 0) { const t = this.peekFirstKey(); const e = He(t); const n = e[0]; this.forEach(function (t) { t.tileCoord[0] !== n && (this.remove(Ke(t.tileCoord)), t.dispose()); }, this); } }, e; }(Ye)); const tn = Qe; const en = {
      POINT: 'Point', LINE_STRING: 'LineString', LINEAR_RING: 'LinearRing', POLYGON: 'Polygon', MULTI_POINT: 'MultiPoint', MULTI_LINE_STRING: 'MultiLineString', MULTI_POLYGON: 'MultiPolygon', GEOMETRY_COLLECTION: 'GeometryCollection', CIRCLE: 'Circle',
    }; const nn = 6371008.8; function rn(t, e, n) { const i = n || nn; const r = Wt(t[1]); const o = Wt(e[1]); const s = (o - r) / 2; const a = Wt(e[0] - t[0]) / 2; const u = Math.sin(s) * Math.sin(s) + Math.sin(a) * Math.sin(a) * Math.cos(r) * Math.cos(o); return 2 * i * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)); } function on(t, e, n, i) { const r = i || nn; const o = Wt(t[1]); const s = Wt(t[0]); const a = e / r; const u = Math.asin(Math.sin(o) * Math.cos(a) + Math.cos(o) * Math.sin(a) * Math.cos(n)); const c = s + Math.atan2(Math.sin(n) * Math.sin(a) * Math.cos(o), Math.cos(a) - Math.sin(o) * Math.sin(u)); return [Xt(c), Xt(u)]; } const sn = {
      DEGREES: 'degrees', FEET: 'ft', METERS: 'm', PIXELS: 'pixels', TILE_PIXELS: 'tile-pixels', USFEET: 'us-ft',
    }; const an = {}; an[sn.DEGREES] = 2 * Math.PI * 6370997 / 360, an[sn.FEET] = 0.3048, an[sn.METERS] = 1, an[sn.USFEET] = 1200 / 3937; const un = sn; const cn = function (t) { this.code_ = t.code, this.units_ = t.units, this.extent_ = void 0 !== t.extent ? t.extent : null, this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null, this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : 'enu', this.global_ = void 0 !== t.global && t.global, this.canWrapX_ = !(!this.global_ || !this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit; }; cn.prototype.canWrapX = function () { return this.canWrapX_; }, cn.prototype.getCode = function () { return this.code_; }, cn.prototype.getExtent = function () { return this.extent_; }, cn.prototype.getUnits = function () { return this.units_; }, cn.prototype.getMetersPerUnit = function () { return this.metersPerUnit_ || an[this.units_]; }, cn.prototype.getWorldExtent = function () { return this.worldExtent_; }, cn.prototype.getAxisOrientation = function () { return this.axisOrientation_; }, cn.prototype.isGlobal = function () { return this.global_; }, cn.prototype.setGlobal = function (t) { this.global_ = t, this.canWrapX_ = !(!t || !this.extent_); }, cn.prototype.getDefaultTileGrid = function () { return this.defaultTileGrid_; }, cn.prototype.setDefaultTileGrid = function (t) { this.defaultTileGrid_ = t; }, cn.prototype.setExtent = function (t) { this.extent_ = t, this.canWrapX_ = !(!this.global_ || !t); }, cn.prototype.setWorldExtent = function (t) { this.worldExtent_ = t; }, cn.prototype.setGetPointResolution = function (t) { this.getPointResolutionFunc_ = t; }, cn.prototype.getPointResolutionFunc = function () { return this.getPointResolutionFunc_; }; const hn = cn; const ln = 6378137; const fn = Math.PI * ln; const pn = [-fn, -fn, fn, fn]; const dn = [-180, -85, 180, 85]; const vn = (function (t) {
      function e(e) {
        t.call(this, {
          code: e, units: un.METERS, extent: pn, global: !0, worldExtent: dn, getPointResolution(t, e) { return t / Bt(e[1] / ln); },
        });
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
    }(hn)); const gn = [new vn('EPSG:3857'), new vn('EPSG:102100'), new vn('EPSG:102113'), new vn('EPSG:900913'), new vn('urn:ogc:def:crs:EPSG:6.18:3:3857'), new vn('urn:ogc:def:crs:EPSG::3857'), new vn('http://www.opengis.net/gml/srs/epsg.xml#3857')]; function yn(t, e, n) { const i = t.length; const r = n > 1 ? n : 2; let o = e; void 0 === o && (o = r > 2 ? t.slice() : new Array(i)); for (let s = fn, a = 0; a < i; a += r) { o[a] = s * t[a] / 180; let u = ln * Math.log(Math.tan(Math.PI * (t[a + 1] + 90) / 360)); u > s ? u = s : u < -s && (u = -s), o[a + 1] = u; } return o; } function mn(t, e, n) { const i = t.length; const r = n > 1 ? n : 2; let o = e; void 0 === o && (o = r > 2 ? t.slice() : new Array(i)); for (let s = 0; s < i; s += r)o[s] = 180 * t[s] / fn, o[s + 1] = 360 * Math.atan(Math.exp(t[s + 1] / ln)) / Math.PI - 90; return o; } const _n = 6378137; const bn = [-180, -90, 180, 90]; const wn = Math.PI * _n / 180; const xn = (function (t) {
      function e(e, n) {
        t.call(this, {
          code: e, units: un.DEGREES, extent: bn, axisOrientation: n, global: !0, metersPerUnit: wn, worldExtent: bn,
        });
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
    }(hn)); const En = [new xn('CRS:84'), new xn('EPSG:4326', 'neu'), new xn('urn:ogc:def:crs:EPSG::4326', 'neu'), new xn('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new xn('urn:ogc:def:crs:OGC:1.3:CRS84'), new xn('urn:ogc:def:crs:OGC:2:84'), new xn('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new xn('urn:x-ogc:def:crs:EPSG:4326', 'neu')]; const Sn = {}; function Tn(t) { return Sn[t] || null; } function On(t, e) { Sn[t] = e; } const Cn = {}; function Rn(t, e, n) { const i = t.getCode(); const r = e.getCode(); i in Cn || (Cn[i] = {}), Cn[i][r] = n; } function In(t, e) { let n; return t in Cn && e in Cn[t] && (n = Cn[t][e]), n; } function Pn(t, e, n) { let i; if (void 0 !== e) { for (let r = 0, o = t.length; r < o; ++r)e[r] = t[r]; i = e; } else i = t.slice(); return i; } function Ln(t, e, n) { if (void 0 !== e && t !== e) { for (let i = 0, r = t.length; i < r; ++i)e[i] = t[i]; t = e; } return t; } function An(t) { On(t.getCode(), t), Rn(t, t, Pn); } function Fn(t) { t.forEach(An); } function jn(t) { return typeof t === 'string' ? Tn(t) : t || null; } function kn(t, e, n, i) { let r; t = jn(t); const o = t.getPointResolutionFunc(); if (o)r = o(e, n); else { const s = t.getUnits(); if (s == un.DEGREES && !i || i == un.DEGREES)r = e; else { const a = Bn(t, jn('EPSG:4326')); let u = [n[0] - e / 2, n[1], n[0] + e / 2, n[1], n[0], n[1] - e / 2, n[0], n[1] + e / 2]; u = a(u, u, 2); const c = rn(u.slice(0, 2), u.slice(2, 4)); const h = rn(u.slice(4, 6), u.slice(6, 8)); r = (c + h) / 2; const l = i ? an[i] : t.getMetersPerUnit(); void 0 !== l && (r /= l); } } return r; } function Mn(t) { Fn(t), t.forEach((e) => { t.forEach((t) => { e !== t && Rn(e, t, Pn); }); }); } function Nn(t, e, n, i) { t.forEach((t) => { e.forEach((e) => { Rn(t, e, n), Rn(e, t, i); }); }); } function Dn(t, e) { return t ? typeof t === 'string' ? jn(t) : t : jn(e); } function $n(t, e) { return zn(t, 'EPSG:4326', void 0 !== e ? e : 'EPSG:3857'); } function Gn(t, e) { const n = zn(t, void 0 !== e ? e : 'EPSG:3857', 'EPSG:4326'); const i = n[0]; return (i < -180 || i > 180) && (n[0] = Kt(i + 180, 360) - 180), n; } function Vn(t, e) { if (t === e) return !0; const n = t.getUnits() === e.getUnits(); if (t.getCode() === e.getCode()) return n; const i = Bn(t, e); return i === Pn && n; } function Bn(t, e) { const n = t.getCode(); const i = e.getCode(); let r = In(n, i); return r || (r = Ln), r; } function Un(t, e) { const n = jn(t); const i = jn(e); return Bn(n, i); } function zn(t, e, n) { const i = Un(e, n); return i(t, void 0, t.length); } function Yn(t, e, n) { const i = Un(e, n); return Gt(t, i); } function Xn() { Mn(gn), Mn(En), Nn(En, gn, yn, mn); } function Wn(t, e, n, i) { const r = zn(n, e, t); let o = kn(e, i, n); const s = e.getMetersPerUnit(); void 0 !== s && (o *= s); const a = t.getMetersPerUnit(); void 0 !== a && (o /= a); const u = t.getExtent(); if (!u || at(u, r)) { const c = kn(t, o, r) / o; isFinite(c) && c > 0 && (o /= c); } return o; } function Kn(t, e, n, i) { const r = n - t; const o = i - e; const s = Math.sqrt(r * r + o * o); return [Math.round(n + r / s), Math.round(i + o / s)]; } function Hn(t, e, n, i, r, o, s, a, u, c, h) { const l = ke(Math.round(n * t), Math.round(n * e)); if (u.length === 0) return l.canvas; l.scale(n, n); const f = lt(); u.forEach((t, e, n) => { mt(f, t.extent); }); const p = jt(f); const d = Pt(f); const v = ke(Math.round(n * p / i), Math.round(n * d / i)); const g = n / i; u.forEach((t, e, n) => { const i = t.extent[0] - f[0]; const r = -(t.extent[3] - f[3]); const o = jt(t.extent); const s = Pt(t.extent); v.drawImage(t.image, c, c, t.image.width - 2 * c, t.image.height - 2 * c, i * g, r * g, o * g, s * g); }); const y = At(s); return a.getTriangles().forEach((t, e, r) => { const s = t.source; const a = t.target; let u = s[0][0]; let c = s[0][1]; let h = s[1][0]; let p = s[1][1]; let d = s[2][0]; let g = s[2][1]; const m = (a[0][0] - y[0]) / o; const _ = -(a[0][1] - y[1]) / o; const b = (a[1][0] - y[0]) / o; const w = -(a[1][1] - y[1]) / o; const x = (a[2][0] - y[0]) / o; const E = -(a[2][1] - y[1]) / o; const S = u; const T = c; u = 0, c = 0, h -= S, p -= T, d -= S, g -= T; const O = [[h, p, 0, 0, b - m], [d, g, 0, 0, x - m], [0, 0, h, p, w - _], [0, 0, d, g, E - _]]; const C = Yt(O); if (C) { l.save(), l.beginPath(); const R = (m + b + x) / 3; const I = (_ + w + E) / 3; const P = Kn(R, I, m, _); const L = Kn(R, I, b, w); const A = Kn(R, I, x, E); l.moveTo(L[0], L[1]), l.lineTo(P[0], P[1]), l.lineTo(A[0], A[1]), l.clip(), l.transform(C[0], C[2], C[1], C[3], m, _), l.translate(f[0] - S, f[3] - T), l.scale(i / n, -i / n), l.drawImage(v.canvas, 0, 0), l.restore(); } }), h && (l.save(), l.strokeStyle = 'black', l.lineWidth = 1, a.getTriangles().forEach((t, e, n) => { const i = t.target; const r = (i[0][0] - y[0]) / o; const s = -(i[0][1] - y[1]) / o; const a = (i[1][0] - y[0]) / o; const u = -(i[1][1] - y[1]) / o; const c = (i[2][0] - y[0]) / o; const h = -(i[2][1] - y[1]) / o; l.beginPath(), l.moveTo(a, u), l.lineTo(r, s), l.lineTo(c, h), l.closePath(), l.stroke(); }), l.restore()), l.canvas; }Xn(); const qn = 10; const Zn = 0.25; const Jn = function (t, e, n, i, r) { this.sourceProj_ = t, this.targetProj_ = e; let o = {}; const s = Un(this.targetProj_, this.sourceProj_); this.transformInv_ = function (t) { const e = `${t[0]}/${t[1]}`; return o[e] || (o[e] = s(t)), o[e]; }, this.maxSourceExtent_ = i, this.errorThresholdSquared_ = r * r, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!i && !!this.sourceProj_.getExtent() && jt(i) == jt(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? jt(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? jt(this.targetProj_.getExtent()) : null; const a = At(n); const u = Ft(n); const c = Ot(n); const h = Tt(n); const l = this.transformInv_(a); const f = this.transformInv_(u); const p = this.transformInv_(c); const d = this.transformInv_(h); if (this.addQuad_(a, u, c, h, l, f, p, d, qn), this.wrapsXInSource_) { let v = 1 / 0; this.triangles_.forEach((t, e, n) => { v = Math.min(v, t.source[0][0], t.source[1][0], t.source[2][0]); }), this.triangles_.forEach((t) => { if (Math.max(t.source[0][0], t.source[1][0], t.source[2][0]) - v > this.sourceWorldWidth_ / 2) { const e = [[t.source[0][0], t.source[0][1]], [t.source[1][0], t.source[1][1]], [t.source[2][0], t.source[2][1]]]; e[0][0] - v > this.sourceWorldWidth_ / 2 && (e[0][0] -= this.sourceWorldWidth_), e[1][0] - v > this.sourceWorldWidth_ / 2 && (e[1][0] -= this.sourceWorldWidth_), e[2][0] - v > this.sourceWorldWidth_ / 2 && (e[2][0] -= this.sourceWorldWidth_); const n = Math.min(e[0][0], e[1][0], e[2][0]); const i = Math.max(e[0][0], e[1][0], e[2][0]); i - n < this.sourceWorldWidth_ / 2 && (t.source = e); } }); }o = {}; }; Jn.prototype.addTriangle_ = function (t, e, n, i, r, o) { this.triangles_.push({ source: [i, r, o], target: [t, e, n] }); }, Jn.prototype.addQuad_ = function (t, e, n, i, r, o, s, a, u) { const c = nt([r, o, s, a]); const h = this.sourceWorldWidth_ ? jt(c) / this.sourceWorldWidth_ : null; const l = this.sourceWorldWidth_; const f = this.sourceProj_.canWrapX() && h > 0.5 && h < 1; let p = !1; if (u > 0) { if (this.targetProj_.isGlobal() && this.targetWorldWidth_) { const d = nt([t, e, n, i]); const v = jt(d) / this.targetWorldWidth_; p = v > Zn || p; }!f && this.sourceProj_.isGlobal() && h && (p = h > Zn || p); } if (p || !this.maxSourceExtent_ || kt(c, this.maxSourceExtent_)) { if (!p && (!isFinite(r[0]) || !isFinite(r[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(s[0]) || !isFinite(s[1]) || !isFinite(a[0]) || !isFinite(a[1]))) { if (!(u > 0)) return; p = !0; } if (u > 0) { if (!p) { let g; const y = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2]; const m = this.transformInv_(y); if (f) { const _ = (Kt(r[0], l) + Kt(s[0], l)) / 2; g = _ - Kt(m[0], l); } else g = (r[0] + s[0]) / 2 - m[0]; const b = (r[1] + s[1]) / 2 - m[1]; const w = g * g + b * b; p = w > this.errorThresholdSquared_; } if (p) { if (Math.abs(t[0] - n[0]) <= Math.abs(t[1] - n[1])) { const x = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2]; const E = this.transformInv_(x); const S = [(i[0] + t[0]) / 2, (i[1] + t[1]) / 2]; const T = this.transformInv_(S); this.addQuad_(t, e, x, S, r, o, E, T, u - 1), this.addQuad_(S, x, n, i, T, E, s, a, u - 1); } else { const O = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2]; const C = this.transformInv_(O); const R = [(n[0] + i[0]) / 2, (n[1] + i[1]) / 2]; const I = this.transformInv_(R); this.addQuad_(t, O, R, i, r, C, I, a, u - 1), this.addQuad_(O, e, n, R, C, o, s, I, u - 1); } return; } } if (f) { if (!this.canWrapXInSource_) return; this.wrapsXInSource_ = !0; } this.addTriangle_(t, n, i, r, s, a), this.addTriangle_(t, e, n, r, o, s); } }, Jn.prototype.calculateSourceExtent = function () { const t = lt(); return this.triangles_.forEach((e, n, i) => { const r = e.source; _t(t, r[0]), _t(t, r[1]), _t(t, r[2]); }), t; }, Jn.prototype.getTriangles = function () { return this.triangles_; }; const Qn = Jn; const ti = (function (t) { function e(e, n, i, r, o, s, a, u, c, h, l) { t.call(this, o, se.IDLE), this.renderEdges_ = void 0 !== l && l, this.pixelRatio_ = a, this.gutter_ = u, this.canvas_ = null, this.sourceTileGrid_ = n, this.targetTileGrid_ = r, this.wrappedTileCoord_ = s || o, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0; const f = r.getTileCoordExtent(this.wrappedTileCoord_); const p = this.targetTileGrid_.getExtent(); let d = this.sourceTileGrid_.getExtent(); const v = p ? Lt(f, p) : f; if (St(v) !== 0) { const g = e.getExtent(); g && (d = d ? Lt(d, g) : g); const y = r.getResolution(this.wrappedTileCoord_[0]); const m = Ct(v); const _ = Wn(e, i, m, y); if (!isFinite(_) || _ <= 0) this.state = se.EMPTY; else { const b = void 0 !== h ? h : re; if (this.triangulation_ = new Qn(e, i, v, d, _ * b), this.triangulation_.getTriangles().length !== 0) { this.sourceZ_ = n.getZForResolution(_); let w = this.triangulation_.calculateSourceExtent(); if (d && (e.canWrapX() ? (w[1] = Vt(w[1], d[1], d[3]), w[3] = Vt(w[3], d[1], d[3])) : w = Lt(w, d)), St(w)) { for (let x = n.getTileRangeForExtentAndZ(w, this.sourceZ_), E = x.minX; E <= x.maxX; E++) for (let S = x.minY; S <= x.maxY; S++) { const T = c(this.sourceZ_, E, S, a); T && this.sourceTiles_.push(T); } this.sourceTiles_.length === 0 && (this.state = se.EMPTY); } else this.state = se.EMPTY; } else this.state = se.EMPTY; } } else this.state = se.EMPTY; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.state == se.LOADING && this.unlistenSources_(), t.prototype.disposeInternal.call(this); }, e.prototype.getImage = function () { return this.canvas_; }, e.prototype.reproject_ = function () { const t = []; if (this.sourceTiles_.forEach((e, n, i) => { e && e.getState() == se.LOADED && t.push({ extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord), image: e.getImage() }); }), this.sourceTiles_.length = 0, t.length === 0) this.state = se.ERROR; else { const e = this.wrappedTileCoord_[0]; const n = this.targetTileGrid_.getTileSize(e); const i = typeof n === 'number' ? n : n[0]; const r = typeof n === 'number' ? n : n[1]; const o = this.targetTileGrid_.getResolution(e); const s = this.sourceTileGrid_.getResolution(this.sourceZ_); const a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_); this.canvas_ = Hn(i, r, this.pixelRatio_, s, this.sourceTileGrid_.getExtent(), o, a, this.triangulation_, t, this.gutter_, this.renderEdges_), this.state = se.LOADED; } this.changed(); }, e.prototype.load = function () { if (this.state == se.IDLE) { this.state = se.LOADING, this.changed(); let t = 0; this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach((e, n, i) => { const r = e.getState(); if (r == se.IDLE || r == se.LOADING) { t++; var o = _e(e, Ae.CHANGE, function (n) { const i = e.getState(); i != se.LOADED && i != se.ERROR && i != se.EMPTY || (xe(o), t--, t === 0 && (this.unlistenSources_(), this.reproject_())); }, this); this.sourcesListenerKeys_.push(o); } }), this.sourceTiles_.forEach((t, e, n) => { const i = t.getState(); i == se.IDLE && t.load(); }), t === 0 && setTimeout(this.reproject_.bind(this), 0); } }, e.prototype.unlistenSources_ = function () { this.sourcesListenerKeys_.forEach(xe), this.sourcesListenerKeys_ = null; }, e; }(je)); const ei = ti; function ni(t, e) { const n = /\{z\}/g; const i = /\{x\}/g; const r = /\{y\}/g; const o = /\{-y\}/g; return function (s, a, u) { return s ? t.replace(n, s[0].toString()).replace(i, s[1].toString()).replace(r, () => { const t = -s[2] - 1; return t.toString(); }).replace(o, () => { const t = s[0]; const n = e.getFullTileRange(t); Q(n, 55); const i = n.getHeight() + s[2]; return i.toString(); }) : void 0; }; } function ii(t, e) { for (var n = t.length, i = new Array(n), r = 0; r < n; ++r)i[r] = ni(t[r], e); return ri(i); } function ri(t) { return t.length === 1 ? t[0] : function (e, n, i) { if (e) { const r = qe(e); const o = Kt(r, t.length); return t[o](e, n, i); } }; } function oi(t, e, n) {} function si(t) { const e = []; let n = /\{([a-z])-([a-z])\}/.exec(t); if (n) { let i; const r = n[1].charCodeAt(0); const o = n[2].charCodeAt(0); for (i = r; i <= o; ++i)e.push(t.replace(n[0], String.fromCharCode(i))); return e; } if (n = n = /\{(\d+)-(\d+)\}/.exec(t), n) { for (let s = parseInt(n[2], 10), a = parseInt(n[1], 10); a <= s; a++)e.push(t.replace(n[0], a.toString())); return e; } return e.push(t), e; } const ai = { PROPERTYCHANGE: 'propertychange' }; const ui = (function (t) { function e() { t.call(this), this.revision_ = 0; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.changed = function () { ++this.revision_, this.dispatchEvent(Ae.CHANGE); }, e.prototype.getRevision = function () { return this.revision_; }, e.prototype.on = function (t, e) { if (Array.isArray(t)) { for (var n = t.length, i = new Array(n), r = 0; r < n; ++r)i[r] = _e(this, t[r], e); return i; } return _e(this, t, e); }, e.prototype.once = function (t, e) { if (Array.isArray(t)) { for (var n = t.length, i = new Array(n), r = 0; r < n; ++r)i[r] = be(this, t[r], e); return i; } return be(this, t, e); }, e.prototype.un = function (t, e) { if (Array.isArray(t)) for (let n = 0, i = t.length; n < i; ++n)we(this, t[n], e); else we(this, t, e); }, e; }(Le)); const ci = ui; const hi = (function (t) { function e(e, n, i) { t.call(this, e), this.key = n, this.oldValue = i; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const li = (function (t) { function e(e) { t.call(this), H(this), this.values_ = {}, void 0 !== e && this.setProperties(e); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function (t) { let e; return this.values_.hasOwnProperty(t) && (e = this.values_[t]), e; }, e.prototype.getKeys = function () { return Object.keys(this.values_); }, e.prototype.getProperties = function () { return qt({}, this.values_); }, e.prototype.notify = function (t, e) { let n; n = pi(t), this.dispatchEvent(new hi(n, t, e)), n = ai.PROPERTYCHANGE, this.dispatchEvent(new hi(n, t, e)); }, e.prototype.set = function (t, e, n) { if (n) this.values_[t] = e; else { const i = this.values_[t]; this.values_[t] = e, i !== e && this.notify(t, i); } }, e.prototype.setProperties = function (t, e) { for (const n in t) this.set(n, t[n], e); }, e.prototype.unset = function (t, e) { if (t in this.values_) { const n = this.values_[t]; delete this.values_[t], e || this.notify(t, n); } }, e; }(ci)); const fi = {}; function pi(t) { return fi.hasOwnProperty(t) ? fi[t] : fi[t] = `change:${t}`; } const di = li; const vi = {
      UNDEFINED: 'undefined', LOADING: 'loading', READY: 'ready', ERROR: 'error',
    }; const gi = (function (t) { function e(e) { t.call(this), this.projection_ = jn(e.projection), this.attributions_ = yi(e.attributions), this.attributionsCollapsible_ = void 0 === e.attributionsCollapsible || e.attributionsCollapsible, this.loading = !1, this.state_ = void 0 !== e.state ? e.state : vi.READY, this.wrapX_ = void 0 !== e.wrapX && e.wrapX; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getAttributions = function () { return this.attributions_; }, e.prototype.getAttributionsCollapsible = function () { return this.attributionsCollapsible_; }, e.prototype.getProjection = function () { return this.projection_; }, e.prototype.getResolutions = function () { return W(); }, e.prototype.getState = function () { return this.state_; }, e.prototype.getWrapX = function () { return this.wrapX_; }, e.prototype.refresh = function () { this.changed(); }, e.prototype.setAttributions = function (t) { this.attributions_ = yi(t), this.changed(); }, e.prototype.setState = function (t) { this.state_ = t, this.changed(); }, e; }(di)); function yi(t) { return t ? Array.isArray(t) ? function (e) { return t; } : typeof t === 'function' ? t : function (e) { return [t]; } : null; } const mi = gi; const _i = 42; const bi = 256; const wi = function (t, e, n, i) { this.minX = t, this.maxX = e, this.minY = n, this.maxY = i; }; function xi(t, e, n, i, r) { return void 0 !== r ? (r.minX = t, r.maxX = e, r.minY = n, r.maxY = i, r) : new wi(t, e, n, i); }wi.prototype.contains = function (t) { return this.containsXY(t[1], t[2]); }, wi.prototype.containsTileRange = function (t) { return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY; }, wi.prototype.containsXY = function (t, e) { return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY; }, wi.prototype.equals = function (t) { return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY; }, wi.prototype.extend = function (t) { t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY); }, wi.prototype.getHeight = function () { return this.maxY - this.minY + 1; }, wi.prototype.getSize = function () { return [this.getWidth(), this.getHeight()]; }, wi.prototype.getWidth = function () { return this.maxX - this.minX + 1; }, wi.prototype.intersects = function (t) { return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY; }; const Ei = wi; function Si(t, e, n) { let i; let r; const o = n || Ti; let s = 0; let a = t.length; let u = !1; while (s < a)i = s + (a - s >> 1), r = +o(t[i], e), r < 0 ? s = i + 1 : (a = i, u = !r); return u ? s : ~s; } function Ti(t, e) { return t > e ? 1 : t < e ? -1 : 0; } function Oi(t, e) { return t.indexOf(e) >= 0; } function Ci(t, e, n) { let i; const r = t.length; if (t[0] <= e) return 0; if (e <= t[r - 1]) return r - 1; if (n > 0) { for (i = 1; i < r; ++i) if (t[i] < e) return i - 1; } else if (n < 0) { for (i = 1; i < r; ++i) if (t[i] <= e) return i; } else for (i = 1; i < r; ++i) { if (t[i] == e) return i; if (t[i] < e) return t[i - 1] - e < e - t[i] ? i - 1 : i; } return r - 1; } function Ri(t, e, n) { while (e < n) { const i = t[e]; t[e] = t[n], t[n] = i, ++e, --n; } } function Ii(t, e) { for (let n = Array.isArray(e) ? e : [e], i = n.length, r = 0; r < i; r++)t[t.length] = n[r]; } function Pi(t, e) { const n = t.indexOf(e); const i = n > -1; return i && t.splice(n, 1), i; } function Li(t, e) { const n = t.length; if (n !== e.length) return !1; for (let i = 0; i < n; i++) if (t[i] !== e[i]) return !1; return !0; } function Ai(t, e) { let n; const i = t.length; const r = Array(t.length); for (n = 0; n < i; n++)r[n] = { index: n, value: t[n] }; for (r.sort((t, n) => e(t.value, n.value) || t.index - n.index), n = 0; n < t.length; n++)t[n] = r[n].value; } function Fi(t, e, n) { const i = e || Ti; return t.every((e, r) => { if (r === 0) return !0; const o = i(t[r - 1], e); return !(o > 0 || n && o === 0); }); } const ji = [0, 0, 0]; const ki = function (t) { let e; if (this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0, this.resolutions_ = t.resolutions, Q(Fi(this.resolutions_, (t, e) => e - t, !0), 17), !t.origins) for (let n = 0, i = this.resolutions_.length - 1; n < i; ++n) if (e) { if (this.resolutions_[n] / this.resolutions_[n + 1] !== e) { e = void 0; break; } } else e = this.resolutions_[n] / this.resolutions_[n + 1]; this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = void 0 !== t.origin ? t.origin : null, this.origins_ = null, void 0 !== t.origins && (this.origins_ = t.origins, Q(this.origins_.length == this.resolutions_.length, 20)); const r = t.extent; void 0 === r || this.origin_ || this.origins_ || (this.origin_ = At(r)), Q(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18), this.tileSizes_ = null, void 0 !== t.tileSizes && (this.tileSizes_ = t.tileSizes, Q(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = void 0 !== t.tileSize ? t.tileSize : this.tileSizes_ ? null : bi, Q(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22), this.extent_ = void 0 !== r ? r : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], void 0 !== t.sizes ? this.fullTileRanges_ = t.sizes.map((t, e) => { const n = new Ei(Math.min(0, t[0]), Math.max(t[0] - 1, -1), Math.min(0, t[1]), Math.max(t[1] - 1, -1)); return n; }, this) : r && this.calculateTileRanges_(r); }; ki.prototype.forEachTileCoord = function (t, e, n) { for (let i = this.getTileRangeForExtentAndZ(t, e), r = i.minX, o = i.maxX; r <= o; ++r) for (let s = i.minY, a = i.maxY; s <= a; ++s)n([e, r, s]); }, ki.prototype.forEachTileCoordParentTileRange = function (t, e, n, i, r) { let o; let s; let a; let u = null; let c = t[0] - 1; this.zoomFactor_ === 2 ? (s = t[1], a = t[2]) : u = this.getTileCoordExtent(t, r); while (c >= this.minZoom) { if (this.zoomFactor_ === 2 ? (s = Math.floor(s / 2), a = Math.floor(a / 2), o = xi(s, s, a, a, i)) : o = this.getTileRangeForExtentAndZ(u, c, i), e.call(n, c, o)) return !0; --c; } return !1; }, ki.prototype.getExtent = function () { return this.extent_; }, ki.prototype.getMaxZoom = function () { return this.maxZoom; }, ki.prototype.getMinZoom = function () { return this.minZoom; }, ki.prototype.getOrigin = function (t) { return this.origin_ ? this.origin_ : this.origins_[t]; }, ki.prototype.getResolution = function (t) { return this.resolutions_[t]; }, ki.prototype.getResolutions = function () { return this.resolutions_; }, ki.prototype.getTileCoordChildTileRange = function (t, e, n) { if (t[0] < this.maxZoom) { if (this.zoomFactor_ === 2) { const i = 2 * t[1]; const r = 2 * t[2]; return xi(i, i + 1, r, r + 1, e); } const o = this.getTileCoordExtent(t, n); return this.getTileRangeForExtentAndZ(o, t[0] + 1, e); } return null; }, ki.prototype.getTileRangeExtent = function (t, e, n) { const i = this.getOrigin(t); const r = this.getResolution(t); const o = ie(this.getTileSize(t), this.tmpSize_); const s = i[0] + e.minX * o[0] * r; const a = i[0] + (e.maxX + 1) * o[0] * r; const u = i[1] + e.minY * o[1] * r; const c = i[1] + (e.maxY + 1) * o[1] * r; return ft(s, u, a, c, n); }, ki.prototype.getTileRangeForExtentAndZ = function (t, e, n) { const i = ji; this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, i); const r = i[1]; const o = i[2]; return this.getTileCoordForXYAndZ_(t[2], t[3], e, !0, i), xi(r, i[1], o, i[2], n); }, ki.prototype.getTileCoordCenter = function (t) { const e = this.getOrigin(t[0]); const n = this.getResolution(t[0]); const i = ie(this.getTileSize(t[0]), this.tmpSize_); return [e[0] + (t[1] + 0.5) * i[0] * n, e[1] + (t[2] + 0.5) * i[1] * n]; }, ki.prototype.getTileCoordExtent = function (t, e) { const n = this.getOrigin(t[0]); const i = this.getResolution(t[0]); const r = ie(this.getTileSize(t[0]), this.tmpSize_); const o = n[0] + t[1] * r[0] * i; const s = n[1] + t[2] * r[1] * i; const a = o + r[0] * i; const u = s + r[1] * i; return ft(o, s, a, u, e); }, ki.prototype.getTileCoordForCoordAndResolution = function (t, e, n) { return this.getTileCoordForXYAndResolution_(t[0], t[1], e, !1, n); }, ki.prototype.getTileCoordForXYAndResolution_ = function (t, e, n, i, r) { const o = this.getZForResolution(n); const s = n / this.getResolution(o); const a = this.getOrigin(o); const u = ie(this.getTileSize(o), this.tmpSize_); const c = i ? 0.5 : 0; const h = i ? 0 : 0.5; const l = Math.floor((t - a[0]) / n + c); const f = Math.floor((e - a[1]) / n + h); let p = s * l / u[0]; let d = s * f / u[1]; return i ? (p = Math.ceil(p) - 1, d = Math.ceil(d) - 1) : (p = Math.floor(p), d = Math.floor(d)), Xe(o, p, d, r); }, ki.prototype.getTileCoordForXYAndZ_ = function (t, e, n, i, r) { const o = this.getOrigin(n); const s = this.getResolution(n); const a = ie(this.getTileSize(n), this.tmpSize_); const u = i ? 0.5 : 0; const c = i ? 0 : 0.5; const h = Math.floor((t - o[0]) / s + u); const l = Math.floor((e - o[1]) / s + c); let f = h / a[0]; let p = l / a[1]; return i ? (f = Math.ceil(f) - 1, p = Math.ceil(p) - 1) : (f = Math.floor(f), p = Math.floor(p)), Xe(n, f, p, r); }, ki.prototype.getTileCoordForCoordAndZ = function (t, e, n) { return this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, n); }, ki.prototype.getTileCoordResolution = function (t) { return this.resolutions_[t[0]]; }, ki.prototype.getTileSize = function (t) { return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t]; }, ki.prototype.getFullTileRange = function (t) { return this.fullTileRanges_ ? this.fullTileRanges_[t] : null; }, ki.prototype.getZForResolution = function (t, e) { const n = Ci(this.resolutions_, t, e || 0); return Vt(n, this.minZoom, this.maxZoom); }, ki.prototype.calculateTileRanges_ = function (t) { for (var e = this.resolutions_.length, n = new Array(e), i = this.minZoom; i < e; ++i)n[i] = this.getTileRangeForExtentAndZ(t, i); this.fullTileRanges_ = n; }; const Mi = ki; function Ni(t) { let e = t.getDefaultTileGrid(); return e || (e = Bi(t), t.setDefaultTileGrid(e)), e; } function Di(t, e, n) { const i = e[0]; const r = t.getTileCoordCenter(e); const o = Ui(n); if (at(o, r)) return e; const s = jt(o); const a = Math.ceil((o[0] - r[0]) / s); return r[0] += s * a, t.getTileCoordForCoordAndZ(r, i); } function $i(t, e, n, i) {
      const r = void 0 !== i ? i : tt.TOP_LEFT; const o = Vi(t, e, n); return new Mi({
        extent: t, origin: Rt(t, r), resolutions: o, tileSize: n,
      });
    } function Gi(t) {
      const e = t || {}; const n = e.extent || jn('EPSG:3857').getExtent(); const i = {
        extent: n, minZoom: e.minZoom, tileSize: e.tileSize, resolutions: Vi(n, e.maxZoom, e.tileSize),
      }; return new Mi(i);
    } function Vi(t, e, n) { for (var i = void 0 !== e ? e : _i, r = Pt(t), o = jt(t), s = ie(void 0 !== n ? n : bi), a = Math.max(o / s[0], r / s[1]), u = i + 1, c = new Array(u), h = 0; h < u; ++h)c[h] = a / Math.pow(2, h); return c; } function Bi(t, e, n, i) { const r = Ui(t); return $i(r, e, n, i); } function Ui(t) { t = jn(t); let e = t.getExtent(); if (!e) { const n = 180 * an[un.DEGREES] / t.getMetersPerUnit(); e = ft(-n, -n, n, n); } return e; } const zi = (function (t) {
      function e(e) {
        t.call(this, {
          attributions: e.attributions, attributionsCollapsible: e.attributionsCollapsible, projection: e.projection, state: e.state, wrapX: e.wrapX,
        }), this.opaque_ = void 0 !== e.opaque && e.opaque, this.tilePixelRatio_ = void 0 !== e.tilePixelRatio ? e.tilePixelRatio : 1, this.tileGrid = void 0 !== e.tileGrid ? e.tileGrid : null, this.tileCache = new tn(e.cacheSize), this.tmpSize = [0, 0], this.key_ = e.key || '', this.tileOptions = { transition: e.transition };
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.canExpireCache = function () { return this.tileCache.canExpireCache(); }, e.prototype.expireCache = function (t, e) { const n = this.getTileCacheForProjection(t); n && n.expireCache(e); }, e.prototype.forEachLoadedTile = function (t, e, n, i) { const r = this.getTileCacheForProjection(t); if (!r) return !1; for (var o, s, a, u = !0, c = n.minX; c <= n.maxX; ++c) for (let h = n.minY; h <= n.maxY; ++h)s = We(e, c, h), a = !1, r.containsKey(s) && (o = r.get(s), a = o.getState() === se.LOADED, a && (a = !1 !== i(o))), a || (u = !1); return u; }, e.prototype.getGutterForProjection = function (t) { return 0; }, e.prototype.getKey = function () { return this.key_; }, e.prototype.setKey = function (t) { this.key_ !== t && (this.key_ = t, this.changed()); }, e.prototype.getOpaque = function (t) { return this.opaque_; }, e.prototype.getResolutions = function () { return this.tileGrid.getResolutions(); }, e.prototype.getTile = function (t, e, n, i, r) { return W(); }, e.prototype.getTileGrid = function () { return this.tileGrid; }, e.prototype.getTileGridForProjection = function (t) { return this.tileGrid ? this.tileGrid : Ni(t); }, e.prototype.getTileCacheForProjection = function (t) { const e = this.getProjection(); return e && !Vn(e, t) ? null : this.tileCache; }, e.prototype.getTilePixelRatio = function (t) { return this.tilePixelRatio_; }, e.prototype.getTilePixelSize = function (t, e, n) { const i = this.getTileGridForProjection(n); const r = this.getTilePixelRatio(e); const o = ie(i.getTileSize(t), this.tmpSize); return r == 1 ? o : ne(o, r, this.tmpSize); }, e.prototype.getTileCoordForTileUrlFunction = function (t, e) { const n = void 0 !== e ? e : this.getProjection(); const i = this.getTileGridForProjection(n); return this.getWrapX() && n.isGlobal() && (t = Di(i, t, n)), Je(t, i) ? t : null; }, e.prototype.refresh = function () { this.tileCache.clear(), this.changed(); }, e.prototype.useTile = function (t, e, n, i) {}, e;
    }(mi)); const Yi = (function (t) { function e(e, n) { t.call(this, e), this.tile = n; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const Xi = zi; const Wi = { TILELOADSTART: 'tileloadstart', TILELOADEND: 'tileloadend', TILELOADERROR: 'tileloaderror' }; const Ki = (function (t) {
      function e(e) {
        t.call(this, {
          attributions: e.attributions, cacheSize: e.cacheSize, opaque: e.opaque, projection: e.projection, state: e.state, tileGrid: e.tileGrid, tilePixelRatio: e.tilePixelRatio, wrapX: e.wrapX, transition: e.transition, key: e.key, attributionsCollapsible: e.attributionsCollapsible,
        }), this.generateTileUrlFunction_ = !e.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, this.tileUrlFunction = e.tileUrlFunction ? e.tileUrlFunction.bind(this) : oi, this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), e.tileUrlFunction && this.setTileUrlFunction(e.tileUrlFunction, this.key_), this.tileLoadingKeys_ = {};
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getTileLoadFunction = function () { return this.tileLoadFunction; }, e.prototype.getTileUrlFunction = function () { return this.tileUrlFunction; }, e.prototype.getUrls = function () { return this.urls; }, e.prototype.handleTileChange = function (t) { let e; const n = t.target; const i = H(n); const r = n.getState(); r == se.LOADING ? (this.tileLoadingKeys_[i] = !0, e = Wi.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], e = r == se.ERROR ? Wi.TILELOADERROR : r == se.LOADED || r == se.ABORT ? Wi.TILELOADEND : void 0), void 0 != e && this.dispatchEvent(new Yi(e, n)); }, e.prototype.setTileLoadFunction = function (t) { this.tileCache.clear(), this.tileLoadFunction = t, this.changed(); }, e.prototype.setTileUrlFunction = function (t, e) { this.tileUrlFunction = t, this.tileCache.pruneExceptNewestZ(), typeof e !== 'undefined' ? this.setKey(e) : this.changed(); }, e.prototype.setUrl = function (t) { const e = this.urls = si(t); this.setUrls(e); }, e.prototype.setUrls = function (t) { this.urls = t; const e = t.join('\n'); this.generateTileUrlFunction_ ? this.setTileUrlFunction(ii(t, this.tileGrid), e) : this.setKey(e); }, e.prototype.useTile = function (t, e, n) { const i = We(t, e, n); this.tileCache.containsKey(i) && this.tileCache.get(i); }, e;
    }(Xi)); const Hi = Ki; const qi = (function (t) {
      function e(e) {
        t.call(this, {
          attributions: e.attributions, cacheSize: e.cacheSize, opaque: e.opaque, projection: e.projection, state: e.state, tileGrid: e.tileGrid, tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : Zi, tilePixelRatio: e.tilePixelRatio, tileUrlFunction: e.tileUrlFunction, url: e.url, urls: e.urls, wrapX: e.wrapX, transition: e.transition, key: e.key, attributionsCollapsible: e.attributionsCollapsible,
        }), this.crossOrigin = void 0 !== e.crossOrigin ? e.crossOrigin : null, this.tileClass = void 0 !== e.tileClass ? e.tileClass : Ue, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.canExpireCache = function () { if (!oe) return t.prototype.canExpireCache.call(this); if (this.tileCache.canExpireCache()) return !0; for (const e in this.tileCacheForProjection) if (this.tileCacheForProjection[e].canExpireCache()) return !0; return !1; }, e.prototype.expireCache = function (e, n) { if (oe) { const i = this.getTileCacheForProjection(e); for (const r in this.tileCache.expireCache(this.tileCache == i ? n : {}), this.tileCacheForProjection) { const o = this.tileCacheForProjection[r]; o.expireCache(o == i ? n : {}); } } else t.prototype.expireCache.call(this, e, n); }, e.prototype.getGutterForProjection = function (t) { return oe && this.getProjection() && t && !Vn(this.getProjection(), t) ? 0 : this.getGutter(); }, e.prototype.getGutter = function () { return 0; }, e.prototype.getOpaque = function (e) { return !(oe && this.getProjection() && e && !Vn(this.getProjection(), e)) && t.prototype.getOpaque.call(this, e); }, e.prototype.getTileGridForProjection = function (e) { if (!oe) return t.prototype.getTileGridForProjection.call(this, e); const n = this.getProjection(); if (!this.tileGrid || n && !Vn(n, e)) { const i = H(e); return i in this.tileGridForProjection || (this.tileGridForProjection[i] = Ni(e)), this.tileGridForProjection[i]; } return this.tileGrid; }, e.prototype.getTileCacheForProjection = function (e) { if (!oe) return t.prototype.getTileCacheForProjection.call(this, e); const n = this.getProjection(); if (!n || Vn(n, e)) return this.tileCache; const i = H(e); return i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new tn(this.tileCache.highWaterMark)), this.tileCacheForProjection[i]; }, e.prototype.createTile_ = function (t, e, n, i, r, o) { const s = [t, e, n]; const a = this.getTileCoordForTileUrlFunction(s, r); const u = a ? this.tileUrlFunction(a, i, r) : void 0; const c = new this.tileClass(s, void 0 !== u ? se.IDLE : se.EMPTY, void 0 !== u ? u : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions); return c.key = o, _e(c, Ae.CHANGE, this.handleTileChange, this), c; }, e.prototype.getTile = function (t, e, n, i, r) { const o = this.getProjection(); if (oe && o && r && !Vn(o, r)) { let s; const a = this.getTileCacheForProjection(r); const u = [t, e, n]; const c = Ke(u); a.containsKey(c) && (s = a.get(c)); const h = this.getKey(); if (s && s.key == h) return s; const l = this.getTileGridForProjection(o); const f = this.getTileGridForProjection(r); const p = this.getTileCoordForTileUrlFunction(u, r); const d = new ei(o, l, r, f, u, p, this.getTilePixelRatio(i), this.getGutter(), ((t, e, n, i) => this.getTileInternal(t, e, n, i, o)), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_); return d.key = h, s ? (d.interimTile = s, d.refreshInterimChain(), a.replace(c, d)) : a.set(c, d), d; } return this.getTileInternal(t, e, n, i, o || r); }, e.prototype.getTileInternal = function (t, e, n, i, r) { let o = null; const s = We(t, e, n); const a = this.getKey(); if (this.tileCache.containsKey(s)) { if (o = this.tileCache.get(s), o.key != a) { const u = o; o = this.createTile_(t, e, n, i, r, a), u.getState() == se.IDLE ? o.interimTile = u.interimTile : o.interimTile = u, o.refreshInterimChain(), this.tileCache.replace(s, o); } } else o = this.createTile_(t, e, n, i, r, a), this.tileCache.set(s, o); return o; }, e.prototype.setRenderReprojectionEdges = function (t) { if (oe && this.renderReprojectionEdges_ != t) { for (const e in this.renderReprojectionEdges_ = t, this.tileCacheForProjection) this.tileCacheForProjection[e].clear(); this.changed(); } }, e.prototype.setTileGridForProjection = function (t, e) { if (oe) { const n = jn(t); if (n) { const i = H(n); i in this.tileGridForProjection || (this.tileGridForProjection[i] = e); } } }, e;
    }(Hi)); function Zi(t, e) { t.getImage().src = e; } const Ji = qi; function Qi(t, e) { const n = []; Object.keys(e).forEach((t) => { e[t] !== null && void 0 !== e[t] && n.push(`${t}=${encodeURIComponent(e[t])}`); }); const i = n.join('&'); return t = t.replace(/[?&]$/, ''), t = t.indexOf('?') === -1 ? `${t}?` : `${t}&`, t + i; } const tr = (function (t) {
      function e(e) {
        const n = e || {}; t.call(this, {
          attributions: n.attributions, cacheSize: n.cacheSize, crossOrigin: n.crossOrigin, projection: n.projection, reprojectionErrorThreshold: n.reprojectionErrorThreshold, tileGrid: n.tileGrid, tileLoadFunction: n.tileLoadFunction, tileUrlFunction: er, url: n.url, urls: n.urls, wrapX: void 0 === n.wrapX || n.wrapX, transition: n.transition,
        }), this.params_ = n.params || {}, this.tmpExtent_ = lt(), this.setKey(this.getKeyForParams_());
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getKeyForParams_ = function () { let t = 0; const e = []; for (const n in this.params_)e[t++] = `${n}-${this.params_[n]}`; return e.join('/'); }, e.prototype.getParams = function () { return this.params_; }, e.prototype.getRequestUrl_ = function (t, e, n, i, r, o) { const s = this.urls; if (s) { let a; const u = r.getCode().split(':').pop(); if (o.SIZE = `${e[0]},${e[1]}`, o.BBOX = n.join(','), o.BBOXSR = u, o.IMAGESR = u, o.DPI = Math.round(o.DPI ? o.DPI * i : 90 * i), s.length == 1)a = s[0]; else { const c = Kt(qe(t), s.length); a = s[c]; } const h = a.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage'); return Qi(h, o); } }, e.prototype.getTilePixelRatio = function (t) { return t; }, e.prototype.updateParams = function (t) { qt(this.params_, t), this.setKey(this.getKeyForParams_()); }, e;
    }(Ji)); function er(t, e, n) { let i = this.getTileGrid(); if (i || (i = this.getTileGridForProjection(n)), !(i.getResolutions().length <= t[0])) { const r = i.getTileCoordExtent(t, this.tmpExtent_); let o = ie(i.getTileSize(t[0]), this.tmpSize); e != 1 && (o = ne(o, e, this.tmpSize)); const s = { F: 'image', FORMAT: 'PNG32', TRANSPARENT: !0 }; return qt(s, this.params_), this.getRequestUrl_(t, o, r, e, n, s); } } const nr = tr; const ir = n('268f'); const rr = n.n(ir); const or = n('e265'); const sr = n.n(or); const ar = n('a4bb'); const ur = n.n(ar); const cr = n('85f2'); const hr = n.n(cr); function lr(t, e, n) {
      return e in t ? hr()(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function fr(t) { for (let e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; let i = ur()(n); typeof sr.a === 'function' && (i = i.concat(sr()(n).filter(t => rr()(n, t).enumerable))), i.forEach((e) => { lr(t, e, n[e]); }); } return t; } const pr = n('f499'); const dr = n.n(pr); const vr = n('7618'); const gr = n('656a'); const yr = function (t) { return Object(gr.x)(t, (t, e, n) => { const i = ['FORMAT', 'F', 'LAYERS', 'LAYERDEFS', 'DYNAMICLAYERS', 'DPI', 'TRANSPARENT', 'TIME', 'LAYERTIMEOPTIONS', 'GDBVERSION', 'MAPSCALE', 'ROTATION', 'DATUMTRANSFORMATIONS', 'MAPRANGEVALUES', 'LAYERRANGEVALUES', 'LAYERPARAMETERVALUES', 'HISTORICMOMENT']; return n = n.toUpperCase(), i.includes(n) ? t : (t[n] = e, t); }, {}); }; const mr = function (t) { return t == null ? t : Object(vr.a)(t) === 'object' ? dr()(t) : t; }; const _r = {
      extParams: Object, format: { type: String, default: 'PNG32' }, layers: String, layerDefs: [Object, String], dynamicLayers: [Object, String], dpi: Number, transparent: { type: Boolean, default: !0 }, time: String, layerTimeOptions: [Object, String], gdbVersion: String, mapScale: String, rotation: Number, datumTransformations: [Array, String], mapRangeValues: [Array, String], layerRangeValues: [Array, String], layerParameterValues: [Array, String], historicMoment: Number,
    }; const br = {
      cleanExtParams() { return this.extParams ? yr(this.extParams) : void 0; },
      allParams() {
        return fr({}, this.cleanExtParams, {
          LAYERS: this.layers, FORMAT: this.format, LAYERDEFS: mr(this.layerDefs), DYNAMICLAYERS: mr(this.dynamicLayers), DPI: this.dpi, TRANSPARENT: this.transparent, TIME: mr(this.time), LAYERTIMEOPTIONS: mr(this.layerTimeOptions), GDBVERSION: this.gdbVersion, MAPSCALE: this.mapScale, ROTATION: this.rotation, DATUMTRANSFORMATIONS: mr(this.datumTransformations), MAPRANGEVALUES: mr(this.mapRangeValues), LAYERRANGEVALUES: mr(this.layerRangeValues), LAYERPARAMETERVALUES: mr(this.layerParameterValues), HISTORICMOMENT: mr(this.historicMoment),
        });
      },
    }; const wr = {}; const xr = {
      layers(t) { this.$source && this.$source.updateParams({ LAYERS: t }); }, format(t) { this.$source && this.$source.updateParams({ FORMAT: t }); }, layerDefs(t) { this.$source && this.$source.updateParams({ LAYERDEFS: mr(t) }); }, dynamicLayers(t) { this.$source && this.$source.updateParams({ DYNAMICLAYERS: mr(t) }); }, dpi(t) { this.$source && this.$source.updateParams({ DPI: t }); }, transparent(t) { this.$source && this.$source.updateParams({ TRANSPARENT: t }); }, time(t) { this.$source && this.$source.updateParams({ TIME: mr(t) }); }, layerTimeOptions(t) { this.$source && this.$source.updateParams({ LAYERTIMEOPTIONS: mr(t) }); }, gdbVersion(t) { this.$source && this.$source.updateParams({ GDBVERSION: t }); }, mapScale(t) { this.$source && this.$source.updateParams({ MAPSCALE: t }); }, rotation(t) { this.$source && this.$source.updateParams({ ROTATION: t }); }, datumTransformations(t) { this.$source && this.$source.updateParams({ DATUMTRANSFORMATIONS: mr(t) }); }, mapRangeValues(t) { this.$source && this.$source.updateParams({ MAPRANGEVALUES: mr(t) }); }, layerRangeValues(t) { this.$source && this.$source.updateParams({ LAYERRANGEVALUES: mr(t) }); }, layerParameterValues(t) { this.$source && this.$source.updateParams({ LAYERPARAMETERVALUES: mr(t) }); }, historicMoment(t) { this.$source && this.$source.updateParams({ HISTORICMOMENT: t }); }, extParams(t) { this.$source && this.$source.updateParams(t ? yr(t) : void 0); },
    }; const Er = {
      props: _r, computed: br, methods: wr, watch: xr,
    }; const Sr = Er; const Tr = (function (t) { function e(e) { if (t.call(this), this.id_ = void 0, this.geometryName_ = 'geometry', this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, _e(this, pi(this.geometryName_), this.handleGeometryChanged_, this), e) if (typeof e.getSimplifiedGeometry === 'function') { const n = e; this.setGeometry(n); } else { const i = e; this.setProperties(i); } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () { const t = new e(this.getProperties()); t.setGeometryName(this.getGeometryName()); const n = this.getGeometry(); n && t.setGeometry(n.clone()); const i = this.getStyle(); return i && t.setStyle(i), t; }, e.prototype.getGeometry = function () { return this.get(this.geometryName_); }, e.prototype.getId = function () { return this.id_; }, e.prototype.getGeometryName = function () { return this.geometryName_; }, e.prototype.getStyle = function () { return this.style_; }, e.prototype.getStyleFunction = function () { return this.styleFunction_; }, e.prototype.handleGeometryChange_ = function () { this.changed(); }, e.prototype.handleGeometryChanged_ = function () { this.geometryChangeKey_ && (xe(this.geometryChangeKey_), this.geometryChangeKey_ = null); const t = this.getGeometry(); t && (this.geometryChangeKey_ = _e(t, Ae.CHANGE, this.handleGeometryChange_, this)), this.changed(); }, e.prototype.setGeometry = function (t) { this.set(this.geometryName_, t); }, e.prototype.setStyle = function (t) { this.style_ = t, this.styleFunction_ = t ? Or(t) : void 0, this.changed(); }, e.prototype.setId = function (t) { this.id_ = t, this.changed(); }, e.prototype.setGeometryName = function (t) { we(this, pi(this.geometryName_), this.handleGeometryChanged_, this), this.geometryName_ = t, _e(this, pi(this.geometryName_), this.handleGeometryChanged_, this), this.handleGeometryChanged_(); }, e; }(di)); function Or(t) { if (typeof t === 'function') return t; let e; if (Array.isArray(t))e = t; else { Q(typeof t.getZIndex === 'function', 41); const n = t; e = [n]; } return function () { return e; }; } const Cr = Tr; const Rr = n('2b0e'); const Ir = n('c64e'); const Pr = n.n(Ir);
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    function Lr(t) { return t.getId() == null && t.setId(Pr()()), t; } function Ar(t) { let e; if (Object(gr.o)(t) || t instanceof Rr.a)e = t.id; else if (t instanceof Cr)e = t.getId(); else { if (!Object(gr.p)(t) && !Object(gr.m)(t)) throw new Error('Illegal feature format'); e = t; } return e; } function Fr(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function jr(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function kr(t, e) { return !e || Object(vr.a)(e) !== 'object' && typeof e !== 'function' ? jr(t) : e; } const Mr = n('061b'); const Nr = n.n(Mr); const Dr = n('4d16'); const $r = n.n(Dr); function Gr(t) { return Gr = $r.a ? Nr.a : function (t) { return t.__proto__ || Nr()(t); }, Gr(t); } const Vr = n('4aa6'); const Br = n.n(Vr); function Ur(t, e) { return Ur = $r.a || function (t, e) { return t.__proto__ = e, t; }, Ur(t, e); } function zr(t, e) { if (typeof e !== 'function' && e !== null) throw new TypeError('Super expression must either be null or a function'); t.prototype = Br()(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Ur(t, e); } const Yr = n('2d7d'); const Xr = n.n(Yr); function Wr(t) { return Function.toString.call(t).indexOf('[native code]') !== -1; } const Kr = n('a5b2'); const Hr = n.n(Kr); function qr() { if (typeof Reflect === 'undefined' || !Hr.a) return !1; if (Hr.a.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Hr()(Date, [], () => {})), !0; } catch (t) { return !1; } } function Zr(t, e, n) { return Zr = qr() ? Hr.a : function (t, e, n) { const i = [null]; i.push(...e); const r = Function.bind.apply(t, i); const o = new r(); return n && Ur(o, n.prototype), o; }, Zr(...arguments); } function Jr(t) {
      const e = typeof Xr.a === 'function' ? new Xr.a() : void 0; return Jr = function (t) {
        if (t === null || !Wr(t)) return t; if (typeof t !== 'function') throw new TypeError('Super expression must either be null or a function'); if (typeof e !== 'undefined') { if (e.has(t)) return e.get(t); e.set(t, n); } function n() { return Zr(t, arguments, Gr(this).constructor); } return n.prototype = Br()(t.prototype, {
          constructor: {
            value: n, enumerable: !1, writable: !0, configurable: !0,
          },
        }), Ur(n, t);
      }, Jr(t);
    }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const Qr = (function (t) { function e(t) { let n; return Fr(this, e), n = kr(this, Gr(e).call(this, t)), n.name = n.constructor.name, typeof Error.captureStackTrace === 'function' ? Error.captureStackTrace(jr(jr(n)), n.constructor) : n.stack = new Error(t).stack, n; } return zr(e, t), e; }(Jr(Error))); function to(t, e) { if (!t) throw new Qr(e || 'Assertion failed'); } function eo(t, e) { return to(t, e); } function no(t, e) { to(t instanceof e, 'value is an instance of '.concat(e.name)); } function io(t) { to(t.$map, 'component has "$map" property'); } function ro(t) { to(t.$view, 'component has "$view" property'); } function oo(t) { to(t.$geolocation, 'component has "$geolocation" property'); } function so(t) { to(t.$feature, 'component has "$feature" property'); } function ao(t) { to(t.$layer, 'component has "$layer" property'); } function uo(t) { to(t.$source, 'component has "$source" property'); } function co(t) { to(t.$geometry, 'component has "$geometry" property'); } function ho(t) { to(t.$interaction, 'component has "$interaction" property'); } function lo(t) { to(t.$overlay, 'component has "$overlay" property'); } function fo(t) { to(t.$graticule, 'component has "$graticule" property'); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const po = 'EPSG:4326'; const vo = 'EPSG:3857'; const go = 28; const yo = 0; const mo = 256; const _o = 'png'; const bo = 2; const wo = 2048; const xo = 1; const Eo = 0.5; const So = { CANVAS: 'canvas', WEBGL: 'webgl' }; const To = {
      POINT: 'Point', LINE_STRING: 'LineString', POLYGON: 'Polygon', MULTI_POINT: 'MultiPoint', MULTI_LINE_STRING: 'MultiLineString', MULTI_POLYGON: 'MultiPolygon', GEOMETRY_COLLECTION: 'GeometryCollection', CIRCLE: 'Circle',
    }; const Oo = {
      DEGREES: 'degrees', FEET: 'ft', METERS: 'm', PIXELS: 'pixels', TILE_PIXELS: 'tile-pixels', USFEET: 'us-ft',
    }; const Co = {
      BOTTOM_LEFT: 'bottom-left', BOTTOM_CENTER: 'bottom-center', BOTTOM_RIGHT: 'bottom-right', CENTER_LEFT: 'center-left', CENTER_CENTER: 'center-center', CENTER_RIGHT: 'center-right', TOP_LEFT: 'top-left', TOP_CENTER: 'top-center', TOP_RIGHT: 'top-right',
    }; const Ro = '1.3.0'; const Io = '1.0.0'; const Po = 'KVP'; const Lo = 'image/jpeg'; const Ao = n('a745'); const Fo = n.n(Ao); function jo(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), hr()(t, i.key, i); } } function ko(t, e, n) { return e && jo(t.prototype, e), n && jo(t, n), t; } const Mo = n('8feb'); const No = n.n(Mo); function Do(t, e) { while (!Object.prototype.hasOwnProperty.call(t, e)) if (t = Gr(t), t === null) break; return t; } function $o(t, e, n) { return $o = typeof Reflect !== 'undefined' && No.a ? No.a : function (t, e, n) { const i = Do(t, e); if (i) { const r = rr()(i, e); return r.get ? r.get.call(n) : r.value; } }, $o(t, e, n || t); } const Go = function () { this.dataProjection = null, this.defaultFeatureProjection = null; }; Go.prototype.getReadOptions = function (t, e) { let n; return e && (n = { dataProjection: e.dataProjection ? e.dataProjection : this.readProjection(t), featureProjection: e.featureProjection }), this.adaptOptions(n); }, Go.prototype.adaptOptions = function (t) { return qt({ dataProjection: this.dataProjection, featureProjection: this.defaultFeatureProjection }, t); }, Go.prototype.getLastExtent = function () { return null; }, Go.prototype.getType = function () { return W(); }, Go.prototype.readFeature = function (t, e) { return W(); }, Go.prototype.readFeatures = function (t, e) { return W(); }, Go.prototype.readGeometry = function (t, e) { return W(); }, Go.prototype.readProjection = function (t) { return W(); }, Go.prototype.writeFeature = function (t, e) { return W(); }, Go.prototype.writeFeatures = function (t, e) { return W(); }, Go.prototype.writeGeometry = function (t, e) { return W(); }; const Vo = Go; function Bo(t, e, n) { let i; const r = n ? jn(n.featureProjection) : null; const o = n ? jn(n.dataProjection) : null; if (i = r && o && !Vn(r, o) ? Array.isArray(t) ? Yn(t, o, r) : (e ? t.clone() : t).transform(e ? r : o, e ? o : r) : t, e && n && void 0 !== n.decimals && !Array.isArray(i)) { const s = Math.pow(10, n.decimals); const a = function (t) { for (let e = 0, n = t.length; e < n; ++e)t[e] = Math.round(t[e] * s) / s; return t; }; i === t && (i = t.clone()), i.applyTransform(a); } return i; } const Uo = {
      ARRAY_BUFFER: 'arraybuffer', JSON: 'json', TEXT: 'text', XML: 'xml',
    }; const zo = (function (t) { function e() { t.call(this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getType = function () { return Uo.JSON; }, e.prototype.readFeature = function (t, e) { return this.readFeatureFromObject(Yo(t), this.getReadOptions(t, e)); }, e.prototype.readFeatures = function (t, e) { return this.readFeaturesFromObject(Yo(t), this.getReadOptions(t, e)); }, e.prototype.readFeatureFromObject = function (t, e) { return W(); }, e.prototype.readFeaturesFromObject = function (t, e) { return W(); }, e.prototype.readGeometry = function (t, e) { return this.readGeometryFromObject(Yo(t), this.getReadOptions(t, e)); }, e.prototype.readGeometryFromObject = function (t, e) { return W(); }, e.prototype.readProjection = function (t) { return this.readProjectionFromObject(Yo(t)); }, e.prototype.readProjectionFromObject = function (t) { return W(); }, e.prototype.writeFeature = function (t, e) { return JSON.stringify(this.writeFeatureObject(t, e)); }, e.prototype.writeFeatureObject = function (t, e) { return W(); }, e.prototype.writeFeatures = function (t, e) { return JSON.stringify(this.writeFeaturesObject(t, e)); }, e.prototype.writeFeaturesObject = function (t, e) { return W(); }, e.prototype.writeGeometry = function (t, e) { return JSON.stringify(this.writeGeometryObject(t, e)); }, e.prototype.writeGeometryObject = function (t, e) { return W(); }, e; }(Vo)); function Yo(t) { if (typeof t === 'string') { const e = JSON.parse(t); return e || null; } return t !== null ? t : null; } const Xo = zo; function Wo(t, e, n, i, r, o) { for (var s = o || [], a = 0, u = e; u < n; u += i) { const c = t[u]; const h = t[u + 1]; s[a++] = r[0] * c + r[2] * h + r[4], s[a++] = r[1] * c + r[3] * h + r[5]; } return o && s.length != a && (s.length = a), s; } function Ko(t, e, n, i, r, o, s) { for (var a = s || [], u = Math.cos(r), c = Math.sin(r), h = o[0], l = o[1], f = 0, p = e; p < n; p += i) { const d = t[p] - h; const v = t[p + 1] - l; a[f++] = h + d * u - v * c, a[f++] = l + d * c + v * u; for (let g = p + 2; g < p + i; ++g)a[f++] = t[g]; } return s && a.length != f && (a.length = f), a; } function Ho(t, e, n, i, r, o, s, a) { for (var u = a || [], c = s[0], h = s[1], l = 0, f = e; f < n; f += i) { const p = t[f] - c; const d = t[f + 1] - h; u[l++] = c + r * p, u[l++] = h + o * d; for (let v = f + 2; v < f + i; ++v)u[l++] = t[v]; } return a && u.length != l && (u.length = l), u; } function qo(t, e, n, i, r, o, s) { for (var a = s || [], u = 0, c = e; c < n; c += i) { a[u++] = t[c] + r, a[u++] = t[c + 1] + o; for (let h = c + 2; h < c + i; ++h)a[u++] = t[h]; } return s && a.length != u && (a.length = u), a; } const Zo = new Array(6); function Jo() { return [1, 0, 0, 1, 0, 0]; } function Qo(t) { return es(t, 1, 0, 0, 1, 0, 0); } function ts(t, e) { const n = t[0]; const i = t[1]; const r = t[2]; const o = t[3]; const s = t[4]; const a = t[5]; const u = e[0]; const c = e[1]; const h = e[2]; const l = e[3]; const f = e[4]; const p = e[5]; return t[0] = n * u + r * c, t[1] = i * u + o * c, t[2] = n * h + r * l, t[3] = i * h + o * l, t[4] = n * f + r * p + s, t[5] = i * f + o * p + a, t; } function es(t, e, n, i, r, o, s) { return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t[4] = o, t[5] = s, t; } function ns(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t; } function is(t, e) { const n = e[0]; const i = e[1]; return e[0] = t[0] * n + t[2] * i + t[4], e[1] = t[1] * n + t[3] * i + t[5], e; } function rs(t, e, n) { return ts(t, es(Zo, e, 0, 0, n, 0, 0)); } function os(t, e, n) { return ts(t, es(Zo, 1, 0, 0, 1, e, n)); } function ss(t, e, n, i, r, o, s, a) { const u = Math.sin(o); const c = Math.cos(o); return t[0] = i * c, t[1] = r * u, t[2] = -i * u, t[3] = r * c, t[4] = s * i * c - a * i * u + e, t[5] = s * r * u + a * r * c + n, t; } function as(t) { const e = us(t); Q(e !== 0, 32); const n = t[0]; const i = t[1]; const r = t[2]; const o = t[3]; const s = t[4]; const a = t[5]; return t[0] = o / e, t[1] = -i / e, t[2] = -r / e, t[3] = n / e, t[4] = (r * a - o * s) / e, t[5] = -(n * a - i * s) / e, t; } function us(t) { return t[0] * t[3] - t[1] * t[2]; } const cs = Jo(); const hs = (function (t) { function e() { t.call(this), this.extent_ = lt(), this.extentRevision_ = -1, this.simplifiedGeometryCache = {}, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () { return W(); }, e.prototype.closestPointXY = function (t, e, n, i) { return W(); }, e.prototype.containsXY = function (t, e) { return !1; }, e.prototype.getClosestPoint = function (t, e) { const n = e || [NaN, NaN]; return this.closestPointXY(t[0], t[1], n, 1 / 0), n; }, e.prototype.intersectsCoordinate = function (t) { return this.containsXY(t[0], t[1]); }, e.prototype.computeExtent = function (t) { return W(); }, e.prototype.getExtent = function (t) { return this.extentRevision_ != this.getRevision() && (this.extent_ = this.computeExtent(this.extent_), this.extentRevision_ = this.getRevision()), Nt(this.extent_, t); }, e.prototype.rotate = function (t, e) { W(); }, e.prototype.scale = function (t, e, n) { W(); }, e.prototype.simplify = function (t) { return this.getSimplifiedGeometry(t * t); }, e.prototype.getSimplifiedGeometry = function (t) { return W(); }, e.prototype.getType = function () { return W(); }, e.prototype.applyTransform = function (t) { W(); }, e.prototype.intersectsExtent = function (t) { return W(); }, e.prototype.translate = function (t, e) { W(); }, e.prototype.transform = function (t, e) { const n = jn(t); const i = n.getUnits() == un.TILE_PIXELS ? function (t, i, r) { const o = n.getExtent(); const s = n.getWorldExtent(); const a = Pt(s) / Pt(o); return ss(cs, s[0], s[3], a, -a, 0, 0, 0), Wo(t, 0, t.length, r, cs, i), Un(n, e)(t, i, r); } : Un(n, e); return this.applyTransform(i), this; }, e; }(di)); const ls = hs; const fs = (function (t) { function e(e) { t.call(this), this.geometries_ = e || null, this.listenGeometriesChange_(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.unlistenGeometriesChange_ = function () { if (this.geometries_) for (let t = 0, e = this.geometries_.length; t < e; ++t)we(this.geometries_[t], Ae.CHANGE, this.changed, this); }, e.prototype.listenGeometriesChange_ = function () { if (this.geometries_) for (let t = 0, e = this.geometries_.length; t < e; ++t)_e(this.geometries_[t], Ae.CHANGE, this.changed, this); }, e.prototype.clone = function () { const t = new e(null); return t.setGeometries(this.geometries_), t; }, e.prototype.closestPointXY = function (t, e, n, i) { if (i < st(this.getExtent(), t, e)) return i; for (let r = this.geometries_, o = 0, s = r.length; o < s; ++o)i = r[o].closestPointXY(t, e, n, i); return i; }, e.prototype.containsXY = function (t, e) { for (let n = this.geometries_, i = 0, r = n.length; i < r; ++i) if (n[i].containsXY(t, e)) return !0; return !1; }, e.prototype.computeExtent = function (t) { pt(t); for (let e = this.geometries_, n = 0, i = e.length; n < i; ++n)mt(t, e[n].getExtent()); return t; }, e.prototype.getGeometries = function () { return ps(this.geometries_); }, e.prototype.getGeometriesArray = function () { return this.geometries_; }, e.prototype.getSimplifiedGeometry = function (t) { if (this.simplifiedGeometryRevision != this.getRevision() && (Zt(this.simplifiedGeometryCache), this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this; const n = t.toString(); if (this.simplifiedGeometryCache.hasOwnProperty(n)) return this.simplifiedGeometryCache[n]; for (var i = [], r = this.geometries_, o = !1, s = 0, a = r.length; s < a; ++s) { const u = r[s]; const c = u.getSimplifiedGeometry(t); i.push(c), c !== u && (o = !0); } if (o) { const h = new e(null); return h.setGeometriesArray(i), this.simplifiedGeometryCache[n] = h, h; } return this.simplifiedGeometryMaxMinSquaredTolerance = t, this; }, e.prototype.getType = function () { return en.GEOMETRY_COLLECTION; }, e.prototype.intersectsExtent = function (t) { for (let e = this.geometries_, n = 0, i = e.length; n < i; ++n) if (e[n].intersectsExtent(t)) return !0; return !1; }, e.prototype.isEmpty = function () { return this.geometries_.length === 0; }, e.prototype.rotate = function (t, e) { for (let n = this.geometries_, i = 0, r = n.length; i < r; ++i)n[i].rotate(t, e); this.changed(); }, e.prototype.scale = function (t, e, n) { let i = n; i || (i = Ct(this.getExtent())); for (let r = this.geometries_, o = 0, s = r.length; o < s; ++o)r[o].scale(t, e, i); this.changed(); }, e.prototype.setGeometries = function (t) { this.setGeometriesArray(ps(t)); }, e.prototype.setGeometriesArray = function (t) { this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed(); }, e.prototype.applyTransform = function (t) { for (let e = this.geometries_, n = 0, i = e.length; n < i; ++n)e[n].applyTransform(t); this.changed(); }, e.prototype.translate = function (t, e) { for (let n = this.geometries_, i = 0, r = n.length; i < r; ++i)n[i].translate(t, e); this.changed(); }, e.prototype.disposeInternal = function () { this.unlistenGeometriesChange_(), t.prototype.disposeInternal.call(this); }, e; }(ls)); function ps(t) { for (var e = [], n = 0, i = t.length; n < i; ++n)e.push(t[n].clone()); return e; } const ds = fs; const vs = {
      XY: 'XY', XYZ: 'XYZ', XYM: 'XYM', XYZM: 'XYZM',
    }; const gs = (function (t) { function e() { t.call(this), this.layout = vs.XY, this.stride = 2, this.flatCoordinates = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeExtent = function (t) { return gt(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t); }, e.prototype.getCoordinates = function () { return W(); }, e.prototype.getFirstCoordinate = function () { return this.flatCoordinates.slice(0, this.stride); }, e.prototype.getFlatCoordinates = function () { return this.flatCoordinates; }, e.prototype.getLastCoordinate = function () { return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride); }, e.prototype.getLayout = function () { return this.layout; }, e.prototype.getSimplifiedGeometry = function (t) { if (this.simplifiedGeometryRevision != this.getRevision() && (Zt(this.simplifiedGeometryCache), this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance) return this; const e = t.toString(); if (this.simplifiedGeometryCache.hasOwnProperty(e)) return this.simplifiedGeometryCache[e]; const n = this.getSimplifiedGeometryInternal(t); const i = n.getFlatCoordinates(); return i.length < this.flatCoordinates.length ? (this.simplifiedGeometryCache[e] = n, n) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this); }, e.prototype.getSimplifiedGeometryInternal = function (t) { return this; }, e.prototype.getStride = function () { return this.stride; }, e.prototype.setFlatCoordinates = function (t, e) { this.stride = ms(t), this.layout = t, this.flatCoordinates = e; }, e.prototype.setCoordinates = function (t, e) { W(); }, e.prototype.setLayout = function (t, e, n) { let i; if (t)i = ms(t); else { for (let r = 0; r < n; ++r) { if (e.length === 0) return this.layout = vs.XY, void (this.stride = 2); e = e[0]; }i = e.length, t = ys(i); } this.layout = t, this.stride = i; }, e.prototype.applyTransform = function (t) { this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed()); }, e.prototype.rotate = function (t, e) { const n = this.getFlatCoordinates(); if (n) { const i = this.getStride(); Ko(n, 0, n.length, i, t, e, n), this.changed(); } }, e.prototype.scale = function (t, e, n) { let i = e; void 0 === i && (i = t); let r = n; r || (r = Ct(this.getExtent())); const o = this.getFlatCoordinates(); if (o) { const s = this.getStride(); Ho(o, 0, o.length, s, t, i, r, o), this.changed(); } }, e.prototype.translate = function (t, e) { const n = this.getFlatCoordinates(); if (n) { const i = this.getStride(); qo(n, 0, n.length, i, t, e, n), this.changed(); } }, e; }(ls)); function ys(t) { let e; return t == 2 ? e = vs.XY : t == 3 ? e = vs.XYZ : t == 4 && (e = vs.XYZM), e; } function ms(t) { let e; return t == vs.XY ? e = 2 : t == vs.XYZ || t == vs.XYM ? e = 3 : t == vs.XYZM && (e = 4), e; } function _s(t, e, n) { const i = t.getFlatCoordinates(); if (i) { const r = t.getStride(); return Wo(i, 0, i.length, r, e, n); } return null; } const bs = gs; function ws(t, e, n, i, r, o, s) { let a; const u = t[e]; const c = t[e + 1]; const h = t[n] - u; const l = t[n + 1] - c; if (h === 0 && l === 0)a = e; else { const f = ((r - u) * h + (o - c) * l) / (h * h + l * l); if (f > 1)a = n; else { if (f > 0) { for (let p = 0; p < i; ++p)s[p] = Ht(t[e + p], t[n + p], f); return void (s.length = i); }a = e; } } for (let d = 0; d < i; ++d)s[d] = t[a + d]; s.length = i; } function xs(t, e, n, i, r) { let o = t[e]; let s = t[e + 1]; for (e += i; e < n; e += i) { const a = t[e]; const u = t[e + 1]; const c = zt(o, s, a, u); c > r && (r = c), o = a, s = u; } return r; } function Es(t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o) { const a = n[o]; r = xs(t, e, a, i, r), e = a; } return r; } function Ss(t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o) { const a = n[o]; r = Es(t, e, a, i, r), e = a[a.length - 1]; } return r; } function Ts(t, e, n, i, r, o, s, a, u, c, h) { if (e == n) return c; let l; let f; if (r === 0) { if (f = zt(s, a, t[e], t[e + 1]), f < c) { for (l = 0; l < i; ++l)u[l] = t[e + l]; return u.length = i, f; } return c; } const p = h || [NaN, NaN]; let d = e + i; while (d < n) if (ws(t, d - i, d, i, s, a, p), f = zt(s, a, p[0], p[1]), f < c) { for (c = f, l = 0; l < i; ++l)u[l] = p[l]; u.length = i, d += i; } else d += i * Math.max((Math.sqrt(f) - Math.sqrt(c)) / r | 0, 1); if (o && (ws(t, n - i, e, i, s, a, p), f = zt(s, a, p[0], p[1]), f < c)) { for (c = f, l = 0; l < i; ++l)u[l] = p[l]; u.length = i; } return c; } function Os(t, e, n, i, r, o, s, a, u, c, h) { for (let l = h || [NaN, NaN], f = 0, p = n.length; f < p; ++f) { const d = n[f]; c = Ts(t, e, d, i, r, o, s, a, u, c, l), e = d; } return c; } function Cs(t, e, n, i, r, o, s, a, u, c, h) { for (let l = h || [NaN, NaN], f = 0, p = n.length; f < p; ++f) { const d = n[f]; c = Os(t, e, d, i, r, o, s, a, u, c, l), e = d[d.length - 1]; } return c; } function Rs(t, e, n, i) { for (let r = 0, o = n.length; r < o; ++r)t[e++] = n[r]; return e; } function Is(t, e, n, i) { for (let r = 0, o = n.length; r < o; ++r) for (let s = n[r], a = 0; a < i; ++a)t[e++] = s[a]; return e; } function Ps(t, e, n, i, r) { for (var o = r || [], s = 0, a = 0, u = n.length; a < u; ++a) { const c = Is(t, e, n[a], i); o[s++] = c, e = c; } return o.length = s, o; } function Ls(t, e, n, i, r) { for (var o = r || [], s = 0, a = 0, u = n.length; a < u; ++a) { const c = Ps(t, e, n[a], i, o[s]); o[s++] = c, e = c[c.length - 1]; } return o.length = s, o; } function As(t, e, n, i, r) { for (var o = void 0 !== r ? r : [], s = 0, a = e; a < n; a += i)o[s++] = t.slice(a, a + i); return o.length = s, o; } function Fs(t, e, n, i, r) { for (var o = void 0 !== r ? r : [], s = 0, a = 0, u = n.length; a < u; ++a) { const c = n[a]; o[s++] = As(t, e, c, i, o[s]), e = c; } return o.length = s, o; } function js(t, e, n, i, r) { for (var o = void 0 !== r ? r : [], s = 0, a = 0, u = n.length; a < u; ++a) { const c = n[a]; o[s++] = Fs(t, e, c, i, o[s]), e = c[c.length - 1]; } return o.length = s, o; } function ks(t, e, n, i, r, o) { let s = NaN; let a = NaN; const u = (n - e) / i; if (u === 1)s = t[e], a = t[e + 1]; else if (u == 2)s = (1 - r) * t[e] + r * t[e + i], a = (1 - r) * t[e + 1] + r * t[e + i + 1]; else if (u !== 0) { for (var c = t[e], h = t[e + 1], l = 0, f = [0], p = e + i; p < n; p += i) { const d = t[p]; const v = t[p + 1]; l += Math.sqrt((d - c) * (d - c) + (v - h) * (v - h)), f.push(l), c = d, h = v; } const g = r * l; const y = Si(f, g); if (y < 0) { const m = (g - f[-y - 2]) / (f[-y - 1] - f[-y - 2]); const _ = e + (-y - 2) * i; s = Ht(t[_], t[_ + i], m), a = Ht(t[_ + 1], t[_ + i + 1], m); } else s = t[e + y * i], a = t[e + y * i + 1]; } return o ? (o[0] = s, o[1] = a, o) : [s, a]; } function Ms(t, e, n, i, r, o) { if (n == e) return null; let s; if (r < t[e + i - 1]) return o ? (s = t.slice(e, e + i), s[i - 1] = r, s) : null; if (t[n - 1] < r) return o ? (s = t.slice(n - i, n), s[i - 1] = r, s) : null; if (r == t[e + i - 1]) return t.slice(e, e + i); let a = e / i; let u = n / i; while (a < u) { const c = a + u >> 1; r < t[(c + 1) * i - 1] ? u = c : a = c + 1; } const h = t[a * i - 1]; if (r == h) return t.slice((a - 1) * i, (a - 1) * i + i); const l = t[(a + 1) * i - 1]; const f = (r - h) / (l - h); s = []; for (let p = 0; p < i - 1; ++p)s.push(Ht(t[(a - 1) * i + p], t[a * i + p], f)); return s.push(r), s; } function Ns(t, e, n, i, r, o, s) { if (s) return Ms(t, e, n[n.length - 1], i, r, o); let a; if (r < t[i - 1]) return o ? (a = t.slice(0, i), a[i - 1] = r, a) : null; if (t[t.length - 1] < r) return o ? (a = t.slice(t.length - i), a[i - 1] = r, a) : null; for (let u = 0, c = n.length; u < c; ++u) { const h = n[u]; if (e != h) { if (r < t[e + i - 1]) return null; if (r <= t[h - 1]) return Ms(t, e, h, i, r, !1); e = h; } } return null; } function Ds(t, e, n, i, r) { const o = Et(r, r => !$s(t, e, n, i, r[0], r[1])); return !o; } function $s(t, e, n, i, r, o) { for (var s = 0, a = t[n - i], u = t[n - i + 1]; e < n; e += i) { const c = t[e]; const h = t[e + 1]; u <= o ? h > o && (c - a) * (o - u) - (r - a) * (h - u) > 0 && s++ : h <= o && (c - a) * (o - u) - (r - a) * (h - u) < 0 && s--, a = c, u = h; } return s !== 0; } function Gs(t, e, n, i, r, o) { if (n.length === 0) return !1; if (!$s(t, e, n[0], i, r, o)) return !1; for (let s = 1, a = n.length; s < a; ++s) if ($s(t, n[s - 1], n[s], i, r, o)) return !1; return !0; } function Vs(t, e, n, i, r, o) { if (n.length === 0) return !1; for (let s = 0, a = n.length; s < a; ++s) { const u = n[s]; if (Gs(t, e, u, i, r, o)) return !0; e = u[u.length - 1]; } return !1; } function Bs(t, e, n, i, r, o) { for (var s, a = [t[e], t[e + 1]], u = []; e + i < n; e += i) { if (u[0] = t[e + i], u[1] = t[e + i + 1], s = r.call(o, a, u), s) return s; a[0] = u[0], a[1] = u[1]; } return !1; } function Us(t, e, n, i, r) { const o = wt(lt(), t, e, n, i); return !!kt(r, o) && (!!ut(r, o) || (o[0] >= r[0] && o[2] <= r[2] || (o[1] >= r[1] && o[3] <= r[3] || Bs(t, e, n, i, (t, e) => $t(r, t, e))))); } function zs(t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o) { if (Us(t, e, n[o], i, r)) return !0; e = n[o]; } return !1; } function Ys(t, e, n, i, r) { return !!Us(t, e, n, i, r) || (!!$s(t, e, n, i, r[0], r[1]) || (!!$s(t, e, n, i, r[0], r[3]) || (!!$s(t, e, n, i, r[2], r[1]) || !!$s(t, e, n, i, r[2], r[3])))); } function Xs(t, e, n, i, r) { if (!Ys(t, e, n[0], i, r)) return !1; if (n.length === 1) return !0; for (let o = 1, s = n.length; o < s; ++o) if (Ds(t, n[o - 1], n[o], i, r) && !Us(t, n[o - 1], n[o], i, r)) return !1; return !0; } function Ws(t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o) { const a = n[o]; if (Xs(t, e, a, i, r)) return !0; e = a[a.length - 1]; } return !1; } function Ks(t, e, n, i) { for (var r = t[e], o = t[e + 1], s = 0, a = e + i; a < n; a += i) { const u = t[a]; const c = t[a + 1]; s += Math.sqrt((u - r) * (u - r) + (c - o) * (c - o)), r = u, o = c; } return s; } function Hs(t, e, n, i, r, o, s) { const a = (n - e) / i; if (a < 3) { for (;e < n; e += i)o[s++] = t[e], o[s++] = t[e + 1]; return s; } const u = new Array(a); u[0] = 1, u[a - 1] = 1; const c = [e, n - i]; let h = 0; while (c.length > 0) { for (var l = c.pop(), f = c.pop(), p = 0, d = t[f], v = t[f + 1], g = t[l], y = t[l + 1], m = f + i; m < l; m += i) { const _ = t[m]; const b = t[m + 1]; const w = Ut(_, b, d, v, g, y); w > p && (h = m, p = w); }p > r && (u[(h - e) / i] = 1, f + i < h && c.push(f, h), h + i < l && c.push(h, l)); } for (let x = 0; x < a; ++x)u[x] && (o[s++] = t[e + x * i], o[s++] = t[e + x * i + 1]); return s; } function qs(t, e, n, i, r, o, s, a) { for (let u = 0, c = n.length; u < c; ++u) { const h = n[u]; s = Hs(t, e, h, i, r, o, s), a.push(s), e = h; } return s; } function Zs(t, e) { return e * Math.round(t / e); } function Js(t, e, n, i, r, o, s) { if (e == n) return s; let a; let u; let c = Zs(t[e], r); let h = Zs(t[e + 1], r); e += i, o[s++] = c, o[s++] = h; do { if (a = Zs(t[e], r), u = Zs(t[e + 1], r), e += i, e == n) return o[s++] = a, o[s++] = u, s; } while (a == c && u == h);while (e < n) { const l = Zs(t[e], r); const f = Zs(t[e + 1], r); if (e += i, l != a || f != u) { const p = a - c; const d = u - h; const v = l - c; const g = f - h; p * g == d * v && (p < 0 && v < p || p == v || p > 0 && v > p) && (d < 0 && g < d || d == g || d > 0 && g > d) ? (a = l, u = f) : (o[s++] = a, o[s++] = u, c = a, h = u, a = l, u = f); } } return o[s++] = a, o[s++] = u, s; } function Qs(t, e, n, i, r, o, s, a) { for (let u = 0, c = n.length; u < c; ++u) { const h = n[u]; s = Js(t, e, h, i, r, o, s), a.push(s), e = h; } return s; } function ta(t, e, n, i, r, o, s, a) { for (let u = 0, c = n.length; u < c; ++u) { const h = n[u]; const l = []; s = Qs(t, e, h, i, r, o, s, l), a.push(l), e = h[h.length - 1]; } return s; } const ea = (function (t) { function e(e, n) { t.call(this), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, void 0 === n || Array.isArray(e[0]) ? this.setCoordinates(e, n) : this.setFlatCoordinates(n, e); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.appendCoordinate = function (t) { this.flatCoordinates ? Ii(this.flatCoordinates, t) : this.flatCoordinates = t.slice(), this.changed(); }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout); }, e.prototype.closestPointXY = function (t, e, n, i) { return i < st(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(xs(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Ts(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, n, i)); }, e.prototype.forEachSegment = function (t) { return Bs(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t); }, e.prototype.getCoordinateAtM = function (t, e) { if (this.layout != vs.XYM && this.layout != vs.XYZM) return null; const n = void 0 !== e && e; return Ms(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n); }, e.prototype.getCoordinates = function () { return As(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride); }, e.prototype.getCoordinateAt = function (t, e) { return ks(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e); }, e.prototype.getLength = function () { return Ks(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride); }, e.prototype.getFlatMidpoint = function () { return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_; }, e.prototype.getSimplifiedGeometryInternal = function (t) { const n = []; return n.length = Hs(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n, 0), new e(n, vs.XY); }, e.prototype.getType = function () { return en.LINE_STRING; }, e.prototype.intersectsExtent = function (t) { return Us(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t); }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Is(this.flatCoordinates, 0, t, this.stride), this.changed(); }, e; }(bs)); const na = ea; const ia = (function (t) { function e(e, n, i) { if (t.call(this), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0])) this.setCoordinates(e, n); else if (void 0 !== n && i) this.setFlatCoordinates(n, e), this.ends_ = i; else { for (var r = this.getLayout(), o = e, s = [], a = [], u = 0, c = o.length; u < c; ++u) { const h = o[u]; u === 0 && (r = h.getLayout()), Ii(s, h.getFlatCoordinates()), a.push(s.length); } this.setFlatCoordinates(r, s), this.ends_ = a; } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.appendLineString = function (t) { this.flatCoordinates ? Ii(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed(); }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice()); }, e.prototype.closestPointXY = function (t, e, n, i) { return i < st(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Es(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Os(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, n, i)); }, e.prototype.getCoordinateAtM = function (t, e, n) { if (this.layout != vs.XYM && this.layout != vs.XYZM || this.flatCoordinates.length === 0) return null; const i = void 0 !== e && e; const r = void 0 !== n && n; return Ns(this.flatCoordinates, 0, this.ends_, this.stride, t, i, r); }, e.prototype.getCoordinates = function () { return Fs(this.flatCoordinates, 0, this.ends_, this.stride); }, e.prototype.getEnds = function () { return this.ends_; }, e.prototype.getLineString = function (t) { return t < 0 || this.ends_.length <= t ? null : new na(this.flatCoordinates.slice(t === 0 ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout); }, e.prototype.getLineStrings = function () { for (var t = this.flatCoordinates, e = this.ends_, n = this.layout, i = [], r = 0, o = 0, s = e.length; o < s; ++o) { const a = e[o]; const u = new na(t.slice(r, a), n); i.push(u), r = a; } return i; }, e.prototype.getFlatMidpoints = function () { for (var t = [], e = this.flatCoordinates, n = 0, i = this.ends_, r = this.stride, o = 0, s = i.length; o < s; ++o) { const a = i[o]; const u = ks(e, n, a, r, 0.5); Ii(t, u), n = a; } return t; }, e.prototype.getSimplifiedGeometryInternal = function (t) { const n = []; const i = []; return n.length = qs(this.flatCoordinates, 0, this.ends_, this.stride, t, n, 0, i), new e(n, vs.XY, i); }, e.prototype.getType = function () { return en.MULTI_LINE_STRING; }, e.prototype.intersectsExtent = function (t) { return zs(this.flatCoordinates, 0, this.ends_, this.stride, t); }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []); const n = Ps(this.flatCoordinates, 0, t, this.stride, this.ends_); this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed(); }, e; }(bs)); const ra = ia; const oa = (function (t) { function e(e, n) { t.call(this), this.setCoordinates(e, n); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () { const t = new e(this.flatCoordinates.slice(), this.layout); return t; }, e.prototype.closestPointXY = function (t, e, n, i) { const r = this.flatCoordinates; const o = zt(t, e, r[0], r[1]); if (o < i) { for (var s = this.stride, a = 0; a < s; ++a)n[a] = r[a]; return n.length = s, o; } return i; }, e.prototype.getCoordinates = function () { return this.flatCoordinates ? this.flatCoordinates.slice() : []; }, e.prototype.computeExtent = function (t) { return dt(this.flatCoordinates, t); }, e.prototype.getType = function () { return en.POINT; }, e.prototype.intersectsExtent = function (t) { return ct(t, this.flatCoordinates[0], this.flatCoordinates[1]); }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Rs(this.flatCoordinates, 0, t, this.stride), this.changed(); }, e; }(bs)); const sa = oa; const aa = (function (t) { function e(e, n) { t.call(this), n && !Array.isArray(e[0]) ? this.setFlatCoordinates(n, e) : this.setCoordinates(e, n); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.appendPoint = function (t) { this.flatCoordinates ? Ii(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.changed(); }, e.prototype.clone = function () { const t = new e(this.flatCoordinates.slice(), this.layout); return t; }, e.prototype.closestPointXY = function (t, e, n, i) { if (i < st(this.getExtent(), t, e)) return i; for (let r = this.flatCoordinates, o = this.stride, s = 0, a = r.length; s < a; s += o) { const u = zt(t, e, r[s], r[s + 1]); if (u < i) { i = u; for (let c = 0; c < o; ++c)n[c] = r[s + c]; n.length = o; } } return i; }, e.prototype.getCoordinates = function () { return As(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride); }, e.prototype.getPoint = function (t) { const e = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0; return t < 0 || e <= t ? null : new sa(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout); }, e.prototype.getPoints = function () { for (var t = this.flatCoordinates, e = this.layout, n = this.stride, i = [], r = 0, o = t.length; r < o; r += n) { const s = new sa(t.slice(r, r + n), e); i.push(s); } return i; }, e.prototype.getType = function () { return en.MULTI_POINT; }, e.prototype.intersectsExtent = function (t) { for (let e = this.flatCoordinates, n = this.stride, i = 0, r = e.length; i < r; i += n) { const o = e[i]; const s = e[i + 1]; if (ct(t, o, s)) return !0; } return !1; }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Is(this.flatCoordinates, 0, t, this.stride), this.changed(); }, e; }(bs)); const ua = aa; function ca(t, e, n, i) { for (var r = 0, o = t[n - i], s = t[n - i + 1]; e < n; e += i) { const a = t[e]; const u = t[e + 1]; r += s * a - o * u, o = a, s = u; } return r / 2; } function ha(t, e, n, i) { for (var r = 0, o = 0, s = n.length; o < s; ++o) { const a = n[o]; r += ca(t, e, a, i), e = a; } return r; } function la(t, e, n, i) { for (var r = 0, o = 0, s = n.length; o < s; ++o) { const a = n[o]; r += ha(t, e, a, i), e = a[a.length - 1]; } return r; } const fa = (function (t) { function e(e, n) { t.call(this), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, void 0 === n || Array.isArray(e[0]) ? this.setCoordinates(e, n) : this.setFlatCoordinates(n, e); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout); }, e.prototype.closestPointXY = function (t, e, n, i) { return i < st(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(xs(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Ts(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, n, i)); }, e.prototype.getArea = function () { return ca(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride); }, e.prototype.getCoordinates = function () { return As(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride); }, e.prototype.getSimplifiedGeometryInternal = function (t) { const n = []; return n.length = Hs(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n, 0), new e(n, vs.XY); }, e.prototype.getType = function () { return en.LINEAR_RING; }, e.prototype.intersectsExtent = function (t) { return !1; }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Is(this.flatCoordinates, 0, t, this.stride), this.changed(); }, e; }(bs)); const pa = fa; function da(t, e, n, i, r, o, s) { for (var a, u, c, h, l, f, p, d = r[o + 1], v = [], g = 0, y = n.length; g < y; ++g) { const m = n[g]; for (h = t[m - i], f = t[m - i + 1], a = e; a < m; a += i)l = t[a], p = t[a + 1], (d <= f && p <= d || f <= d && d <= p) && (c = (d - f) / (p - f) * (l - h) + h, v.push(c)), h = l, f = p; } let _ = NaN; let b = -1 / 0; for (v.sort(Ti), h = v[0], a = 1, u = v.length; a < u; ++a) { l = v[a]; const w = Math.abs(l - h); w > b && (c = (h + l) / 2, Gs(t, e, n, i, c, d) && (_ = c, b = w)), h = l; } return isNaN(_) && (_ = r[o]), s ? (s.push(_, d, b), s) : [_, d, b]; } function va(t, e, n, i, r) { for (var o = [], s = 0, a = n.length; s < a; ++s) { const u = n[s]; o = da(t, e, u, i, r, 2 * s, o), e = u[u.length - 1]; } return o; } function ga(t, e, n, i) { while (e < n - i) { for (let r = 0; r < i; ++r) { const o = t[e + r]; t[e + r] = t[n - i + r], t[n - i + r] = o; }e += i, n -= i; } } function ya(t, e, n, i) { for (var r = 0, o = t[n - i], s = t[n - i + 1]; e < n; e += i) { const a = t[e]; const u = t[e + 1]; r += (a - o) * (u + s), o = a, s = u; } return r > 0; } function ma(t, e, n, i, r) { for (let o = void 0 !== r && r, s = 0, a = n.length; s < a; ++s) { const u = n[s]; const c = ya(t, e, u, i); if (s === 0) { if (o && c || !o && !c) return !1; } else if (o && !c || !o && c) return !1; e = u; } return !0; } function _a(t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o) if (!ma(t, e, n[o], i, r)) return !1; return !0; } function ba(t, e, n, i, r) { for (let o = void 0 !== r && r, s = 0, a = n.length; s < a; ++s) { const u = n[s]; const c = ya(t, e, u, i); const h = s === 0 ? o && c || !o && !c : o && !c || !o && c; h && ga(t, e, u, i), e = u; } return e; } function wa(t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o)e = ba(t, e, n[o], i, r); return e; } const xa = (function (t) { function e(e, n, i) { t.call(this), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, void 0 !== n && i ? (this.setFlatCoordinates(n, e), this.ends_ = i) : this.setCoordinates(e, n); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.appendLinearRing = function (t) { this.flatCoordinates ? Ii(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed(); }, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice()); }, e.prototype.closestPointXY = function (t, e, n, i) { return i < st(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Es(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Os(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, n, i)); }, e.prototype.containsXY = function (t, e) { return Gs(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e); }, e.prototype.getArea = function () { return ha(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride); }, e.prototype.getCoordinates = function (t) { let e; return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(), ba(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, Fs(e, 0, this.ends_, this.stride); }, e.prototype.getEnds = function () { return this.ends_; }, e.prototype.getFlatInteriorPoint = function () { if (this.flatInteriorPointRevision_ != this.getRevision()) { const t = Ct(this.getExtent()); this.flatInteriorPoint_ = da(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0), this.flatInteriorPointRevision_ = this.getRevision(); } return this.flatInteriorPoint_; }, e.prototype.getInteriorPoint = function () { return new sa(this.getFlatInteriorPoint(), vs.XYM); }, e.prototype.getLinearRingCount = function () { return this.ends_.length; }, e.prototype.getLinearRing = function (t) { return t < 0 || this.ends_.length <= t ? null : new pa(this.flatCoordinates.slice(t === 0 ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout); }, e.prototype.getLinearRings = function () { for (var t = this.layout, e = this.flatCoordinates, n = this.ends_, i = [], r = 0, o = 0, s = n.length; o < s; ++o) { const a = n[o]; const u = new pa(e.slice(r, a), t); i.push(u), r = a; } return i; }, e.prototype.getOrientedFlatCoordinates = function () { if (this.orientedRevision_ != this.getRevision()) { const t = this.flatCoordinates; ma(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = ba(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)), this.orientedRevision_ = this.getRevision(); } return this.orientedFlatCoordinates_; }, e.prototype.getSimplifiedGeometryInternal = function (t) { const n = []; const i = []; return n.length = Qs(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), n, 0, i), new e(n, vs.XY, i); }, e.prototype.getType = function () { return en.POLYGON; }, e.prototype.intersectsExtent = function (t) { return Xs(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t); }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []); const n = Ps(this.flatCoordinates, 0, t, this.stride, this.ends_); this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed(); }, e; }(bs)); const Ea = xa; function Sa(t, e, n, i) { for (var r = n || 32, o = [], s = 0; s < r; ++s)Ii(o, on(t, e, 2 * Math.PI * s / r, i)); return o.push(o[0], o[1]), new xa(o, vs.XY, [o.length]); } function Ta(t) { const e = t[0]; const n = t[1]; const i = t[2]; const r = t[3]; const o = [e, n, e, r, i, r, i, n, e, n]; return new xa(o, vs.XY, [o.length]); } function Oa(t, e, n) { for (var i = e || 32, r = t.getStride(), o = t.getLayout(), s = t.getCenter(), a = r * (i + 1), u = new Array(a), c = 0; c < a; c += r) { u[c] = 0, u[c + 1] = 0; for (let h = 2; h < r; h++)u[c + h] = s[h]; } const l = [u.length]; const f = new xa(u, o, l); return Ca(f, s, t.getRadius(), n), f; } function Ca(t, e, n, i) { for (let r = t.getFlatCoordinates(), o = t.getStride(), s = r.length / o - 1, a = i || 0, u = 0; u <= s; ++u) { const c = u * o; const h = a + 2 * Kt(u, s) * Math.PI / s; r[c] = e[0] + n * Math.cos(h), r[c + 1] = e[1] + n * Math.sin(h); }t.changed(); } function Ra(t, e, n, i) { for (var r = [], o = lt(), s = 0, a = n.length; s < a; ++s) { const u = n[s]; o = gt(t, e, u[0], i), r.push((o[0] + o[2]) / 2, (o[1] + o[3]) / 2), e = u[u.length - 1]; } return r; } const Ia = (function (t) { function e(e, n, i) { if (t.call(this), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(e[0])) { for (var r = this.getLayout(), o = e, s = [], a = [], u = 0, c = o.length; u < c; ++u) { const h = o[u]; u === 0 && (r = h.getLayout()); for (var l = s.length, f = h.getEnds(), p = 0, d = f.length; p < d; ++p)f[p] += l; Ii(s, h.getFlatCoordinates()), a.push(f); }n = r, e = s, i = a; } void 0 !== n && i ? (this.setFlatCoordinates(n, e), this.endss_ = i) : this.setCoordinates(e, n); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.appendPolygon = function (t) { let e; if (this.flatCoordinates) { const n = this.flatCoordinates.length; Ii(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice(); for (let i = 0, r = e.length; i < r; ++i)e[i] += n; } else this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push(); this.endss_.push(e), this.changed(); }, e.prototype.clone = function () { for (var t = this.endss_.length, n = new Array(t), i = 0; i < t; ++i)n[i] = this.endss_[i].slice(); return new e(this.flatCoordinates.slice(), this.layout, n); }, e.prototype.closestPointXY = function (t, e, n, i) { return i < st(this.getExtent(), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Ss(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Cs(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, t, e, n, i)); }, e.prototype.containsXY = function (t, e) { return Vs(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e); }, e.prototype.getArea = function () { return la(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride); }, e.prototype.getCoordinates = function (t) { let e; return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(), wa(e, 0, this.endss_, this.stride, t)) : e = this.flatCoordinates, js(e, 0, this.endss_, this.stride); }, e.prototype.getEndss = function () { return this.endss_; }, e.prototype.getFlatInteriorPoints = function () { if (this.flatInteriorPointsRevision_ != this.getRevision()) { const t = Ra(this.flatCoordinates, 0, this.endss_, this.stride); this.flatInteriorPoints_ = va(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t), this.flatInteriorPointsRevision_ = this.getRevision(); } return this.flatInteriorPoints_; }, e.prototype.getInteriorPoints = function () { return new ua(this.getFlatInteriorPoints().slice(), vs.XYM); }, e.prototype.getOrientedFlatCoordinates = function () { if (this.orientedRevision_ != this.getRevision()) { const t = this.flatCoordinates; _a(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = wa(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)), this.orientedRevision_ = this.getRevision(); } return this.orientedFlatCoordinates_; }, e.prototype.getSimplifiedGeometryInternal = function (t) { const n = []; const i = []; return n.length = ta(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), n, 0, i), new e(n, vs.XY, i); }, e.prototype.getPolygon = function (t) { if (t < 0 || this.endss_.length <= t) return null; let e; if (t === 0)e = 0; else { const n = this.endss_[t - 1]; e = n[n.length - 1]; } const i = this.endss_[t].slice(); const r = i[i.length - 1]; if (e !== 0) for (let o = 0, s = i.length; o < s; ++o)i[o] -= e; return new Ea(this.flatCoordinates.slice(e, r), this.layout, i); }, e.prototype.getPolygons = function () { for (var t = this.layout, e = this.flatCoordinates, n = this.endss_, i = [], r = 0, o = 0, s = n.length; o < s; ++o) { const a = n[o].slice(); const u = a[a.length - 1]; if (r !== 0) for (let c = 0, h = a.length; c < h; ++c)a[c] -= r; const l = new Ea(e.slice(r, u), t, a); i.push(l), r = u; } return i; }, e.prototype.getType = function () { return en.MULTI_POLYGON; }, e.prototype.intersectsExtent = function (t) { return Ws(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t); }, e.prototype.setCoordinates = function (t, e) { this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []); const n = Ls(this.flatCoordinates, 0, t, this.stride, this.endss_); if (n.length === 0) this.flatCoordinates.length = 0; else { const i = n[n.length - 1]; this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1]; } this.changed(); }, e; }(bs)); const Pa = Ia; const La = (function (t) { function e(e) { const n = e || {}; t.call(this), this.dataProjection = jn(n.dataProjection ? n.dataProjection : 'EPSG:4326'), n.featureProjection && (this.defaultFeatureProjection = jn(n.featureProjection)), this.geometryName_ = n.geometryName, this.extractGeometryName_ = n.extractGeometryName; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.readFeatureFromObject = function (t, e) { let n = null; n = t.type === 'Feature' ? t : { type: 'Feature', geometry: t, properties: null }; const i = Aa(n.geometry, e); const r = new Cr(); return this.geometryName_ ? r.setGeometryName(this.geometryName_) : this.extractGeometryName_ && 'geometry_name' in n !== void 0 && r.setGeometryName(n.geometry_name), r.setGeometry(i), 'id' in n && r.setId(n.id), n.properties && r.setProperties(n.properties), r; }, e.prototype.readFeaturesFromObject = function (t, e) { const n = t; let i = null; if (n.type === 'FeatureCollection') { const r = t; i = []; for (let o = r.features, s = 0, a = o.length; s < a; ++s)i.push(this.readFeatureFromObject(o[s], e)); } else i = [this.readFeatureFromObject(t, e)]; return i; }, e.prototype.readGeometryFromObject = function (t, e) { return Aa(t, e); }, e.prototype.readProjectionFromObject = function (t) { let e; const n = t.crs; return n ? n.type == 'name' ? e = jn(n.properties.name) : Q(!1, 36) : e = this.dataProjection, e; }, e.prototype.writeFeatureObject = function (t, e) { e = this.adaptOptions(e); const n = { type: 'Feature', geometry: null, properties: null }; const i = t.getId(); void 0 !== i && (n.id = i); const r = t.getGeometry(); r && (n.geometry = Ga(r, e)); const o = t.getProperties(); return delete o[t.getGeometryName()], Qt(o) || (n.properties = o), n; }, e.prototype.writeFeaturesObject = function (t, e) { e = this.adaptOptions(e); for (var n = [], i = 0, r = t.length; i < r; ++i)n.push(this.writeFeatureObject(t[i], e)); return { type: 'FeatureCollection', features: n }; }, e.prototype.writeGeometryObject = function (t, e) { return Ga(t, this.adaptOptions(e)); }, e; }(Xo)); function Aa(t, e) { if (!t) return null; let n; switch (t.type) { case en.POINT: n = ja(t); break; case en.LINE_STRING: n = ka(t); break; case en.POLYGON: n = $a(t); break; case en.MULTI_POINT: n = Na(t); break; case en.MULTI_LINE_STRING: n = Ma(t); break; case en.MULTI_POLYGON: n = Da(t); break; case en.GEOMETRY_COLLECTION: n = Fa(t); break; default: throw new Error(`Unsupported GeoJSON type: ${t.type}`); } return Bo(n, !1, e); } function Fa(t, e) { const n = t.geometries.map(t => Aa(t, e)); return new ds(n); } function ja(t) { return new sa(t.coordinates); } function ka(t) { return new na(t.coordinates); } function Ma(t) { return new ra(t.coordinates); } function Na(t) { return new ua(t.coordinates); } function Da(t) { return new Pa(t.coordinates); } function $a(t) { return new Ea(t.coordinates); } function Ga(t, e) { t = Bo(t, !0, e); let n; const i = t.getType(); switch (i) { case en.POINT: n = Xa(t, e); break; case en.LINE_STRING: n = Ba(t, e); break; case en.POLYGON: n = Wa(t, e); break; case en.MULTI_POINT: n = za(t, e); break; case en.MULTI_LINE_STRING: n = Ua(t, e); break; case en.MULTI_POLYGON: n = Ya(t, e); break; case en.GEOMETRY_COLLECTION: n = Va(t, e); break; case en.CIRCLE: n = { type: 'GeometryCollection', geometries: [] }; break; default: throw new Error(`Unsupported geometry type: ${i}`); } return n; } function Va(t, e) { const n = t.getGeometriesArray().map((t) => { const n = qt({}, e); return delete n.featureProjection, Ga(t, n); }); return { type: 'GeometryCollection', geometries: n }; } function Ba(t, e) { return { type: 'LineString', coordinates: t.getCoordinates() }; } function Ua(t, e) { return { type: 'MultiLineString', coordinates: t.getCoordinates() }; } function za(t, e) { return { type: 'MultiPoint', coordinates: t.getCoordinates() }; } function Ya(t, e) { let n; return e && (n = e.rightHanded), { type: 'MultiPolygon', coordinates: t.getCoordinates(n) }; } function Xa(t, e) { return { type: 'Point', coordinates: t.getCoordinates() }; } function Wa(t, e) { let n; return e && (n = e.rightHanded), { type: 'Polygon', coordinates: t.getCoordinates(n) }; } const Ka = La; const Ha = n('7915'); const qa = n.n(Ha); const Za = Jo(); const Ja = function (t, e, n, i, r) { this.extent_, this.id_ = r, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n, this.properties_ = i; }; Ja.prototype.get = function (t) { return this.properties_[t]; }, Ja.prototype.getExtent = function () { return this.extent_ || (this.extent_ = this.type_ === en.POINT ? dt(this.flatCoordinates_) : gt(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)), this.extent_; }, Ja.prototype.getFlatInteriorPoint = function () { if (!this.flatInteriorPoints_) { const t = Ct(this.getExtent()); this.flatInteriorPoints_ = da(this.flatCoordinates_, 0, this.ends_, 2, t, 0); } return this.flatInteriorPoints_; }, Ja.prototype.getFlatInteriorPoints = function () { if (!this.flatInteriorPoints_) { const t = Ra(this.flatCoordinates_, 0, this.ends_, 2); this.flatInteriorPoints_ = va(this.flatCoordinates_, 0, this.ends_, 2, t); } return this.flatInteriorPoints_; }, Ja.prototype.getFlatMidpoint = function () { return this.flatMidpoints_ || (this.flatMidpoints_ = ks(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5)), this.flatMidpoints_; }, Ja.prototype.getFlatMidpoints = function () { if (!this.flatMidpoints_) { this.flatMidpoints_ = []; for (let t = this.flatCoordinates_, e = 0, n = this.ends_, i = 0, r = n.length; i < r; ++i) { const o = n[i]; const s = ks(t, e, o, 2, 0.5); Ii(this.flatMidpoints_, s), e = o; } } return this.flatMidpoints_; }, Ja.prototype.getId = function () { return this.id_; }, Ja.prototype.getOrientedFlatCoordinates = function () { return this.flatCoordinates_; }, Ja.prototype.getGeometry = function () { return this; }, Ja.prototype.getSimplifiedGeometry = function (t) { return this; }, Ja.prototype.getProperties = function () { return this.properties_; }, Ja.prototype.getStride = function () { return 2; }, Ja.prototype.getStyleFunction = function () {}, Ja.prototype.getType = function () { return this.type_; }, Ja.prototype.transform = function (t, e) { t = jn(t); const n = t.getExtent(); const i = t.getWorldExtent(); const r = Pt(i) / Pt(n); ss(Za, i[0], i[3], r, -r, 0, 0, 0), Wo(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, Za, this.flatCoordinates_); }, Ja.prototype.getEnds = Ja.prototype.getEndss = function () { return this.ends_; }, Ja.prototype.getFlatCoordinates = Ja.prototype.getOrientedFlatCoordinates; const Qa = Ja; const tu = (function (t) { function e(e) { t.call(this); const n = e || {}; this.dataProjection = new hn({ code: '', units: un.TILE_PIXELS }), this.featureClass_ = n.featureClass ? n.featureClass : Qa, this.geometryName_ = n.geometryName, this.layerName_ = n.layerName ? n.layerName : 'layer', this.layers_ = n.layers ? n.layers : null, this.extent_ = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.readRawGeometry_ = function (t, e, n, i) { t.pos = e.geometry; const r = t.readVarint() + t.pos; let o = 1; let s = 0; let a = 0; let u = 0; let c = 0; let h = 0; while (t.pos < r) { if (!s) { const l = t.readVarint(); o = 7 & l, s = l >> 3; }s--, o === 1 || o === 2 ? (a += t.readSVarint(), u += t.readSVarint(), o === 1 && c > h && (i.push(c), h = c), n.push(a, u), c += 2) : o === 7 ? c > h && (n.push(n[h], n[h + 1]), c += 2) : Q(!1, 59); }c > h && (i.push(c), h = c); }, e.prototype.createFeature_ = function (t, e, n) { let i; const r = e.type; if (r === 0) return null; const o = e.id; const s = e.properties; s[this.layerName_] = e.layer.name; const a = []; const u = []; this.readRawGeometry_(t, e, a, u); const c = ou(r, u.length); if (this.featureClass_ === Qa)i = new this.featureClass_(c, a, u, s, o); else { let h; if (c == en.POLYGON) { for (var l = [], f = 0, p = 0, d = 0, v = u.length; d < v; ++d) { const g = u[d]; ya(a, f, g, 2) || (l.push(u.slice(p, d)), p = d), f = g; }h = l.length > 1 ? new Pa(a, vs.XY, l) : new Ea(a, vs.XY, u); } else h = c === en.POINT ? new sa(a, vs.XY) : c === en.LINE_STRING ? new na(a, vs.XY) : c === en.POLYGON ? new Ea(a, vs.XY, u) : c === en.MULTI_POINT ? new ua(a, vs.XY) : c === en.MULTI_LINE_STRING ? new ra(a, vs.XY, u) : null; const y = this.featureClass_; i = new y(), this.geometryName_ && i.setGeometryName(this.geometryName_); const m = Bo(h, !1, this.adaptOptions(n)); i.setGeometry(m), i.setId(o), i.setProperties(s); } return i; }, e.prototype.getLastExtent = function () { return this.extent_; }, e.prototype.getType = function () { return Uo.ARRAY_BUFFER; }, e.prototype.readFeatures = function (t, e) { const n = this.layers_; const i = new qa.a(t); const r = i.readFields(eu, {}); const o = []; for (const s in r) if (!n || n.indexOf(s) != -1) { for (var a = r[s], u = 0, c = a.length; u < c; ++u) { const h = ru(i, a, u); o.push(this.createFeature_(i, h)); } this.extent_ = a ? [0, 0, a.extent, a.extent] : null; } return o; }, e.prototype.readProjection = function (t) { return this.dataProjection; }, e.prototype.setLayers = function (t) { this.layers_ = t; }, e; }(Vo)); function eu(t, e, n) { if (t === 3) { const i = { keys: [], values: [], features: [] }; const r = n.readVarint() + n.pos; n.readFields(nu, i, r), i.length = i.features.length, i.length && (e[i.name] = i); } } function nu(t, e, n) { if (t === 15)e.version = n.readVarint(); else if (t === 1)e.name = n.readString(); else if (t === 5)e.extent = n.readVarint(); else if (t === 2)e.features.push(n.pos); else if (t === 3)e.keys.push(n.readString()); else if (t === 4) { let i = null; const r = n.readVarint() + n.pos; while (n.pos < r)t = n.readVarint() >> 3, i = t === 1 ? n.readString() : t === 2 ? n.readFloat() : t === 3 ? n.readDouble() : t === 4 ? n.readVarint64() : t === 5 ? n.readVarint() : t === 6 ? n.readSVarint() : t === 7 ? n.readBoolean() : null; e.values.push(i); } } function iu(t, e, n) { if (t == 1)e.id = n.readVarint(); else if (t == 2) { const i = n.readVarint() + n.pos; while (n.pos < i) { const r = e.layer.keys[n.readVarint()]; const o = e.layer.values[n.readVarint()]; e.properties[r] = o; } } else t == 3 ? e.type = n.readVarint() : t == 4 && (e.geometry = n.pos); } function ru(t, e, n) { t.pos = e.features[n]; const i = t.readVarint() + t.pos; const r = { layer: e, type: 0, properties: {} }; return t.readFields(iu, r, i), r; } function ou(t, e) { let n; return t === 1 ? n = e === 1 ? en.POINT : en.MULTI_POINT : t === 2 ? n = e === 1 ? en.LINE_STRING : en.MULTI_LINE_STRING : t === 3 && (n = en.POLYGON), n; } const su = tu; const au = 6371008.8; const uu = {
      meters: au, metres: au, millimeters: 1e3 * au, millimetres: 1e3 * au, centimeters: 100 * au, centimetres: 100 * au, kilometers: au / 1e3, kilometres: au / 1e3, miles: au / 1609.344, nauticalmiles: au / 1852, inches: 39.37 * au, yards: au / 1.0936, feet: 3.28084 * au, radians: 1, degrees: au / 111325,
    }; function cu(t, e, n) { if (n = n || {}, !vu(n)) throw new Error('options is invalid'); const i = n.bbox; const r = n.id; if (void 0 === t) throw new Error('geometry is required'); if (e && e.constructor !== Object) throw new Error('properties must be an Object'); i && gu(i), r && yu(r); const o = { type: 'Feature' }; return r && (o.id = r), i && (o.bbox = i), o.properties = e || {}, o.geometry = t, o; } function hu(t, e, n) { if (!t) throw new Error('coordinates is required'); if (!Array.isArray(t)) throw new Error('coordinates must be an Array'); if (t.length < 2) throw new Error('coordinates must be at least 2 numbers long'); if (!du(t[0]) || !du(t[1])) throw new Error('coordinates must contain numbers'); return cu({ type: 'Point', coordinates: t }, e, n); } function lu(t, e) { if (e = e || {}, !vu(e)) throw new Error('options is invalid'); const n = e.bbox; const i = e.id; if (!t) throw new Error('No features passed'); if (!Array.isArray(t)) throw new Error('features must be an Array'); n && gu(n), i && yu(i); const r = { type: 'FeatureCollection' }; return i && (r.id = i), n && (r.bbox = n), r.features = t, r; } function fu(t, e) { if (void 0 === t || t === null) throw new Error('radians is required'); if (e && typeof e !== 'string') throw new Error('units must be a string'); const n = uu[e || 'kilometers']; if (!n) throw new Error(`${e} units is invalid`); return t * n; } function pu(t) { if (t === null || void 0 === t) throw new Error('degrees is required'); const e = t % 360; return e * Math.PI / 180; } function du(t) { return !isNaN(t) && t !== null && !Array.isArray(t); } function vu(t) { return !!t && t.constructor === Object; } function gu(t) { if (!t) throw new Error('bbox is required'); if (!Array.isArray(t)) throw new Error('bbox must be an Array'); if (t.length !== 4 && t.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers'); t.forEach((t) => { if (!du(t)) throw new Error('bbox must only contain numbers'); }); } function yu(t) { if (!t) throw new Error('id is required'); if (['string', 'number'].indexOf(typeof t) === -1) throw new Error('id must be a number or a string'); } function mu(t, e, n) { if (t !== null) for (var i, r, o, s, a, u, c, h, l = 0, f = 0, p = t.type, d = p === 'FeatureCollection', v = p === 'Feature', g = d ? t.features.length : 1, y = 0; y < g; y++) { c = d ? t.features[y].geometry : v ? t.geometry : t, h = !!c && c.type === 'GeometryCollection', a = h ? c.geometries.length : 1; for (let m = 0; m < a; m++) { let _ = 0; let b = 0; if (s = h ? c.geometries[m] : c, s !== null) { u = s.coordinates; const w = s.type; switch (l = !n || w !== 'Polygon' && w !== 'MultiPolygon' ? 0 : 1, w) { case null: break; case 'Point': if (!1 === e(u, f, y, _, b)) return !1; f++, _++; break; case 'LineString': case 'MultiPoint': for (i = 0; i < u.length; i++) { if (!1 === e(u[i], f, y, _, b)) return !1; f++, w === 'MultiPoint' && _++; }w === 'LineString' && _++; break; case 'Polygon': case 'MultiLineString': for (i = 0; i < u.length; i++) { for (r = 0; r < u[i].length - l; r++) { if (!1 === e(u[i][r], f, y, _, b)) return !1; f++; }w === 'MultiLineString' && _++, w === 'Polygon' && b++; }w === 'Polygon' && _++; break; case 'MultiPolygon': for (i = 0; i < u.length; i++) { for (w === 'MultiPolygon' && (b = 0), r = 0; r < u[i].length; r++) { for (o = 0; o < u[i][r].length - l; o++) { if (!1 === e(u[i][r][o], f, y, _, b)) return !1; f++; }b++; }_++; } break; case 'GeometryCollection': for (i = 0; i < s.geometries.length; i++) if (!1 === mu(s.geometries[i], e, n)) return !1; break; default: throw new Error('Unknown Geometry Type'); } } } } } function _u(t, e) { if (t.type === 'Feature')e(t, 0); else if (t.type === 'FeatureCollection') for (let n = 0; n < t.features.length; n++) if (!1 === e(t.features[n], n)) break; } function bu(t) { const e = []; return t.type === 'FeatureCollection' ? _u(t, (t) => { mu(t, (n) => { e.push(hu(n, t.properties)); }); }) : mu(t, (n) => { e.push(hu(n, t.properties)); }), lu(e); } const wu = bu; function xu(t) { const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return mu(t, (t) => { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]); }), e; } const Eu = xu; function Su(t, e) { if (e = e || {}, !vu(e)) throw new Error('options is invalid'); const n = e.properties; if (!t) throw new Error('geojson is required'); const i = Eu(t); const r = (i[0] + i[2]) / 2; const o = (i[1] + i[3]) / 2; return hu([r, o], n); } const Tu = Su; function Ou(t) { if (!t) throw new Error('geojson is required'); switch (t.type) { case 'Feature': return Cu(t); case 'FeatureCollection': return Iu(t); case 'Point': case 'LineString': case 'Polygon': case 'MultiPoint': case 'MultiLineString': case 'MultiPolygon': case 'GeometryCollection': return Pu(t); default: throw new Error('unknown GeoJSON type'); } } function Cu(t) { const e = { type: 'Feature' }; return Object.keys(t).forEach((n) => { switch (n) { case 'type': case 'properties': case 'geometry': return; default: e[n] = t[n]; } }), e.properties = Ru(t.properties), e.geometry = Pu(t.geometry), e; } function Ru(t) { const e = {}; return t ? (Object.keys(t).forEach((n) => { const i = t[n]; typeof i === 'object' ? i === null ? e[n] = null : i.length ? e[n] = i.map(t => t) : e[n] = Ru(i) : e[n] = i; }), e) : e; } function Iu(t) { const e = { type: 'FeatureCollection' }; return Object.keys(t).forEach((n) => { switch (n) { case 'type': case 'features': return; default: e[n] = t[n]; } }), e.features = t.features.map(t => Cu(t)), e; } function Pu(t) { const e = { type: t.type }; return t.bbox && (e.bbox = t.bbox), t.type === 'GeometryCollection' ? (e.geometries = t.geometries.map(t => Pu(t)), e) : (e.coordinates = Lu(t.coordinates), e); } function Lu(t) { return typeof t[0] !== 'object' ? t.slice() : t.map(t => Lu(t)); } const Au = Ou; function Fu(t) { if (!t) throw new Error('coord is required'); if (t.type === 'Feature' && t.geometry !== null && t.geometry.type === 'Point') return t.geometry.coordinates; if (t.type === 'Point') return t.coordinates; if (Array.isArray(t) && t.length >= 2 && void 0 === t[0].length && void 0 === t[1].length) return t; throw new Error('coord must be GeoJSON Point or an Array of numbers'); } function ju(t) { if (!t) throw new Error('coords is required'); if (t.type === 'Feature' && t.geometry !== null) return t.geometry.coordinates; if (t.coordinates) return t.coordinates; if (Array.isArray(t)) return t; throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array'); } function ku(t, e, n) { if (n = n || {}, !vu(n)) throw new Error('options is invalid'); const i = n.units; const r = Fu(t); const o = Fu(e); const s = pu(o[1] - r[1]); const a = pu(o[0] - r[0]); const u = pu(r[1]); const c = pu(o[1]); const h = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(u) * Math.cos(c); return fu(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), i); } const Mu = ku; function Nu(t, e) { if (!t) throw new Error('targetPoint is required'); if (!e) throw new Error('points is required'); let n; let i = 1 / 0; return _u(e, (e, r) => { const o = Mu(t, e); o < i && (n = Au(e), n.properties.featureIndex = r, n.properties.distanceToPoint = o, i = o); }), n; } const Du = Nu; function $u(t, e, n) { if (n = n || {}, typeof n !== 'object') throw new Error('options is invalid'); const i = n.ignoreBoundary; if (!t) throw new Error('point is required'); if (!e) throw new Error('polygon is required'); const r = Fu(t); let o = ju(e); const s = e.geometry ? e.geometry.type : e.type; const a = e.bbox; if (a && !1 === Vu(r, a)) return !1; s === 'Polygon' && (o = [o]); for (var u = 0, c = !1; u < o.length && !c; u++) if (Gu(r, o[u][0], i)) { let h = !1; let l = 1; while (l < o[u].length && !h)Gu(r, o[u][l], !i) && (h = !0), l++; h || (c = !0); } return c; } function Gu(t, e, n) { let i = !1; e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1)); for (let r = 0, o = e.length - 1; r < e.length; o = r++) { const s = e[r][0]; const a = e[r][1]; const u = e[o][0]; const c = e[o][1]; const h = t[1] * (s - u) + a * (u - t[0]) + c * (t[0] - s) === 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (c - t[1]) <= 0; if (h) return !n; const l = a > t[1] !== c > t[1] && t[0] < (u - s) * (t[1] - a) / (c - a) + s; l && (i = !i); } return i; } function Vu(t, e) { return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1]; } const Bu = $u; function Uu(t) { const e = zu(t); const n = Tu(e); let i = !1; let r = 0; while (!i && r < e.features.length) { var o; var s; var a; var u; var c; var h; var l; const f = e.features[r].geometry; let p = !1; if (f.type === 'Point')n.geometry.coordinates[0] === f.coordinates[0] && n.geometry.coordinates[1] === f.coordinates[1] && (i = !0); else if (f.type === 'MultiPoint') { let d = !1; l = 0; while (!d && l < f.coordinates.length)n.geometry.coordinates[0] === f.coordinates[l][0] && n.geometry.coordinates[1] === f.coordinates[l][1] && (i = !0, d = !0), l++; } else if (f.type === 'LineString') { l = 0; while (!p && l < f.coordinates.length - 1)o = n.geometry.coordinates[0], s = n.geometry.coordinates[1], a = f.coordinates[l][0], u = f.coordinates[l][1], c = f.coordinates[l + 1][0], h = f.coordinates[l + 1][1], Yu(o, s, a, u, c, h) && (p = !0, i = !0), l++; } else if (f.type === 'MultiLineString') { let v = 0; while (v < f.coordinates.length) { p = !1, l = 0; const g = f.coordinates[v]; while (!p && l < g.length - 1)o = n.geometry.coordinates[0], s = n.geometry.coordinates[1], a = g[l][0], u = g[l][1], c = g[l + 1][0], h = g[l + 1][1], Yu(o, s, a, u, c, h) && (p = !0, i = !0), l++; v++; } } else f.type !== 'Polygon' && f.type !== 'MultiPolygon' || Bu(n, f) && (i = !0); r++; } if (i) return n; const y = lu([]); for (r = 0; r < e.features.length; r++)y.features = y.features.concat(wu(e.features[r]).features); return hu(Du(n, y).geometry.coordinates); } function zu(t) { return t.type !== 'FeatureCollection' ? t.type !== 'Feature' ? lu([cu(t)]) : lu([t]) : t; } function Yu(t, e, n, i, r, o) { const s = Math.sqrt((r - n) * (r - n) + (o - i) * (o - i)); const a = Math.sqrt((t - n) * (t - n) + (e - i) * (e - i)); const u = Math.sqrt((r - t) * (r - t) + (o - e) * (o - e)); return s === a + u; } const Xu = Uu; const Wu = (function (t) { function e(e, n, i) { if (t.call(this), void 0 !== i && void 0 === n) this.setFlatCoordinates(i, e); else { const r = n || 0; this.setCenterAndRadius(e, r, i); } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () { return new e(this.flatCoordinates.slice(), void 0, this.layout); }, e.prototype.closestPointXY = function (t, e, n, i) { const r = this.flatCoordinates; const o = t - r[0]; const s = e - r[1]; const a = o * o + s * s; if (a < i) { if (a === 0) for (let u = 0; u < this.stride; ++u)n[u] = r[u]; else { const c = this.getRadius() / Math.sqrt(a); n[0] = r[0] + c * o, n[1] = r[1] + c * s; for (let h = 2; h < this.stride; ++h)n[h] = r[h]; } return n.length = this.stride, a; } return i; }, e.prototype.containsXY = function (t, e) { const n = this.flatCoordinates; const i = t - n[0]; const r = e - n[1]; return i * i + r * r <= this.getRadiusSquared_(); }, e.prototype.getCenter = function () { return this.flatCoordinates.slice(0, this.stride); }, e.prototype.computeExtent = function (t) { const e = this.flatCoordinates; const n = e[this.stride] - e[0]; return ft(e[0] - n, e[1] - n, e[0] + n, e[1] + n, t); }, e.prototype.getRadius = function () { return Math.sqrt(this.getRadiusSquared_()); }, e.prototype.getRadiusSquared_ = function () { const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0]; const e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1]; return t * t + e * e; }, e.prototype.getType = function () { return en.CIRCLE; }, e.prototype.intersectsExtent = function (t) { const e = this.getExtent(); if (kt(t, e)) { const n = this.getCenter(); return t[0] <= n[0] && t[2] >= n[0] || (t[1] <= n[1] && t[3] >= n[1] || Et(t, this.intersectsCoordinate, this)); } return !1; }, e.prototype.setCenter = function (t) { const e = this.stride; const n = this.flatCoordinates[e] - this.flatCoordinates[0]; const i = t.slice(); i[e] = i[0] + n; for (let r = 1; r < e; ++r)i[e + r] = t[r]; this.setFlatCoordinates(this.layout, i), this.changed(); }, e.prototype.setCenterAndRadius = function (t, e, n) { this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []); const i = this.flatCoordinates; let r = Rs(i, 0, t, this.stride); i[r++] = i[0] + e; for (let o = 1, s = this.stride; o < s; ++o)i[r++] = i[o]; i.length = r, this.changed(); }, e.prototype.getCoordinates = function () { return null; }, e.prototype.setCoordinates = function (t, e) {}, e.prototype.setRadius = function (t) { this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed(); }, e; }(bs)); Wu.prototype.transform; let Ku; const Hu = Wu;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function qu(t, e) { const n = Fo()(t) ? t : [t, e]; return new sa(n); } function Zu(t) { return new na(t); } function Ju(t) { return new Ea(t); } function Qu(t) { return new ua(t); } function tc(t) { return new ra(t); } function ec(t) { return new Pa(t); } function nc(t) { return new ds(t); } function ic(t, e) { return Sa(t, e); } function rc(t) { const e = [To.MULTI_POINT, To.MULTI_LINE_STRING, To.MULTI_POLYGON, To.GEOMETRY_COLLECTION]; return e.includes(t.type || t.getType()); } function oc(t) { t instanceof Hu && (t = qu(t.getCenter())); const e = t.type || t.getType(); const n = [To.GEOMETRY_COLLECTION]; return !1 === n.includes(e) ? t : (t.geometries || t.getGeometries())[0]; } function sc(t) { const e = oc(t); const n = Xu({ type: e.type || e.getType(), coordinates: e.coordinates || e.getCoordinates() }); if (n && n.geometry) return n.geometry.coordinates; }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function ac(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return Gn(t, e); } function uc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return $n(t, e); } function cc(t, e, n) { return zn(t, e, n); } function hc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => ac(t, e)); } function lc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => uc(t, e)); } function fc(t, e, n) { return t.map(t => zn(t, e, n)); } function pc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => hc(t, e)); } function dc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => lc(t, e)); } function vc(t, e, n) { return t.map(t => fc(t, e, n)); } function gc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => ac(t, e)); } function yc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => uc(t, e)); } function mc(t, e, n) { return t.map(t => cc(t, e, n)); } function _c(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => hc(t, e)); } function bc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => lc(t, e)); } function wc(t, e, n) { return t.map(t => fc(t, e, n)); } function xc(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => pc(t, e)); } function Ec(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : vo; return t.map(t => dc(t, e)); } function Sc(t, e, n) { return t.map(t => vc(t, e, n)); } const Tc = (Ku = {}, lr(Ku, To.POINT, { toLonLat: ac, fromLonLat: uc, transform: cc }), lr(Ku, To.LINE_STRING, { toLonLat: hc, fromLonLat: lc, transform: fc }), lr(Ku, To.POLYGON, { toLonLat: pc, fromLonLat: dc, transform: vc }), lr(Ku, To.MULTI_POINT, { toLonLat: gc, fromLonLat: yc, transform: mc }), lr(Ku, To.MULTI_LINE_STRING, { toLonLat: _c, fromLonLat: bc, transform: wc }), lr(Ku, To.MULTI_POLYGON, { toLonLat: xc, fromLonLat: Ec, transform: Sc }), Ku);
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    function Oc(t) { return t && Object(gr.l)(t.getArray); } function Cc(t) { return t && Object(gr.l)(t.getAttributions) && Object(gr.l)(t.getFeatureById); } function Rc(t) { return Object(gr.l)(t.getCenter) && Object(gr.l)(t.getRadius); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Ic(t) { return new Lc(t); } function Pc(t) { return new su(t); } var Lc = (function (t) { function e() { return Fr(this, e), kr(this, Gr(e).apply(this, arguments)); } return zr(e, t), ko(e, [{ key: 'writeGeometryObject', value(t, n) { return Rc(t) && (t = ic(cc(t.getCenter(), n.featureProjection || this.defaultFeatureProjection, po), t.getRadius()), n.featureProjection = po), $o(Gr(e.prototype), 'writeGeometryObject', this).call(this, t, n); } }, { key: 'writeFeatureObject', value(t, e) { const n = { type: 'Feature' }; const i = t.getId(); void 0 !== i && (n.id = i); const r = t.getGeometry(); n.geometry = r ? this.writeGeometryObject(r, e) : null; const o = t.getProperties(); return delete o[t.getGeometryName()], Object(gr.i)(o) ? n.properties = null : n.properties = o, n; } }]), e; }(Ka)); const Ac = Ic();
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Fc(t, e, n) { const i = Ac.writeFeatureObject(t, { featureProjection: e, dataProjection: n }); return Fo()(Object(gr.g)(i, 'properties.features')) && (i.properties.features = i.properties.features.map(t => (t instanceof Cr ? Fc(t, e, n) : t))), i; } function jc(t, e, n) { const i = Ac.readFeature(t, { featureProjection: e, dataProjection: n }); return Fo()(i.get('features')) && i.set('features', i.get('features').map(t => (Object(gr.o)(t) ? jc(t, e, n) : t))), i; } function kc(t, e, n) { return Ac.writeGeometryObject(t, { featureProjection: e, dataProjection: n }); } function Mc(t, e, n) { return n = Nc(t, n), Ac.readGeometry(t, { featureProjection: e, dataProjection: n }); } function Nc(t, e) { return Ac.readProjection(t) || e; }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const Dc = {
      computed: { viewProjection() { return this.rev && this.$view ? this.$view.getProjection().getCode() : vo; }, resolvedDataProjection() { return Object(gr.b)(this.dataProjection, this.projection, this.$map && this.$map.get('dataProjection'), this.$options.dataProjection, this.viewProjection); } },
      methods: {
        pointToViewProj(t) { return cc(t, this.resolvedDataProjection, this.viewProjection); }, pointToDataProj(t) { return cc(t, this.viewProjection, this.resolvedDataProjection); }, lineToViewProj(t) { return fc(t, this.resolvedDataProjection, this.viewProjection); }, lineToDataProj(t) { return fc(t, this.viewProjection, this.resolvedDataProjection); }, polygonToViewProj(t) { return vc(t, this.resolvedDataProjection, this.viewProjection); }, polygonToDataProj(t) { return vc(t, this.viewProjection, this.resolvedDataProjection); }, multiPointToViewProj(t) { return mc(t, this.resolvedDataProjection, this.viewProjection); }, multiPointToDataProj(t) { return mc(t, this.viewProjection, this.resolvedDataProjection); }, multiLineToViewProj(t) { return wc(t, this.resolvedDataProjection, this.viewProjection); }, multiLineToDataProj(t) { return wc(t, this.viewProjection, this.resolvedDataProjection); }, multiPolygonToViewProj(t) { return Sc(t, this.resolvedDataProjection, this.viewProjection); }, multiPolygonToDataProj(t) { return Sc(t, this.viewProjection, this.resolvedDataProjection); }, extentToViewProj(t) { return Yn(t, this.resolvedDataProjection, this.viewProjection); }, extentToDataProj(t) { return Yn(t, this.viewProjection, this.resolvedDataProjection); }, writeGeometryInDataProj(t) { return kc(t, this.viewProjection, this.resolvedDataProjection); }, writeGeometryInViewProj(t) { return kc(t); }, readGeometryInDataProj(t) { return Mc(t, this.viewProjection, this.resolvedDataProjection); }, writeFeatureInDataProj(t) { return Fc(t, this.viewProjection, this.resolvedDataProjection); }, writeFeatureInViewProj(t) { return Fc(t); }, readFeatureInDataProj(t) { return jc(t, this.viewProjection, this.resolvedDataProjection); },
      },
    }; const $c = Dc; const Gc = {
      getFeaturesTarget() { throw new Error('Not implemented method'); }, addFeatures(t) { t.forEach(this.addFeature.bind(this)); }, addFeature(t) { t instanceof Rr.a ? t = t.$feature : Object(gr.o)(t) && (t = this.readFeatureInDataProj(t)), no(t, Cr), this.prepareFeature(t), this.getFeaturesTarget().has(t) || this.getFeaturesTarget().add(t); }, removeFeatures(t) { t.forEach(this.removeFeature.bind(this)); }, removeFeature(t) { t instanceof Rr.a ? t = t.$feature : Object(gr.o)(t) && (t = this.getFeatureById(t.id)), t && this.getFeaturesTarget().has(t) && this.getFeaturesTarget().remove(t); }, clearFeatures() { this.getFeaturesTarget().clear(); }, getFeatureById(t) { return this.getFeaturesTarget().findByKey(t); }, getFeatures() { return this.getFeaturesTarget().elements; }, getServices() { const t = this; return { get featuresContainer() { return t; } }; }, prepareFeature(t) { return Lr(t); },
    }; const Vc = { mixins: [$c], methods: Gc }; const Bc = Vc; const Uc = n('d847'); const zc = n.n(Uc); var Yc = function (t, e) { return Yc = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }, Yc(t, e); }; function Xc(t, e) { function n() { this.constructor = t; }Yc(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n()); } function Wc(t) { return typeof t === 'function'; } let Kc = !1; const Hc = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const e = new Error(); e.stack; }Kc = t; }, get useDeprecatedSynchronousErrorHandling() { return Kc; } }; function qc(t) { setTimeout(() => { throw t; }); } const Zc = {
      closed: !0, next(t) {}, error(t) { if (Hc.useDeprecatedSynchronousErrorHandling) throw t; qc(t); }, complete() {},
    }; const Jc = Array.isArray || function (t) { return t && typeof t.length === 'number'; }; function Qc(t) { return t != null && typeof t === 'object'; } let th; const eh = { e: {} }; function nh() { try { return th.apply(this, arguments); } catch (t) { return eh.e = t, eh; } } function ih(t) { return th = t, nh; } function rh(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join('\n  ')}` : '', this.name = 'UnsubscriptionError', this.errors = t, this; }rh.prototype = Object.create(Error.prototype); const oh = rh; const sh = (function () { function t(t) { this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, t && (this._unsubscribe = t); } return t.prototype.unsubscribe = function () { let t; let e = !1; if (!this.closed) { const n = this; let i = n._parent; const r = n._parents; const o = n._unsubscribe; const s = n._subscriptions; this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null; let a = -1; let u = r ? r.length : 0; while (i)i.remove(this), i = ++a < u && r[a] || null; if (Wc(o)) { var c = ih(o).call(this); c === eh && (e = !0, t = t || (eh.e instanceof oh ? ah(eh.e.errors) : [eh.e])); } if (Jc(s)) { a = -1, u = s.length; while (++a < u) { const h = s[a]; if (Qc(h)) { c = ih(h.unsubscribe).call(h); if (c === eh) { e = !0, t = t || []; const l = eh.e; l instanceof oh ? t = t.concat(ah(l.errors)) : t.push(l); } } } } if (e) throw new oh(t); } }, t.prototype.add = function (e) { if (!e || e === t.EMPTY) return t.EMPTY; if (e === this) return this; let n = e; switch (typeof e) { case 'function': n = new t(e); case 'object': if (n.closed || typeof n.unsubscribe !== 'function') return n; if (this.closed) return n.unsubscribe(), n; if (typeof n._addParent !== 'function') { const i = n; n = new t(), n._subscriptions = [i]; } break; default: throw new Error(`unrecognized teardown ${e} added to Subscription.`); } const r = this._subscriptions || (this._subscriptions = []); return r.push(n), n._addParent(this), n; }, t.prototype.remove = function (t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); n !== -1 && e.splice(n, 1); } }, t.prototype._addParent = function (t) { const e = this; const n = e._parent; const i = e._parents; n && n !== t ? i ? i.indexOf(t) === -1 && i.push(t) : this._parents = [t] : this._parent = t; }, t.EMPTY = (function (t) { return t.closed = !0, t; }(new t())), t; }()); function ah(t) { return t.reduce((t, e) => t.concat(e instanceof oh ? e.errors : e), []); } const uh = typeof Symbol === 'function' ? Symbol('rxSubscriber') : `@@rxSubscriber_${Math.random()}`; const ch = (function (t) { function e(n, i, r) { const o = t.call(this) || this; switch (o.syncErrorValue = null, o.syncErrorThrown = !1, o.syncErrorThrowable = !1, o.isStopped = !1, o._parentSubscription = null, arguments.length) { case 0: o.destination = Zc; break; case 1: if (!n) { o.destination = Zc; break; } if (typeof n === 'object') { n instanceof e ? (o.syncErrorThrowable = n.syncErrorThrowable, o.destination = n, n.add(o)) : (o.syncErrorThrowable = !0, o.destination = new hh(o, n)); break; } default: o.syncErrorThrowable = !0, o.destination = new hh(o, n, i, r); break; } return o; } return Xc(e, t), e.prototype[uh] = function () { return this; }, e.create = function (t, n, i) { const r = new e(t, n, i); return r.syncErrorThrowable = !1, r; }, e.prototype.next = function (t) { this.isStopped || this._next(t); }, e.prototype.error = function (t) { this.isStopped || (this.isStopped = !0, this._error(t)); }, e.prototype.complete = function () { this.isStopped || (this.isStopped = !0, this._complete()); }, e.prototype.unsubscribe = function () { this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this)); }, e.prototype._next = function (t) { this.destination.next(t); }, e.prototype._error = function (t) { this.destination.error(t), this.unsubscribe(); }, e.prototype._complete = function () { this.destination.complete(), this.unsubscribe(); }, e.prototype._unsubscribeAndRecycle = function () { const t = this; const e = t._parent; const n = t._parents; return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parent = e, this._parents = n, this._parentSubscription = null, this; }, e; }(sh)); var hh = (function (t) { function e(e, n, i, r) { let o; const s = t.call(this) || this; s._parentSubscriber = e; let a = s; return Wc(n) ? o = n : n && (o = n.next, i = n.error, r = n.complete, n !== Zc && (a = Object.create(n), Wc(a.unsubscribe) && s.add(a.unsubscribe.bind(a)), a.unsubscribe = s.unsubscribe.bind(s))), s._context = a, s._next = o, s._error = i, s._complete = r, s; } return Xc(e, t), e.prototype.next = function (t) { if (!this.isStopped && this._next) { const e = this._parentSubscriber; Hc.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t); } }, e.prototype.error = function (t) { if (!this.isStopped) { const e = this._parentSubscriber; const n = Hc.useDeprecatedSynchronousErrorHandling; if (this._error)n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable)n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : qc(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; qc(t); } } }, e.prototype.complete = function () { const t = this; if (!this.isStopped) { const e = this._parentSubscriber; if (this._complete) { const n = function () { return t._complete.call(t._context); }; Hc.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? (this.__tryOrSetError(e, n), this.unsubscribe()) : (this.__tryOrUnsub(n), this.unsubscribe()); } else this.unsubscribe(); } }, e.prototype.__tryOrUnsub = function (t, e) { try { t.call(this._context, e); } catch (n) { if (this.unsubscribe(), Hc.useDeprecatedSynchronousErrorHandling) throw n; qc(n); } }, e.prototype.__tryOrSetError = function (t, e, n) { if (!Hc.useDeprecatedSynchronousErrorHandling) throw new Error('bad call'); try { e.call(this._context, n); } catch (i) { return Hc.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = i, t.syncErrorThrown = !0, !0) : (qc(i), !0); } return !1; }, e.prototype._unsubscribe = function () { const t = this._parentSubscriber; this._context = null, this._parentSubscriber = null, t.unsubscribe(); }, e; }(ch)); function lh(t, e) { return function (n) { return n.lift(new fh(t, e)); }; } var fh = (function () { function t(t, e) { this.compare = t, this.keySelector = e; } return t.prototype.call = function (t, e) { return e.subscribe(new ph(t, this.compare, this.keySelector)); }, t; }()); var ph = (function (t) { function e(e, n, i) { const r = t.call(this, e) || this; return r.keySelector = i, r.hasKey = !1, typeof n === 'function' && (r.compare = n), r; } return Xc(e, t), e.prototype.compare = function (t, e) { return t === e; }, e.prototype._next = function (t) { const e = this.keySelector; let n = t; if (e && (n = ih(this.keySelector)(t), n === eh)) return this.destination.error(eh.e); let i = !1; if (this.hasKey) { if (i = ih(this.compare)(this.key, n), i === eh) return this.destination.error(eh.e); } else this.hasKey = !0; !1 === Boolean(i) && (this.key = n, this.destination.next(t)); }, e; }(ch)); function dh(t, e) { return function (n) { if (typeof t !== 'function') throw new TypeError('argument is not a function. Are you looking for `mapTo()`?'); return n.lift(new vh(t, e)); }; } var vh = (function () { function t(t, e) { this.project = t, this.thisArg = e; } return t.prototype.call = function (t, e) { return e.subscribe(new gh(t, this.project, this.thisArg)); }, t; }()); var gh = (function (t) { function e(e, n, i) { const r = t.call(this, e) || this; return r.project = n, r.count = 0, r.thisArg = i || r, r; } return Xc(e, t), e.prototype._next = function (t) { let e; try { e = this.project.call(this.thisArg, t, this.count++); } catch (n) { return void this.destination.error(n); } this.destination.next(e); }, e; }(ch)); const yh = (function (t) { function e(e, n) { return t.call(this) || this; } return Xc(e, t), e.prototype.schedule = function (t, e) { return void 0 === e && (e = 0), this; }, e; }(sh)); const mh = (function (t) { function e(e, n) { const i = t.call(this, e, n) || this; return i.scheduler = e, i.work = n, i.pending = !1, i; } return Xc(e, t), e.prototype.schedule = function (t, e) { if (void 0 === e && (e = 0), this.closed) return this; this.state = t; const n = this.id; const i = this.scheduler; return n != null && (this.id = this.recycleAsyncId(i, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(i, this.id, e), this; }, e.prototype.requestAsyncId = function (t, e, n) { return void 0 === n && (n = 0), setInterval(t.flush.bind(t, this), n); }, e.prototype.recycleAsyncId = function (t, e, n) { if (void 0 === n && (n = 0), n !== null && this.delay === n && !1 === this.pending) return e; clearInterval(e); }, e.prototype.execute = function (t, e) { if (this.closed) return new Error('executing a cancelled action'); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)); }, e.prototype._execute = function (t, e) { let n = !1; let i = void 0; try { this.work(t); } catch (r) { n = !0, i = !!r && r || new Error(r); } if (n) return this.unsubscribe(), i; }, e.prototype._unsubscribe = function () { const t = this.id; const e = this.scheduler; const n = e.actions; const i = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, i !== -1 && n.splice(i, 1), t != null && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null; }, e; }(yh)); const _h = (function () { function t(e, n) { void 0 === n && (n = t.now), this.SchedulerAction = e, this.now = n; } return t.prototype.schedule = function (t, e, n) { return void 0 === e && (e = 0), new this.SchedulerAction(this, t).schedule(n, e); }, t.now = function () { return Date.now(); }, t; }()); const bh = (function (t) { function e(n, i) { void 0 === i && (i = _h.now); var r = t.call(this, n, () => (e.delegate && e.delegate !== r ? e.delegate.now() : i())) || this; return r.actions = [], r.active = !1, r.scheduled = void 0, r; } return Xc(e, t), e.prototype.schedule = function (n, i, r) { return void 0 === i && (i = 0), e.delegate && e.delegate !== this ? e.delegate.schedule(n, i, r) : t.prototype.schedule.call(this, n, i, r); }, e.prototype.flush = function (t) { const e = this.actions; if (this.active)e.push(t); else { let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break; } while (t = e.shift());if (this.active = !1, n) { while (t = e.shift())t.unsubscribe(); throw n; } } }, e; }(_h)); const wh = new bh(mh); const xh = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return Xc(e, t), e.prototype.notifyNext = function (t, e, n, i, r) { this.destination.next(e); }, e.prototype.notifyError = function (t, e) { this.destination.error(t); }, e.prototype.notifyComplete = function (t) { this.destination.complete(); }, e; }(ch)); const Eh = (function (t) { function e(e, n, i) { const r = t.call(this) || this; return r.parent = e, r.outerValue = n, r.outerIndex = i, r.index = 0, r; } return Xc(e, t), e.prototype._next = function (t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this); }, e.prototype._error = function (t) { this.parent.notifyError(t, this), this.unsubscribe(); }, e.prototype._complete = function () { this.parent.notifyComplete(this), this.unsubscribe(); }, e; }(ch)); function Sh(t) { while (t) { const e = t; const n = e.closed; const i = e.destination; const r = e.isStopped; if (n || r) return !1; t = i && i instanceof ch ? i : null; } return !0; } function Th(t, e, n) { if (t) { if (t instanceof ch) return t; if (t[uh]) return t[uh](); } return t || e || n ? new ch(t, e, n) : new ch(Zc); } const Oh = typeof Symbol === 'function' && Symbol.observable || '@@observable'; function Ch() {} function Rh(t) { return t ? t.length === 1 ? t[0] : function (e) { return t.reduce((t, e) => e(t), e); } : Ch; } const Ih = (function () { function t(t) { this._isScalar = !1, t && (this._subscribe = t); } return t.prototype.lift = function (e) { const n = new t(); return n.source = this, n.operator = e, n; }, t.prototype.subscribe = function (t, e, n) { const i = this.operator; const r = Th(t, e, n); if (i ? i.call(r, this.source) : r.add(this.source || Hc.useDeprecatedSynchronousErrorHandling && !r.syncErrorThrowable ? this._subscribe(r) : this._trySubscribe(r)), Hc.useDeprecatedSynchronousErrorHandling && r.syncErrorThrowable && (r.syncErrorThrowable = !1, r.syncErrorThrown)) throw r.syncErrorValue; return r; }, t.prototype._trySubscribe = function (t) { try { return this._subscribe(t); } catch (e) { Hc.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), Sh(t) ? t.error(e) : console.warn(e); } }, t.prototype.forEach = function (t, e) { const n = this; return e = Ph(e), new e(((e, i) => { let r; r = n.subscribe((e) => { try { t(e); } catch (n) { i(n), r && r.unsubscribe(); } }, i, e); })); }, t.prototype._subscribe = function (t) { const e = this.source; return e && e.subscribe(t); }, t.prototype[Oh] = function () { return this; }, t.prototype.pipe = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return t.length === 0 ? this : Rh(t)(this); }, t.prototype.toPromise = function (t) { const e = this; return t = Ph(t), new t(((t, n) => { let i; e.subscribe(t => i = t, t => n(t), () => t(i)); })); }, t.create = function (e) { return new t(e); }, t; }()); function Ph(t) { if (t || (t = Hc.Promise || Promise), !t) throw new Error('no Promise impl found'); return t; } const Lh = function (t) { return function (e) { for (let n = 0, i = t.length; n < i && !e.closed; n++)e.next(t[n]); e.closed || e.complete(); }; }; const Ah = function (t) { return function (e) { return t.then((t) => { e.closed || (e.next(t), e.complete()); }, t => e.error(t)).then(null, qc), e; }; }; function Fh() { return typeof Symbol === 'function' && Symbol.iterator ? Symbol.iterator : '@@iterator'; } const jh = Fh(); const kh = function (t) { return function (e) { const n = t[jh](); do { const i = n.next(); if (i.done) { e.complete(); break; } if (e.next(i.value), e.closed) break; } while (1);return typeof n.return === 'function' && e.add(() => { n.return && n.return(); }), e; }; }; const Mh = function (t) { return function (e) { const n = t[Oh](); if (typeof n.subscribe !== 'function') throw new TypeError('Provided object does not correctly implement Symbol.observable'); return n.subscribe(e); }; }; const Nh = function (t) { return t && typeof t.length === 'number' && typeof t !== 'function'; }; function Dh(t) { return t && typeof t.subscribe !== 'function' && typeof t.then === 'function'; } const $h = function (t) {
      if (t instanceof Ih) return function (e) { return t._isScalar ? (e.next(t.value), void e.complete()) : t.subscribe(e); }; if (t && typeof t[Oh] === 'function') return Mh(t); if (Nh(t)) return Lh(t); if (Dh(t)) return Ah(t); if (t && typeof t[jh] === 'function') return kh(t); const e = Qc(t) ? 'an invalid object' : `'${t}'`; const
        n = `You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`; throw new TypeError(n);
    }; function Gh(t, e, n, i, r) { if (void 0 === r && (r = new Eh(t, n, i)), !r.closed) return $h(e)(r); } const Vh = { leading: !0, trailing: !1 }; function Bh(t, e, n) { return void 0 === e && (e = wh), void 0 === n && (n = Vh), function (i) { return i.lift(new Uh(t, e, n.leading, n.trailing)); }; } var Uh = (function () { function t(t, e, n, i) { this.duration = t, this.scheduler = e, this.leading = n, this.trailing = i; } return t.prototype.call = function (t, e) { return e.subscribe(new zh(t, this.duration, this.scheduler, this.leading, this.trailing)); }, t; }()); var zh = (function (t) { function e(e, n, i, r, o) { const s = t.call(this, e) || this; return s.duration = n, s.scheduler = i, s.leading = r, s.trailing = o, s._hasTrailingValue = !1, s._trailingValue = null, s; } return Xc(e, t), e.prototype._next = function (t) { this.throttled ? this.trailing && (this._trailingValue = t, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(Yh, this.duration, { subscriber: this })), this.leading && this.destination.next(t)); }, e.prototype._complete = function () { this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete(); }, e.prototype.clearThrottle = function () { const t = this.throttled; t && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), t.unsubscribe(), this.remove(t), this.throttled = null); }, e; }(ch)); function Yh(t) { const e = t.subscriber; e.clearThrottle(); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Xh(t, e, n, i, r) { return r ? (r[0] = t, r[1] = e, r[2] = n, r[3] = i, r) : [t, e, n, i]; } function Wh(t) { t = jn(t); let e = t.getExtent(); if (!e) { const n = 180 * an[Oo.DEGREES] / t.getMetersPerUnit(); e = Xh(-n, -n, n, n); } return e; } function Kh(t) { if (Fo()(t)) { for (var e = 0, n = new Array(t.length); e < t.length; e++)n[e] = t[e]; return n; } } const Hh = n('774e'); const qh = n.n(Hh); const Zh = n('c8bb'); const Jh = n.n(Zh); function Qh(t) { if (Jh()(Object(t)) || Object.prototype.toString.call(t) === '[object Arguments]') return qh()(t); } function tl() { throw new TypeError('Invalid attempt to spread non-iterable instance'); } function el(t) { return Kh(t) || Qh(t) || tl(); } function nl(t, e, n) { return n ? nl(t, e).pipe(dh(t => (Jc(t) ? n(...t) : n(t)))) : new Ih(((n) => { let i; const r = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return n.next(t.length === 1 ? t[0] : t); }; try { i = t(r); } catch (o) { return void n.error(o); } if (Wc(e)) return function () { return e(r, i); }; })); } function il(t) { return t && typeof t.schedule === 'function'; } function rl(t) { return t && typeof t[Oh] === 'function'; } function ol(t) { return t && typeof t[jh] === 'function'; } function sl(t, e) {
      return new Ih(e ? (n) => {
        const i = new sh(); let
          r = 0; return i.add(e.schedule(function () { r !== t.length ? (n.next(t[r++]), n.closed || i.add(this.schedule())) : n.complete(); })), i;
      } : Lh(t));
    } function al(t, e) { return new Ih(e ? (n) => { const i = new sh(); return i.add(e.schedule(() => t.then((t) => { i.add(e.schedule(() => { n.next(t), i.add(e.schedule(() => n.complete())); })); }, (t) => { i.add(e.schedule(() => n.error(t))); }))), i; } : Ah(t)); } function ul(t, e) { if (!t) throw new Error('Iterable cannot be null'); return new Ih(e ? (n) => { let i; const r = new sh(); return r.add(() => { i && typeof i.return === 'function' && i.return(); }), r.add(e.schedule(() => { i = t[jh](), r.add(e.schedule(function () { if (!n.closed) { let t; let e; try { const r = i.next(); t = r.value, e = r.done; } catch (o) { return void n.error(o); }e ? n.complete() : (n.next(t), this.schedule()); } })); })), r; } : kh(t)); } function cl(t, e) { return new Ih(e ? (n) => { const i = new sh(); return i.add(e.schedule(() => { const r = t[Oh](); i.add(r.subscribe({ next(t) { i.add(e.schedule(() => n.next(t))); }, error(t) { i.add(e.schedule(() => n.error(t))); }, complete() { i.add(e.schedule(() => n.complete())); } })); })), i; } : Mh(t)); } function hl(t, e) { if (!e) return t instanceof Ih ? t : new Ih($h(t)); if (t != null) { if (rl(t)) return cl(t, e); if (Dh(t)) return al(t, e); if (Nh(t)) return sl(t, e); if (ol(t) || typeof t === 'string') return ul(t, e); } throw new TypeError(`${t !== null && typeof t || t} is not observable`); } function ll(t, e, n) { return void 0 === n && (n = Number.POSITIVE_INFINITY), typeof e === 'function' ? function (i) { return i.pipe(ll((n, i) => hl(t(n, i)).pipe(dh((t, r) => e(n, t, i, r))), n)); } : (typeof e === 'number' && (n = e), function (e) { return e.lift(new fl(t, n)); }); } var fl = (function () { function t(t, e) { void 0 === e && (e = Number.POSITIVE_INFINITY), this.project = t, this.concurrent = e; } return t.prototype.call = function (t, e) { return e.subscribe(new pl(t, this.project, this.concurrent)); }, t; }()); var pl = (function (t) { function e(e, n, i) { void 0 === i && (i = Number.POSITIVE_INFINITY); const r = t.call(this, e) || this; return r.project = n, r.concurrent = i, r.hasCompleted = !1, r.buffer = [], r.active = 0, r.index = 0, r; } return Xc(e, t), e.prototype._next = function (t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t); }, e.prototype._tryNext = function (t) { let e; const n = this.index++; try { e = this.project(t, n); } catch (i) { return void this.destination.error(i); } this.active++, this._innerSub(e, t, n); }, e.prototype._innerSub = function (t, e, n) { const i = new Eh(this, void 0, void 0); const r = this.destination; r.add(i), Gh(this, t, e, n, i); }, e.prototype._complete = function () { this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe(); }, e.prototype.notifyNext = function (t, e, n, i, r) { this.destination.next(e); }, e.prototype.notifyComplete = function (t) { const e = this.buffer; this.remove(t), this.active--, e.length > 0 ? this._next(e.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete(); }, e; }(xh)); function dl(t) { return t; } function vl(t) { return void 0 === t && (t = Number.POSITIVE_INFINITY), ll(dl, t); } function gl() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; let n = Number.POSITIVE_INFINITY; let i = null; const r = t[t.length - 1]; return il(r) ? (i = t.pop(), t.length > 1 && typeof t[t.length - 1] === 'number' && (n = t.pop())) : typeof r === 'number' && (n = t.pop()), i === null && t.length === 1 && t[0] instanceof Ih ? t[0] : vl(n)(sl(t, i)); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function yl(t, e, n) { return Fo()(e) ? gl(...el(e.map((e) => { let n; let i; return Object(vr.a)(e) === 'object' ? (n = e.event, i = e.selector) : n = e, yl(t, n, i); }))) : nl(n => t.on(e, n), n => t.un(e, n), n); } const ml = yl; const _l = n('a47c'); const bl = n.n(_l);
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    function wl() { for (var t, e = arguments.length, n = new Array(e), i = 0; i < e; i++)n[i] = arguments[i]; return Object(vr.a)(n[n.length - 1]) !== 'object' && (t = n.pop()), n.slice(1).reduce((e, n, i) => bl()(e, n, t), n[0]); } const xl = wl; const El = n('967e'); const Sl = n.n(El); const Tl = n('795b'); const Ol = n.n(Tl); function Cl(t, e, n, i, r, o, s) { try { var a = t[o](s); var u = a.value; } catch (c) { return void n(c); }a.done ? e(u) : Ol.a.resolve(u).then(i, r); } function Rl(t) { return function () { const e = this; const n = arguments; return new Ol.a(((i, r) => { const o = t.apply(e, n); function s(t) { Cl(o, i, r, s, a, 'next', t); } function a(t) { Cl(o, i, r, s, a, 'throw', t); }s(void 0); })); }; } function Il(t) { return !Jc(t) && t - parseFloat(t) + 1 >= 0; } function Pl(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = wh), (!Il(t) || t < 0) && (t = 0), e && typeof e.schedule === 'function' || (e = wh), new Ih((n => n.add(e.schedule(Ll, t, { subscriber: n, counter: 0, period: t })), n)); } function Ll(t) { const e = t.subscriber; const n = t.counter; const i = t.period; e.next(n), this.schedule({ subscriber: e, counter: n + 1, period: i }, i); } function Al() { return Error.call(this), this.message = 'no elements in sequence', this.name = 'EmptyError', this; }Al.prototype = Object.create(Error.prototype); const Fl = Al; function jl(t, e) { return function (n) { return n.lift(new kl(t, e)); }; } var kl = (function () { function t(t, e) { this.predicate = t, this.thisArg = e; } return t.prototype.call = function (t, e) { return e.subscribe(new Ml(t, this.predicate, this.thisArg)); }, t; }()); var Ml = (function (t) { function e(e, n, i) { const r = t.call(this, e) || this; return r.predicate = n, r.thisArg = i, r.count = 0, r; } return Xc(e, t), e.prototype._next = function (t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++); } catch (n) { return void this.destination.error(n); }e && this.destination.next(t); }, e; }(ch)); function Nl() { return Error.call(this), this.message = 'argument out of range', this.name = 'ArgumentOutOfRangeError', this; }Nl.prototype = Object.create(Error.prototype); const Dl = Nl; const $l = new Ih((t => t.complete())); function Gl(t) { return t ? Vl(t) : $l; } function Vl(t) { return new Ih((e => t.schedule(() => e.complete()))); } function Bl(t) { return function (e) { return t === 0 ? Gl() : e.lift(new Ul(t)); }; } var Ul = (function () { function t(t) { if (this.total = t, this.total < 0) throw new Dl(); } return t.prototype.call = function (t, e) { return e.subscribe(new zl(t, this.total)); }, t; }()); var zl = (function (t) { function e(e, n) { const i = t.call(this, e) || this; return i.total = n, i.count = 0, i; } return Xc(e, t), e.prototype._next = function (t) { const e = this.total; const n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())); }, e; }(ch)); function Yl(t) { return void 0 === t && (t = null), function (e) { return e.lift(new Xl(t)); }; } var Xl = (function () { function t(t) { this.defaultValue = t; } return t.prototype.call = function (t, e) { return e.subscribe(new Wl(t, this.defaultValue)); }, t; }()); var Wl = (function (t) { function e(e, n) { const i = t.call(this, e) || this; return i.defaultValue = n, i.isEmpty = !0, i; } return Xc(e, t), e.prototype._next = function (t) { this.isEmpty = !1, this.destination.next(t); }, e.prototype._complete = function () { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete(); }, e; }(ch)); function Kl(t, e, n) { return function (i) { return i.lift(new Hl(t, e, n)); }; } var Hl = (function () { function t(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n; } return t.prototype.call = function (t, e) { return e.subscribe(new ql(t, this.nextOrObserver, this.error, this.complete)); }, t; }()); var ql = (function (t) { function e(e, n, i, r) { const o = t.call(this, e) || this; return o._tapNext = Ch, o._tapError = Ch, o._tapComplete = Ch, o._tapError = i || Ch, o._tapComplete = r || Ch, Wc(n) ? (o._context = o, o._tapNext = n) : n && (o._context = n, o._tapNext = n.next || Ch, o._tapError = n.error || Ch, o._tapComplete = n.complete || Ch), o; } return Xc(e, t), e.prototype._next = function (t) { try { this._tapNext.call(this._context, t); } catch (e) { return void this.destination.error(e); } this.destination.next(t); }, e.prototype._error = function (t) { try { this._tapError.call(this._context, t); } catch (t) { return void this.destination.error(t); } this.destination.error(t); }, e.prototype._complete = function () { try { this._tapComplete.call(this._context); } catch (t) { return void this.destination.error(t); } return this.destination.complete(); }, e; }(ch)); const Zl = function (t) { return void 0 === t && (t = Jl), Kl({ hasValue: !1, next() { this.hasValue = !0; }, complete() { if (!this.hasValue) throw t(); } }); }; function Jl() { return new Fl(); } function Ql(t, e) { const n = arguments.length >= 2; return function (i) { return i.pipe(t ? jl((e, n) => t(e, n, i)) : dl, Bl(1), n ? Yl(e) : Zl(() => new Fl())); }; } function tf(t) { return function (e) { return e.lift(new ef(t)); }; } var ef = (function () { function t(t) { this.predicate = t; } return t.prototype.call = function (t, e) { return e.subscribe(new nf(t, this.predicate)); }, t; }()); var nf = (function (t) { function e(e, n) { const i = t.call(this, e) || this; return i.predicate = n, i.skipping = !0, i.index = 0, i; } return Xc(e, t), e.prototype._next = function (t) { const e = this.destination; this.skipping && this.tryCallPredicate(t), this.skipping || e.next(t); }, e.prototype.tryCallPredicate = function (t) { try { const e = this.predicate(t, this.index++); this.skipping = Boolean(e); } catch (n) { this.destination.error(n); } }, e; }(ch)); const rf = n('365b'); const of = n.n(rf); const sf = (function () { function t() { Fr(this, t), lr(this, 'pools', Br()(null)); } return ko(t, [{ key: '_preparePool', value(t) { this.pools[t] || (this.pools[t] = Br()(null)); } }, { key: 'set', value(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'default'; e != null && (this._preparePool(n), this.pools[n][t] = { value: e, refs: 1 }); } }, { key: 'get', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'default'; this._preparePool(e); const n = this.pools[e][t]; if (n && n.value != null) return n.refs++, this.pools[e][t] = n, n.value; } }, { key: 'unset', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'default'; this._preparePool(e); const n = this.pools[e][t]; n && n.value != null && (n.refs--, n.refs === 0 ? delete this.pools[e][t] : this.pools[e][t] = n); } }, { key: 'has', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'default'; return this._preparePool(e), !!this.pools[e][t]; } }, { key: 'ids', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'default'; return this._preparePool(t), ur()(this.pools[t]); } }, { key: 'refs', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'default'; return this._preparePool(e), this.has(t, e) ? this.pools[e][t].refs : void 0; } }]), t; }()); const af = sf; const uf = 'identityMap'; const cf = {
      IDENTITY_MAP_PROP: uf, props: { ident: [String, Number] }, methods: { makeSelfIdent() { if (this.ident) { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return this.makeIdent.apply(this, [this.ident].concat(e)); } }, makeIdent() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return e.filter(gr.h).join('.'); } }, created() { hf.call(this); },
    }; function hf() { const t = this; this[uf] || (Rr.a[uf] = Rr.a.prototype[uf] = new af()), zc()(this, { $identityMap: { enumerable: !0, get() { return t[uf]; } } }); } const lf = cf;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    const ff = function () {}; const pf = { methods: { subscribeAll() {}, unsubscribeAll() { this._rxSubs.forEach(t => t.unsubscribe()), this._rxSubs = []; }, subscribeTo(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ff; let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ff; const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ff; n = function (t) { n(t); }; const r = t.subscribe(e, n, i); return this._rxSubs.push(r), r; } }, beforeCreate() { this._rxSubs = []; }, destroyed() { this.unsubscribeAll(); } }; const df = pf; const vf = 'services'; const gf = {
      inject: { $services: vf }, provide() { return lr({}, vf, this.getServices()); }, methods: { getServices() { return xl({}, this.$services || {}); } }, beforeCreate() { let t = this.$parent; while (t) { if (t._provided != null && t._provided[vf] != null) break; t = t.$parent; }t != null && t._provided[vf] != null || delete this.$options.inject.$services; },
    }; const yf = gf; const mf = 'vm'; const _f = 'instance_promise'; const bf = {}; const wf = {
      beforeInit() {}, init: (function () { const t = Rl(Sl.a.mark(function t() { let e; let n; return Sl.a.wrap(function (t) { while (1) switch (t.prev = t.next) { case 0: return n = this.makeSelfIdent(), n && this.$identityMap.has(n, _f) ? e = this.$identityMap.get(n, _f) : (e = Ol.a.resolve(this.createOlObject()), n && this.$identityMap.set(n, e, _f)), t.next = 4, e; case 4: this._olObject = t.sent, this._olObject[mf] || (this._olObject[mf] = []), this._olObject[mf].includes(this) || this._olObject[mf].push(this), ++this.rev; case 8: case 'end': return t.stop(); } }, t, this); })); return function () { return t.apply(this, arguments); }; }()), createOlObject() { throw new Error('Not implemented method'); }, deinit() { const t = this; const e = this.makeSelfIdent(); e && this.$identityMap.unset(e, _f), this._olObject && (this._olObject[mf] = this._olObject[mf].filter(e => e !== t), this._olObject = void 0); }, getServices() { return yf.methods.getServices.call(this); }, mount() { throw new Error('Not implemented method'); }, unmount() { throw new Error('Not implemented method'); }, refresh() { const t = this; return this.$olObject == null ? Ol.a.resolve() : new Ol.a(((e) => { const n = function () { ++t.rev, e(); }; t.$olObject && Object(gr.l)(t.$olObject.changed) ? (t.$olObject.once('change', n), t.$olObject.changed()) : n(); })); }, remount() { const t = this; return this.$olObject == null ? Ol.a.resolve() : Ol.a.resolve(this.unmount()).then(() => t.mount()); }, recreate() { const t = this; return this.$olObject == null ? Ol.a.resolve() : Ol.a.resolve(this.unmount()).then(() => t.deinit()).then(() => t.init()).then(() => t.mount()); },
    }; const xf = {
      VM_PROP: mf, INSTANCE_PROMISE_POOL: _f, mixins: [lf, df, yf], props: bf, methods: wf, data() { return { rev: 0 }; }, created() { const t = this; this._olObject = void 0, this._createPromise = Ol.a.resolve(this.beforeInit()).then(this.init).then(() => t.$emit('created', t), t), this._mountPromise = Pl(100).pipe(tf(() => !t._mounted), Ql(), dh(() => t)).toPromise(Ol.a), zc()(this, { $olObject: { enumerable: !0, get() { return t._olObject; } }, $createPromise: { enumerable: !0, get() { return t._createPromise; } }, $mountPromise: { enumerable: !0, get() { return t._mountPromise; } } }), this.scheduleRefresh = of()(function () { return this.refresh(); }, 10), this.scheduleRemount = of()(function () { return this.remount(); }, 10), this.scheduleRecreate = of()(function () { return this.recreate(); }, 10); }, mounted() { const t = this; this.$createPromise.then(this.mount).then(() => { t._mounted = !0, t.$emit('mounted', t); }); }, destroyed() { const t = this; this.$mountPromise.then(this.unmount).then(this.deinit).then(() => { t.$emit('destroyed', t); }); },
    }; const Ef = xf;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    function Sf(t, e) { return t.reduce((t, n) => t[n] = e(n), t, {}); } function Tf(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; return ur()(t).reduce((n, i) => e.length && !e.includes(i) || (n = n.concat(t[i])), n, []); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const Of = { render(t) { let e; const n = this.$options.stubVNode || {}; if (n.empty) { const i = t(); return typeof n.empty === 'string' ? i.text = n.empty : typeof n.empty === 'function' && (i.text = n.empty.call(this)), i; }e = !1 === n.slots ? void 0 : Tf(this.$slots, n.slots); const r = typeof n.attrs === 'function' ? n.attrs.call(this) : n.attrs; const o = { attrs: r, style: { display: 'none !important' } }; return t(n.tag || 'i', o, e); } }; const Cf = Of; const Rf = {
      mixins: [Cf, Ef],
      methods: {
        init() { return Ef.methods.init.call(this); }, deinit() { return Ef.methods.deinit.call(this); }, createOlObject() { throw new Error('Not implemented method'); }, getServices() { return Ef.methods.getServices.call(this); }, refresh() { return Ef.methods.refresh.call(this); },
      },
    }; const If = Rf; const Pf = { methods: { beforeInit() { const t = this; return Pl(100).pipe(tf(() => !t.$map), Ql(), dh(() => t)).toPromise(Ol.a); } } }; const Lf = Pf; const Af = { coordinates: { type: Array, required: !0, validator(t) { return t.length; } } }; const Ff = {
      type() { throw new Error('Not implemented computed property'); }, extent() { if (this.extentViewProj && this.resolvedDataProjection) return this.extentToDataProj(this.extentViewProj); }, extentViewProj() { if (this.rev && this.$geometry) return this.$geometry.getExtent(); }, point() { if (this.pointViewProj && this.resolvedDataProjection) return this.pointToDataProj(this.pointViewProj); }, pointViewProj() { if (this.rev && this.$geometry) return sc(this.$geometry); }, coordinatesViewProj() { if (this.rev && this.$geometry) return this.$geometry.getCoordinates(); },
    }; const jf = {
      createOlObject() { return this.createGeometry(); }, createGeometry() { throw new Error('Not implemented method'); }, getCoordinates() { return co(this), this.toDataProj(this.$geometry.getCoordinates()); }, setCoordinates(t) { co(this), this.$geometry.setCoordinates(this.toViewProj(t)); }, init() { return this.setupTransformFunctions(), If.methods.init.call(this); }, setupTransformFunctions() { const t = this; const e = Tc[this.type].transform; this.toDataProj = function (n) { return e(n, t.viewProjection, t.resolvedDataProjection); }, this.toViewProj = function (n) { return e(n, t.resolvedDataProjection, t.viewProjection); }; }, deinit() { return If.methods.deinit.call(this); }, refresh() { return If.methods.refresh.call(this); }, getServices() { const t = this; return xl(If.methods.getServices.call(this), { get geometry() { return t.$geometry; } }); }, mount() { this.$geometryContainer && this.$geometryContainer.setGeometry(this), this.subscribeAll(); }, unmount() { this.unsubscribeAll(), this.$geometryContainer && this.$geometryContainer.setGeometry(void 0); }, subscribeAll() { Nf.call(this); },
    }; const kf = { coordinates(t) { if (this.$geometry && this.$view) { const e = Df({ coordinates: t, extent: nt(t) }, { coordinates: this.getCoordinates(), extent: this.extent }); e || this.setCoordinates(t); } }, resolvedDataProjection() { this.$geometry && (this.setupTransformFunctions(), this.setCoordinates(this.coordinates)); } }; const Mf = {
      mixins: [If, Lf, $c],
      props: Af,
      computed: Ff,
      watch: kf,
      methods: jf,
      stubVNode: { empty() { return this.$options.name; } },
      created() {
        const t = this; zc()(this, {
          $geometry: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $geometryContainer: { enumerable: !0, get() { return t.$services && t.$services.geometryContainer; } },
        });
      },
    }; function Nf() { const t = this; co(this); const e = 100; const n = ml(this.$geometry, 'change', () => ({ coordinates: t.getCoordinates(), extent: t.extent })).pipe(Bh(e), lh(Df), dh((t) => { const e = t.coordinates; return { prop: 'coordinates', value: e }; })); this.subscribeTo(n, (e) => { const n = e.prop; const i = e.value; ++t.rev, t.$emit('update:'.concat(n), i); }); } function Df(t, e) { return !!Object(gr.j)(t.extent, e.extent) && Object(gr.j)(t.coordinates, e.coordinates); } const $f = Mf; const Gf = {
      getGeometryTarget() { throw new Error('Not implemented method'); }, getGeometry() { return this._geometry; }, getServices() { const t = this; return { get geometryContainer() { return t; } }; }, setGeometry(t) { t instanceof Rr.a ? t = t.$geometry : Object(gr.o)(t) && (t = this.readGeometryInDataProj(t)), t !== this._geometry && (this._geometry = t); const e = this.getGeometryTarget(); e && t !== e.getGeometry() && e.setGeometry(t); },
    }; const Vf = { mixins: [$c], methods: Gf, created() { this._geometry = void 0, zc()(this, { $geometry: { enumerable: !0, get: this.getGeometry } }); } }; const Bf = Vf; const Uf = {
      attributions: [String, Array], logo: String, projection: String, wrapX: { type: Boolean, default: !0 },
    }; const zf = {
      createOlObject() { return this.createSource(); }, createSource() { throw new Error('Not implemented method'); }, init() { return If.methods.init.call(this); }, deinit() { return If.methods.deinit.call(this); }, getServices() { const t = this; return xl(If.methods.getServices.call(this), { get source() { return t.$source; } }); }, mount() { this.$sourceContainer && this.$sourceContainer.setSource(this), this.subscribeAll(); }, unmount() { this.unsubscribeAll(), this.$sourceContainer && this.$sourceContainer.setSource(void 0); }, refresh() { const t = this; return this.$source && !Object(gr.l)(this.$source.clear) ? If.methods.refresh.call(this) : new Ol.a(((e) => { const n = function () { ++t.rev, e(); }; t.$source ? (t.$source.once('change', n), t.$source.clear()) : n(); })); },
    }; const Yf = { attributions(t) { this.$source && this.$source.setAttributions(t); } }; const Xf = {
      mixins: [If, Lf],
      props: Uf,
      methods: zf,
      watch: Yf,
      stubVNode: { empty() { return this.$options.name; } },
      created() {
        const t = this; zc()(this, {
          $source: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $sourceContainer: { enumerable: !0, get() { return t.$services && t.$services.sourceContainer; } },
        });
      },
    }; const Wf = Xf; const Kf = { crossOrigin: String, projection: { type: String, default: vo } }; const Hf = {
      init() { return Wf.methods.init.call(this); }, deinit() { return Wf.methods.deinit.call(this); }, mount() { Wf.methods.mount.call(this); }, unmount() { Wf.methods.unmount.call(this); },
    }; const qf = { mixins: [Wf], props: Kf, methods: Hf }; const Zf = qf;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    function Jf(t, e, n, i, r) { if (Fo()(e)) return gl(...el(e.map(e => Jf(t, e)))); r = r || function (t, e) { return t.get(e); }; const o = 'change:'.concat(e); const s = ml(t, o, () => r(t, e)); const a = []; return i != null && a.push(Bh(i)), n && (Object(gr.l)(n) || (n = gr.j), a.push(lh(n))), a.push(dh(t => ({ prop: e, value: t }))), s.pipe(...a); } const Qf = Jf; const tp = {
      createOlObject() { return this.createStyle(); }, createStyle() { throw new Error('Not implemented method'); }, init() { return If.methods.init.call(this); }, deinit() { return If.methods.deinit.call(this); }, getServices() { const t = this; return xl(If.methods.getServices.call(this), { get style() { return t.$style; } }); }, refresh() { const t = this; return this.$olObject == null ? Ol.a.resolve() : this.remount().then(() => { if (t.$map) return t.$map.render(), ml(t.$map, 'postcompose').pipe(Ql()).toPromise(); }); },
    }; const ep = {
      mixins: [If, Lf],
      methods: tp,
      stubVNode: { empty() { return this.$options.name; } },
      created() {
        const t = this; zc()(this, {
          $style: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $stylesContainer: { enumerable: !0, get() { return t.$services && t.$services.stylesContainer; } },
        });
      },
    }; const np = ep; const ip = {}; const rp = {
      init() { return np.methods.init.call(this); }, deinit() { return np.methods.deinit.call(this); }, mount() { this.$stylesContainer && this.$stylesContainer.setImage(this); }, unmount() { this.$stylesContainer && this.$stylesContainer.setImage(void 0); }, getServices() { return np.methods.getServices.call(this); }, refresh() { return this.recreate(); },
    }; const op = {}; const sp = {
      mixins: [np], props: ip, methods: rp, watch: op, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } },
    }; const ap = sp; const up = { id: { type: [String, Number], default() { return Pr()(); } }, active: { type: Boolean, default: !0 }, priority: { type: Number, default: 0 } }; const cp = {
      createOlObject: (function () { const t = Rl(Sl.a.mark(function t() { let e; return Sl.a.wrap(function (t) { while (1) switch (t.prev = t.next) { case 0: return t.next = 2, this.createInteraction(); case 2: return e = t.sent, e.setActive(this.active), e.setProperties({ id: this.id, priority: this.priority }), t.abrupt('return', e); case 6: case 'end': return t.stop(); } }, t, this); })); return function () { return t.apply(this, arguments); }; }()), createInteraction() { throw new Error('Not implemented method'); }, getServices() { const t = this; return xl(If.methods.getServices.call(this), { get interaction() { return t.$interaction; } }); }, init() { return If.methods.init.call(this); }, deinit() { return If.methods.deinit.call(this); }, mount() { this.$interactionsContainer && this.$interactionsContainer.addInteraction(this), this.subscribeAll(); }, unmount() { this.unsubscribeAll(), this.$interactionsContainer && this.$interactionsContainer.removeInteraction(this); }, refresh() { return If.methods.refresh.call(this); },
    }; const hp = { active(t) { this.$interaction && t !== this.$interaction.getActive() && this.$interaction.setActive(t); }, priority(t) { this.$interactionsContainer && (this.$interaction.set('priority', t), this.$interactionsContainer.sortInteractions()); } }; const lp = {
      mixins: [If, Lf],
      props: up,
      methods: cp,
      watch: hp,
      stubVNode: { empty() { return this.$options.name; } },
      created() {
        const t = this; zc()(this, {
          $interaction: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $interactionsContainer: { enumerable: !0, get() { return t.$services && t.$services.interactionsContainer; } },
        });
      },
    }; const fp = lp; const pp = { ACTIVE: 'active' }; const dp = (function (t) { function e(e) { t.call(this), e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getActive = function () { return this.get(pp.ACTIVE); }, e.prototype.getMap = function () { return this.map_; }, e.prototype.handleEvent = function (t) { return !0; }, e.prototype.setActive = function (t) { this.set(pp.ACTIVE, t); }, e.prototype.setMap = function (t) { this.map_ = t; }, e; }(di));
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function vp(t, e, n) { const i = t.getCenter(); if (i) { const r = t.constrainCenter([i[0] + e[0], i[1] + e[1]]); n ? t.animate({ duration: n, easing: he, center: r }) : t.setCenter(r); } } function gp(t, e, n, i) { e = t.constrainRotation(e, 0), yp(t, e, n, i); } function yp(t, e, n, i) {
      if (void 0 !== e) {
        const r = t.getRotation(); const o = t.getCenter(); void 0 !== r && o && i > 0 ? t.animate({
          rotation: e, anchor: n, duration: i, easing: ue,
        }) : t.rotate(e, n);
      }
    } function mp(t, e, n, i, r) { e = t.constrainResolution(e, 0, r), bp(t, e, n, i); } function _p(t, e, n, i) { const r = t.getResolution(); let o = t.constrainResolution(r, e, 0); if (void 0 !== o) { const s = t.getResolutions(); o = Vt(o, t.getMinResolution() || s[s.length - 1], t.getMaxResolution() || s[0]); } if (n && void 0 !== o && o !== r) { const a = t.getCenter(); let u = t.calculateCenterZoom(o, n); u = t.constrainCenter(u), n = [(o * a[0] - r * u[0]) / (o - r), (o * a[1] - r * u[1]) / (o - r)]; }bp(t, o, n, i); } function bp(t, e, n, i) {
      if (e) {
        const r = t.getResolution(); const o = t.getCenter(); if (void 0 !== r && o && e !== r && i) {
          t.animate({
            resolution: e, anchor: n, duration: i, easing: ue,
          });
        } else { if (n) { const s = t.calculateCenterZoom(e, n); t.setCenter(s); }t.setResolution(e); }
      }
    } const wp = dp; const xp = {
      getInteractionsTarget() { throw new Error('Not implemented method'); }, addInteraction(t) { t = t instanceof Rr.a ? t.$interaction : t, no(t, wp), !1 === this.getInteractionsTarget().has(t) && (this.getInteractionsTarget().add(t), this.sortInteractions()); }, removeInteraction(t) { t = t instanceof Rr.a ? t.$interaction : t, t && this.getInteractionsTarget().has(t) && (this.getInteractionsTarget().remove(t), this.sortInteractions()); }, getInteractions() { return this.getInteractionsTarget().elements; }, getInteractionById(t) { return this.getInteractionsTarget().findByKey(t); }, sortInteractions(t) { t || (t = this.getDefaultInteractionsSorter()), this.getInteractionsTarget().sort(t); }, getDefaultInteractionsSorter() { return function () { return 0; }; }, clearInteractions() { this.getInteractionsTarget().clear(); }, getServices() { const t = this; return { get interactionsContainer() { return t; } }; },
    }; const Ep = { methods: xp }; const Sp = Ep; const Tp = {
      getSourceTarget() { throw new Error('Not implemented method'); }, getSource() { return this._source; }, getServices() { const t = this; return { get sourceContainer() { return t; } }; }, setSource(t) { t = t instanceof Rr.a ? t.$source : t, t !== this._source && (this._source = t); const e = this.getSourceTarget(); e && t !== e.getSource() && e.setSource(t); },
    }; const Op = { methods: Tp, created() { this._source = void 0; } }; const Cp = Op; const Rp = {
      id: { type: [String, Number], default() { return Pr()(); } }, extent: { type: Array, validator(t) { return t.length === 4; } }, minResolution: Number, maxResolution: Number, opacity: { type: Number, default: 1 }, overlay: { type: Boolean, default: !1 }, visible: { type: Boolean, default: !0 }, zIndex: Number,
    }; const Ip = {
      createOlObject: (function () { const t = Rl(Sl.a.mark(function t() { let e; return Sl.a.wrap(function (t) { while (1) switch (t.prev = t.next) { case 0: return t.next = 2, this.createLayer(); case 2: return e = t.sent, e.set('id', this.id), t.abrupt('return', e); case 5: case 'end': return t.stop(); } }, t, this); })); return function () { return t.apply(this, arguments); }; }()), createLayer() { throw new Error('Not implemented method'); }, init() { return If.methods.init.call(this); }, deinit() { return If.methods.deinit.call(this); }, isAtPixel(t) { const e = this; return io(this), this.$map.forEachLayerAtPixel(t, t => t === e.$layer); }, getServices() { const t = this; return xl(If.methods.getServices.call(this), Cp.methods.getServices.call(this), { get layer() { return t.$layer; } }); }, getSourceTarget() { return this.$layer; }, mount() { this.overlay && this.$map ? this.setMap(this.$map) : this.$layersContainer && this.$layersContainer.addLayer(this), this.subscribeAll(); }, unmount() { this.unsubscribeAll(), this.overlay ? this.setMap(void 0) : this.$layersContainer && this.$layersContainer.removeLayer(this); }, refresh() { return If.methods.refresh.call(this); }, setMap(t) { ao(this), t = t instanceof Rr.a ? t.$map : t, this.$layer.setMap(t); },
    }; const Pp = {
      id(t) { this.$layer && t !== this.$layer.get('id') && this.$layer.set('id', t); }, maxResolution(t) { this.$layer && t !== this.$layer.getMaxResolution() && this.$layer.setMaxResolution(t); }, minResolution(t) { this.$layer && t !== this.$layer.getMinResolution() && this.$layer.setMinResolution(t); }, opacity(t) { this.$layer && t !== this.$layer.getOpacity() && this.$layer.setOpacity(t); }, visible(t) { this.$layer && t !== this.$layer.getVisible() && this.$layer.setVisible(t); }, zIndex(t) { this.$layer && t !== this.$layer.getZIndex() && this.$layer.setZIndex(t); }, extent(t) { this.$layer && !Object(gr.j)(t, this.$layer.getExtent()) && this.$layer.setExtent(t); },
    }; const Lp = {
      mixins: [If, Lf, Cp],
      props: Rp,
      methods: Ip,
      watch: Pp,
      stubVNode: { attrs() { return { id: [this.$options.name, this.id].join('-'), class: this.$options.name }; } },
      created() {
        const t = this; zc()(this, {
          $layer: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $layersContainer: { enumerable: !0, get() { return t.$services && t.$services.layersContainer; } },
        });
      },
    }; const Ap = Lp; const Fp = {
      OPACITY: 'opacity', VISIBLE: 'visible', EXTENT: 'extent', Z_INDEX: 'zIndex', MAX_RESOLUTION: 'maxResolution', MIN_RESOLUTION: 'minResolution', SOURCE: 'source',
    }; const jp = (function (t) { function e(e) { t.call(this); const n = qt({}, e); n[Fp.OPACITY] = void 0 !== e.opacity ? e.opacity : 1, n[Fp.VISIBLE] = void 0 === e.visible || e.visible, n[Fp.Z_INDEX] = e.zIndex, n[Fp.MAX_RESOLUTION] = void 0 !== e.maxResolution ? e.maxResolution : 1 / 0, n[Fp.MIN_RESOLUTION] = void 0 !== e.minResolution ? e.minResolution : 0, this.setProperties(n), this.state_ = null, this.type; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getType = function () { return this.type; }, e.prototype.getLayerState = function () { const t = this.state_ || { layer: this, managed: !0 }; return t.opacity = Vt(this.getOpacity(), 0, 1), t.sourceState = this.getSourceState(), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = this.getZIndex() || 0, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), this.state_ = t, t; }, e.prototype.getLayersArray = function (t) { return W(); }, e.prototype.getLayerStatesArray = function (t) { return W(); }, e.prototype.getExtent = function () { return this.get(Fp.EXTENT); }, e.prototype.getMaxResolution = function () { return this.get(Fp.MAX_RESOLUTION); }, e.prototype.getMinResolution = function () { return this.get(Fp.MIN_RESOLUTION); }, e.prototype.getOpacity = function () { return this.get(Fp.OPACITY); }, e.prototype.getSourceState = function () { return W(); }, e.prototype.getVisible = function () { return this.get(Fp.VISIBLE); }, e.prototype.getZIndex = function () { return this.get(Fp.Z_INDEX); }, e.prototype.setExtent = function (t) { this.set(Fp.EXTENT, t); }, e.prototype.setMaxResolution = function (t) { this.set(Fp.MAX_RESOLUTION, t); }, e.prototype.setMinResolution = function (t) { this.set(Fp.MIN_RESOLUTION, t); }, e.prototype.setOpacity = function (t) { this.set(Fp.OPACITY, t); }, e.prototype.setVisible = function (t) { this.set(Fp.VISIBLE, t); }, e.prototype.setZIndex = function (t) { this.set(Fp.Z_INDEX, t); }, e; }(di)); const kp = jp; const Mp = {
      getLayersTarget() { throw new Error('Not implemented method'); }, addLayer(t) { t = t instanceof Rr.a ? t.$layer : t, no(t, kp), !1 === this.getLayersTarget().has(t) && this.getLayersTarget().add(t); }, removeLayer(t) { t = t instanceof Rr.a ? t.$layer : t, t && this.getLayersTarget().has(t) && this.getLayersTarget().remove(t); }, getLayers() { return this.getLayersTarget().elements; }, getLayerById(t) { return this.getLayersTarget().findByKey(t); }, clearLayers() { this.getLayersTarget().clear(); }, getServices() { const t = this; return { get layersContainer() { return t; } }; },
    }; const Np = { methods: Mp }; const Dp = Np; const $p = { POSTRENDER: 'postrender', MOVESTART: 'movestart', MOVEEND: 'moveend' }; const Gp = {
      BOTTOM_LEFT: 'bottom-left', BOTTOM_CENTER: 'bottom-center', BOTTOM_RIGHT: 'bottom-right', CENTER_LEFT: 'center-left', CENTER_CENTER: 'center-center', CENTER_RIGHT: 'center-right', TOP_LEFT: 'top-left', TOP_CENTER: 'top-center', TOP_RIGHT: 'top-right',
    }; const Vp = 'ol-hidden'; const Bp = 'ol-selectable'; const Up = 'ol-unselectable'; const zp = 'ol-control'; const Yp = 'ol-collapsed'; const Xp = (function () { let t; const e = {}; return function (n) { if (t || (t = document.createElement('div').style), !(n in e)) { t.font = n; const i = t.fontFamily; if (t.font = '', !i) return null; e[n] = i.split(/,\s?/); } return e[n]; }; }()); const Wp = {
      ELEMENT: 'element', MAP: 'map', OFFSET: 'offset', POSITION: 'position', POSITIONING: 'positioning',
    }; const Kp = (function (t) {
      function e(e) {
        t.call(this), this.options = e, this.id = e.id, this.insertFirst = void 0 === e.insertFirst || e.insertFirst, this.stopEvent = void 0 === e.stopEvent || e.stopEvent, this.element = document.createElement('div'), this.element.className = void 0 !== e.className ? e.className : `ol-overlay-container ${Bp}`, this.element.style.position = 'absolute', this.autoPan = void 0 !== e.autoPan && e.autoPan, this.autoPanAnimation = e.autoPanAnimation || {}, this.autoPanMargin = void 0 !== e.autoPanMargin ? e.autoPanMargin : 20, this.rendered = {
          bottom_: '', left_: '', right_: '', top_: '', visible: !0,
        }, this.mapPostrenderListenerKey = null, _e(this, pi(Wp.ELEMENT), this.handleElementChanged, this), _e(this, pi(Wp.MAP), this.handleMapChanged, this), _e(this, pi(Wp.OFFSET), this.handleOffsetChanged, this), _e(this, pi(Wp.POSITION), this.handlePositionChanged, this), _e(this, pi(Wp.POSITIONING), this.handlePositioningChanged, this), void 0 !== e.element && this.setElement(e.element), this.setOffset(void 0 !== e.offset ? e.offset : [0, 0]), this.setPositioning(void 0 !== e.positioning ? e.positioning : Gp.TOP_LEFT), void 0 !== e.position && this.setPosition(e.position);
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getElement = function () { return this.get(Wp.ELEMENT); }, e.prototype.getId = function () { return this.id; }, e.prototype.getMap = function () { return this.get(Wp.MAP); }, e.prototype.getOffset = function () { return this.get(Wp.OFFSET); }, e.prototype.getPosition = function () { return this.get(Wp.POSITION); }, e.prototype.getPositioning = function () { return this.get(Wp.POSITIONING); }, e.prototype.handleElementChanged = function () { Ge(this.element); const t = this.getElement(); t && this.element.appendChild(t); }, e.prototype.handleMapChanged = function () { this.mapPostrenderListenerKey && ($e(this.element), xe(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null); const t = this.getMap(); if (t) { this.mapPostrenderListenerKey = _e(t, $p.POSTRENDER, this.render, this), this.updatePixelPosition(); const e = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer(); this.insertFirst ? e.insertBefore(this.element, e.childNodes[0] || null) : e.appendChild(this.element); } }, e.prototype.render = function () { this.updatePixelPosition(); }, e.prototype.handleOffsetChanged = function () { this.updatePixelPosition(); }, e.prototype.handlePositionChanged = function () { this.updatePixelPosition(), this.get(Wp.POSITION) && this.autoPan && this.panIntoView(); }, e.prototype.handlePositioningChanged = function () { this.updatePixelPosition(); }, e.prototype.setElement = function (t) { this.set(Wp.ELEMENT, t); }, e.prototype.setMap = function (t) { this.set(Wp.MAP, t); }, e.prototype.setOffset = function (t) { this.set(Wp.OFFSET, t); }, e.prototype.setPosition = function (t) { this.set(Wp.POSITION, t); }, e.prototype.panIntoView = function () { const t = this.getMap(); if (t && t.getTargetElement()) { const e = this.getRect(t.getTargetElement(), t.getSize()); const n = this.getElement(); const i = this.getRect(n, [Me(n), Ne(n)]); const r = this.autoPanMargin; if (!ut(e, i)) { const o = i[0] - e[0]; const s = e[2] - i[2]; const a = i[1] - e[1]; const u = e[3] - i[3]; const c = [0, 0]; if (o < 0 ? c[0] = o - r : s < 0 && (c[0] = Math.abs(s) + r), a < 0 ? c[1] = a - r : u < 0 && (c[1] = Math.abs(u) + r), c[0] !== 0 || c[1] !== 0) { const h = t.getView().getCenter(); const l = t.getPixelFromCoordinate(h); const f = [l[0] + c[0], l[1] + c[1]]; t.getView().animate({ center: t.getCoordinateFromPixel(f), duration: this.autoPanAnimation.duration, easing: this.autoPanAnimation.easing }); } } } }, e.prototype.getRect = function (t, e) { const n = t.getBoundingClientRect(); const i = n.left + window.pageXOffset; const r = n.top + window.pageYOffset; return [i, r, i + e[0], r + e[1]]; }, e.prototype.setPositioning = function (t) { this.set(Wp.POSITIONING, t); }, e.prototype.setVisible = function (t) { this.rendered.visible !== t && (this.element.style.display = t ? '' : 'none', this.rendered.visible = t); }, e.prototype.updatePixelPosition = function () { const t = this.getMap(); const e = this.getPosition(); if (t && t.isRendered() && e) { const n = t.getPixelFromCoordinate(e); const i = t.getSize(); this.updateRenderedPosition(n, i); } else this.setVisible(!1); }, e.prototype.updateRenderedPosition = function (t, e) { const n = this.element.style; const i = this.getOffset(); const r = this.getPositioning(); this.setVisible(!0); let o = i[0]; let s = i[1]; if (r == Gp.BOTTOM_RIGHT || r == Gp.CENTER_RIGHT || r == Gp.TOP_RIGHT) { this.rendered.left_ !== '' && (this.rendered.left_ = n.left = ''); const a = `${Math.round(e[0] - t[0] - o)}px`; this.rendered.right_ != a && (this.rendered.right_ = n.right = a); } else { this.rendered.right_ !== '' && (this.rendered.right_ = n.right = ''), r != Gp.BOTTOM_CENTER && r != Gp.CENTER_CENTER && r != Gp.TOP_CENTER || (o -= this.element.offsetWidth / 2); const u = `${Math.round(t[0] + o)}px`; this.rendered.left_ != u && (this.rendered.left_ = n.left = u); } if (r == Gp.BOTTOM_LEFT || r == Gp.BOTTOM_CENTER || r == Gp.BOTTOM_RIGHT) { this.rendered.top_ !== '' && (this.rendered.top_ = n.top = ''); const c = `${Math.round(e[1] - t[1] - s)}px`; this.rendered.bottom_ != c && (this.rendered.bottom_ = n.bottom = c); } else { this.rendered.bottom_ !== '' && (this.rendered.bottom_ = n.bottom = ''), r != Gp.CENTER_LEFT && r != Gp.CENTER_CENTER && r != Gp.CENTER_RIGHT || (s -= this.element.offsetHeight / 2); const h = `${Math.round(t[1] + s)}px`; this.rendered.top_ != h && (this.rendered.top_ = n.top = h); } }, e.prototype.getOptions = function () { return this.options; }, e;
    }(di)); const Hp = Kp; const qp = {
      getOverlaysTarget() { throw new Error('Not implemented method'); }, addOverlay(t) { t = t instanceof Rr.a ? t.$overlay : t, no(t, Hp), !1 === this.getOverlaysTarget().has(t) && this.getOverlaysTarget().add(t); }, removeOverlay(t) { t = t instanceof Rr.a ? t.$overlay : t, t && this.getOverlaysTarget().has(t) && this.getOverlaysTarget().remove(t); }, getOverlays() { return this.getOverlaysTarget().elements; }, getOverlayById(t) { return this.getOverlaysTarget().findByKey(t); }, clearOverlays() { this.getOverlaysTarget().clear(); }, getServices() { const t = this; return { get overlaysContainer() { return t; } }; },
    }; const Zp = { methods: qp }; const Jp = Zp; const Qp = {
      created() { this._styles = void 0; },
      methods: {
        getDefaultStyles() {}, getServices() { const t = this; return { get stylesContainer() { return t; } }; }, getStyles() { return this._styles; }, addStyle(t) { let e = this.getStyles(); const n = t instanceof Rr.a ? t.$style : t; Object(gr.l)(n) ? e = t : (Fo()(e) || (e = []), t = t instanceof Rr.a ? t : { $style: t, condition: !0 }, e.includes(t) || e.push(t)), this.setStyle(e); }, setStyle(t) { if (t !== this._styles) { this._styles = t; const e = this.getStyleTarget(); e && (this._styles === null || this._styles ? e.setStyle(this.createStyleFunc()) : e.setStyle(void 0)); } }, removeStyle(t) { let e = this.getStyles(); e === t ? e = void 0 : Fo()(e) && (e = e.filter(e => (t instanceof Rr.a ? e !== t : e.$style !== t)), e.length || (e = void 0)), this.setStyle(e); }, getStyleTarget() { throw new Error('Not implemented method'); }, createStyleFunc() { const t = this; const e = this.getDefaultStyles(); return function (n, i) { if (n.getGeometry()) { let r = t.getStyles(); if (r && (Object(gr.l)(r) || Object(gr.l)(r.$style))) { const o = Object(gr.l)(r) ? r : r.$style; r = o(n, i); } else Fo()(r) && (r = Object(gr.x)(r, (t, e) => { const r = e.$style; const o = e.condition; return (o == null || !0 === o || Object(gr.l)(o) && o(n, i)) && t.push(r), t; }, [])); return r === null || Fo()(r) && r.length ? r : (r = e, r ? Object(gr.l)(r) ? r(n, i) : r : void 0); } }; },
      },
    }; const td = Qp;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    /*!
OpenLayers tile url function to load tile seeded with TileCache url scheme

@package ol-tilecache
@author Vladimir Vershinin <ghettovoice@gmail.com>
@version 3.0.1
@licence MIT
@copyright (c) 2016-2018, Vladimir Vershinin <ghettovoice@gmail.com>
*/
    /**
 * This file is part of ol-tilecache package.
 * @module ol-tilecache
 * @license MIT
 * @author Vladimir Vershinin
 */
    function ed(t, e) { const n = e - t.toString().length + 1; return (new Array(parseInt(n > 0 && n, 10)).join('0') + t).toString().slice(-e); } function nd(t, e) { const n = t % e; return n * e < 0 ? n + e : n; } function id(t) { return Object.prototype.toString.call(t) === '[object Array]'; } const rd = (function () { function t(t, e) { const n = []; let i = !0; let r = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done); i = !0) if (n.push(s.value), e && n.length === e) break; } catch (u) { r = !0, o = u; } finally { try { !i && a.return && a.return(); } finally { if (r) throw o; } } return n; } return function (e, n) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, n); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }());
    /**
 * This file is part of ol-tilecache package.
 * @module ol-tilecache
 * @license MIT
 * @author Vladimir Vershinin
 */function od(t, e, n) {
      const i = t.getResolution(n); const r = sd(t, e[0], e[1], i, !1); const o = rd(r, 2); const s = o[0]; const a = o[1]; const u = sd(t, e[2], e[3], i, !0); const c = rd(u, 2); const h = c[0]; const l = c[1]; return {
        minX: s, minY: a, maxX: h, maxY: l,
      };
    } function sd(t, e, n, i, r) { const o = t.getZForResolution(i); const s = i / t.getResolution(o); const a = t.getOrigin(o); let u = t.getTileSize(o); id(u) || (u = [u, u]); const c = r ? 0.5 : 0; const h = r ? 0 : 0.5; const l = Math.floor((e - a[0]) / i + c); const f = Math.floor((n - a[1]) / i + h); let p = s * l / u[0]; let d = s * f / u[1]; return r ? (p = Math.ceil(p) - 1, d = Math.ceil(d) - 1) : (p = Math.floor(p), d = Math.floor(d)), [p, d]; } function ad(t) { return t.maxY - t.minY + 1; }
    /**
 * This file is part of ol-tilecache package.
 * @module ol-tilecache
 * @license MIT
 * @author Vladimir Vershinin
 */const ud = /{z}/g; const cd = /{0z}/g; const hd = /{x\d?}/g; const ld = /{y\d?}/g; const fd = /{-y\d?}/g; const pd = [-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244]; function dd(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Gi(); const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : pd; return gd(_d(t), e, n); } function vd(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Gi(); const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : pd; return function (i) {
        if (i != null) {
          return t.replace(ud, yd(i[0])).replace(cd, yd(i[0], !0)).replace(hd, md(i[1])).replace(ld, (t) => { const e = -i[2] - 1; return md(e)(t); })
            .replace(fd, (t) => { const r = i[0]; const o = od(e, n, r); const s = ad(o) + i[2]; return md(s)(t); });
        }
      };
    } function gd(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Gi(); const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : pd; return bd(t.map(t => vd(t, e, n))); } function yd(t, e) { return function () { return e ? ed(t, 2) : t.toString(); }; } function md(t) { return function (e) { const n = e.match(/\d/); return n ? ed(t, 9).slice(3 * (n[0] - 1), 3 * n[0]) : t.toString(); }; } function _d(t) { const e = []; const n = /{(\d)-(\d)}/.exec(t) || /{([a-z])-([a-z])}/.exec(t); if (n) for (let i = n[1].charCodeAt(0), r = n[2].charCodeAt(0), o = i; o <= r; ++o)e.push(t.replace(n[0], String.fromCharCode(o))); else e.push(t); return e; } function bd(t) { return t.length === 1 ? t[0] : function (e, n, i) { if (e != null) { const r = (e[1] << e[0]) + e[2]; const o = nd(r, t.length); return t[o](e, n, i); } }; }
    /**
 * This file is part of ol-tilecache package.
 * @module ol-tilecache
 * @license MIT
 * @author Vladimir Vershinin
 */
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    function wd(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : go; let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : mo; n = ie(n); for (var i = Pt(t), r = jt(t), o = Math.max(r / n[0], i / n[1]), s = e + 1, a = new Array(s), u = 0; u < s; ++u)a[u] = o / Math.pow(2, u); return a; } typeof window !== 'undefined' && window.ol && (window.ol.tileCacheUrlFn = { createTileUrlFunction: dd, createTileUrlFunctionFromTemplate: vd, createTileUrlFunctionFromTemplates: gd });
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    const xd = { props: { url: { type: String } }, computed: { urlTmpl() { return Object(gr.y)(this.url, Object(gr.u)(this, this.urlTokens)); }, urlTokens() { return []; } } }; const Ed = xd; const Sd = {
      cacheSize: { type: Number, default: wo }, crossOrigin: String, maxZoom: { type: Number, default: go }, minZoom: { type: Number, default: yo }, opaque: Boolean, projection: { type: String, default: vo }, reprojectionErrorThreshold: { type: Number, default: Eo }, tilePixelRatio: { type: Number, default: xo }, tileSize: { type: Array, default() { return [mo, mo]; }, validator(t) { return t.length === 2; } }, tileLoadFunction: Function, url: { type: [String, Function], required: !0 }, transition: Number,
    }; const Td = { urlTmpl() { return Object(gr.p)(this.url) ? Object(gr.y)(this.url, Object(gr.u)(this, this.urlTokens)) : ''; } }; const Od = {
      createTileGrid() {
        return ro(this), Gi({
          extent: Wh(this.$view.getProjection()), maxZoom: this.maxZoom, minZoom: this.minZoom, tileSize: this.tileSize,
        });
      },
      createUrlFunc() { return Object(gr.l)(this.url) ? this.url : (ro(this), dd(this.urlTmpl, this._tileGrid, Wh(this.$view.getProjection()))); },
      init() { return this._tileGrid = this.createTileGrid(), Wf.methods.init.call(this); },
      deinit() { return this._tileGrid = void 0, Wf.methods.deinit.call(this); },
      mount() { Wf.methods.mount.call(this); },
      unmount() { Wf.methods.mount.call(this); },
    }; const Cd = { url() { this.$source && (this.$source.setTileUrlFunction(this.createUrlFunc()), this.scheduleRefresh()); } }; const Rd = {
      mixins: [Wf, Ed], props: Sd, computed: Td, methods: Od, watch: Cd,
    }; const Id = Rd; const Pd = {
      updateWhileAnimating: Boolean, updateWhileInteracting: Boolean, renderBuffer: { type: Number, default: 100 }, renderOrder: Function, declutter: Boolean,
    }; const Ld = {
      init() { return Ap.methods.init.call(this); }, deinit() { return Ap.methods.deinit.call(this); }, getServices() { return xl(Ap.methods.getServices.call(this), td.methods.getServices.call(this)); }, getStyleTarget() { return this.$layer; }, mount() { Ap.methods.mount.call(this); }, unmount() { Ap.methods.unmount.call(this); },
    }; const Ad = { mixins: [Ap, td], props: Pd, methods: Ld }; const Fd = Ad; function jd(t, e) { return void 0 === e && (e = wh), function (n) { return n.lift(new kd(t, e)); }; } var kd = (function () { function t(t, e) { this.dueTime = t, this.scheduler = e; } return t.prototype.call = function (t, e) { return e.subscribe(new Md(t, this.dueTime, this.scheduler)); }, t; }()); var Md = (function (t) { function e(e, n, i) { const r = t.call(this, e) || this; return r.dueTime = n, r.scheduler = i, r.debouncedSubscription = null, r.lastValue = null, r.hasValue = !1, r; } return Xc(e, t), e.prototype._next = function (t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(Nd, this.dueTime, this)); }, e.prototype._complete = function () { this.debouncedNext(), this.destination.complete(); }, e.prototype.debouncedNext = function () { if (this.clearDebounce(), this.hasValue) { const t = this.lastValue; this.lastValue = null, this.hasValue = !1, this.destination.next(t); } }, e.prototype.clearDebounce = function () { const t = this.debouncedSubscription; t !== null && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null); }, e; }(ch)); function Nd(t) { t.debouncedNext(); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const Dd = (function () { function t(e, n) { const i = this; Fr(this, t), this._adaptee = e, this._getElementKey = n, this._index = Br()(null), this._adaptee.forEach(t => i._addToIndex(i._getElementKey(t), t)); } return ko(t, [{ key: 'forEach', value(t) { Object(gr.f)(this.elements, t); } }, { key: 'add', value(t) { const e = this._getElementKey(t); e != null && (this._adaptee.push(t), this._index[e] = t); } }, { key: 'remove', value(t) { this._adaptee.remove(t) && this._removeFromIndex(this._getElementKey(t)); } }, { key: 'has', value(t) { return !!this.findByKey(this._getElementKey(t)); } }, { key: 'clear', value() { this._adaptee.clear(), this._resetIndex(); } }, { key: 'findByKey', value(t) { return t && this._index[t]; } }, { key: 'sort', value(t) { this.elements.sort(t); } }, { key: '_resetIndex', value() { this._index = Br()(null); } }, { key: '_addToIndex', value(t, e) { return t != null && (this._index[t] = e, e.on('propertychange', this._handleElementChange, this), !0); } }, { key: '_removeFromIndex', value(t) { const e = this.findByKey(t); return e && (e.un('propertychange', this._handleElementChange, this), delete this._index[t]), !!e; } }, { key: '_handleElementChange', value(t) { const e = t.target; const n = this._getElementKey(e); if (this.findByKey(n) !== e) for (const i in this._index) if (this._index[i] === e) { this._removeFromIndex(i); break; } this._addToIndex(n, e); } }, { key: 'adaptee', get() { return this._adaptee; } }, { key: 'elements', get() { return this._adaptee.getArray(); } }]), t; }()); const $d = (function () { function t(e) { Fr(this, t), this._adaptee = e; } return ko(t, [{ key: 'forEach', value(t) { this.elements.forEach(t); } }, { key: 'add', value(t) { this._adaptee.addFeature(t); } }, { key: 'remove', value(t) { this._adaptee.removeFeature(t); } }, { key: 'has', value(t) { return !!this.findByKey(t.getId()); } }, { key: 'clear', value() { this._adaptee.clear(); } }, { key: 'findByKey', value(t) { return this._adaptee.getFeatureById(t); } }, { key: 'sort', value(t) { throw new Error('Not supported'); } }, { key: 'adaptee', get() { return this._adaptee; } }, { key: 'elements', get() { return this._adaptee.getFeatures(); } }]), t; }()); const Gd = { useSpatialIndex: { type: Boolean, default: !0 } }; const Vd = { featuresViewProj() { return this.rev && this.resolvedDataProjection && this.$source ? this.getFeatures().map(this.writeFeatureInViewProj.bind(this)) : []; } }; const Bd = {
      clear() { Bc.methods.clearFeatures.call(this); }, getFeaturesTarget() { return this._featuresTarget == null && this.$source && (this._featuresTarget = new $d(this.$source)), this._featuresTarget; }, getServices() { return xl(Wf.methods.getServices.call(this), Bc.methods.getServices.call(this)); }, init() { return Wf.methods.init.call(this); }, deinit() { return Wf.methods.deinit.call(this); }, mount() { Wf.methods.mount.call(this); }, unmount() { this.clear(), Wf.methods.unmount.call(this); }, subscribeAll() { zd.call(this); }, writeFeatureInDataProj(t) { return $c.methods.writeFeatureInDataProj.call(this, t); }, writeGeometryInViewProj(t) { return $c.methods.writeFeatureInViewProj.call(this, t); },
    }; const Ud = {
      mixins: [Wf, Bc, $c], props: Gd, computed: Vd, methods: Bd, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } },
    }; function zd() { const t = this; uo(this); const e = ml(this.$source, 'addfeature').pipe(Kl((e) => { const n = e.feature; t.addFeature(n); })); const n = ml(this.$source, 'removefeature').pipe(Kl((e) => { const n = e.feature; t.removeFeature(n); })); const i = ml(this.$source, 'changefeature'); const r = gl(e, n, i); this.subscribeTo(r, (e) => { ++t.rev, t.$emit(e.type, e); }), this.subscribeTo(r.pipe(jd(100)), () => { t.$emit('update:features', t.getFeatures().map(t.writeFeatureInDataProj.bind(t))); }); } const Yd = Ud; const Xd = { setFill(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._fill && (this._fill = t), this.$style && t !== this.$style.getFill() && (this.$style.setFill(t), this.scheduleRefresh()); }, setStroke(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._stroke && (this._stroke = t), this.$style && t !== this.$style.getStroke() && (this.$style.setStroke(t), this.scheduleRefresh()); } }; const Wd = { methods: Xd, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } }, created() { this._fill = void 0, this._stroke = void 0; } }; const Kd = Wd;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Hd(t, e) { return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]]; }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    const qd = n('5176'); const Zd = n.n(qd); const Jd = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i; const Qd = /^([a-z]*)$/i; function tv(t) { return typeof t === 'string' ? t : sv(t); } function ev(t) { const e = document.createElement('div'); if (e.style.color = t, e.style.color !== '') { document.body.appendChild(e); const n = getComputedStyle(e).color; return document.body.removeChild(e), n; } return ''; } const nv = (function () { const t = 1024; const e = {}; let n = 0; return function (i) { let r; if (e.hasOwnProperty(i))r = e[i]; else { if (n >= t) { let o = 0; for (const s in e)(3 & o++) === 0 && (delete e[s], --n); }r = rv(i), e[i] = r, ++n; } return r; }; }()); function iv(t) { return Array.isArray(t) ? t : nv(t); } function rv(t) { let e; let n; let i; let r; let o; if (Qd.exec(t) && (t = ev(t)), Jd.exec(t)) { let s; const a = t.length - 1; s = a <= 4 ? 1 : 2; const u = a === 4 || a === 8; e = parseInt(t.substr(1 + 0 * s, s), 16), n = parseInt(t.substr(1 + 1 * s, s), 16), i = parseInt(t.substr(1 + 2 * s, s), 16), r = u ? parseInt(t.substr(1 + 3 * s, s), 16) : 255, s == 1 && (e = (e << 4) + e, n = (n << 4) + n, i = (i << 4) + i, u && (r = (r << 4) + r)), o = [e, n, i, r / 255]; } else t.indexOf('rgba(') == 0 ? (o = t.slice(5, -1).split(',').map(Number), ov(o)) : t.indexOf('rgb(') == 0 ? (o = t.slice(4, -1).split(',').map(Number), o.push(1), ov(o)) : Q(!1, 14); return o; } function ov(t) { return t[0] = Vt(t[0] + 0.5 | 0, 0, 255), t[1] = Vt(t[1] + 0.5 | 0, 0, 255), t[2] = Vt(t[2] + 0.5 | 0, 0, 255), t[3] = Vt(t[3], 0, 1), t; } function sv(t) { let e = t[0]; e != (0 | e) && (e = e + 0.5 | 0); let n = t[1]; n != (0 | n) && (n = n + 0.5 | 0); let i = t[2]; i != (0 | i) && (i = i + 0.5 | 0); const r = void 0 === t[3] ? 1 : t[3]; return `rgba(${e},${n},${i},${r})`; } function av(t) { return Array.isArray(t) ? sv(t) : t; } const uv = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : ''; const cv = uv.indexOf('firefox') !== -1; const hv = uv.indexOf('safari') !== -1 && uv.indexOf('chrom') == -1; const lv = uv.indexOf('webkit') !== -1 && uv.indexOf('edge') == -1; const fv = uv.indexOf('macintosh') !== -1; const pv = window.devicePixelRatio || 1; const dv = (function () { let t = !1; try { t = !!document.createElement('canvas').getContext('2d').setLineDash; } catch (e) {} return t; }()); const vv = 'geolocation' in navigator; const gv = 'ontouchstart' in window; const yv = 'PointerEvent' in window; const mv = !!navigator.msPointerEnabled; const _v = {
      IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3,
    }; const bv = '10px sans-serif'; const wv = [0, 0, 0, 1]; const xv = 'round'; const Ev = []; const Sv = 0; const Tv = 'round'; const Ov = 10; const Cv = [0, 0, 0, 1]; const Rv = 'center'; const Iv = 'middle'; const Pv = [0, 0, 0, 0]; const Lv = 1; const Av = new Ye(); const Fv = {}; let jv = null; const kv = {}; const
      Mv = (function () { let t; let e; const n = 60; const i = Fv; const r = '32px '; const o = ['monospace', 'serif']; const s = o.length; const a = 'wmytzilWMYTZIL@#/&?$%10'; function u(t) { for (let n = Nv(), i = 100; i <= 700; i += 300) { for (var u = `${i} `, c = !0, h = 0; h < s; ++h) { const l = o[h]; if (n.font = u + r + l, e = n.measureText(a).width, t != l) { n.font = `${u + r + t},${l}`; const f = n.measureText(a).width; c = c && f != e; } } if (c) return !0; } return !1; } function c() { let e = !0; for (const r in i)i[r] < n && (u(r) ? (i[r] = n, Zt(kv), jv = null, Av.clear()) : (++i[r], e = !1)); e && (clearInterval(t), t = void 0); } return function (e) { const r = Xp(e); if (r) for (let o = 0, s = r.length; o < s; ++o) { const a = r[o]; a in i || (i[a] = n, u(a) || (i[a] = 0, void 0 === t && (t = setInterval(c, 32)))); } }; }()); function Nv() { return jv || (jv = ke(1, 1)), jv; } const Dv = (function () { let t; const e = kv; return function (n) { let i = e[n]; return void 0 == i && (t || (t = document.createElement('span'), t.textContent = 'M', t.style.margin = t.style.padding = '0 !important', t.style.position = 'absolute !important', t.style.left = '-99999px !important'), t.style.font = n, document.body.appendChild(t), i = e[n] = t.offsetHeight, document.body.removeChild(t)), i; }; }()); function $v(t, e) { const n = Nv(); return t != n.font && (n.font = t), n.measureText(e).width; } function Gv(t, e, n, i) { e !== 0 && (t.translate(n, i), t.rotate(e), t.translate(-n, -i)); } const Vv = Jo(); function Bv(t, e, n, i, r, o, s, a, u, c, h) { let l; n != 1 && (l = t.globalAlpha, t.globalAlpha = l * n), e && t.setTransform(...e), t.drawImage(i, r, o, s, a, u, c, s * h, a * h), l && (t.globalAlpha = l), e && t.setTransform(...Vv); } const Uv = function (t) { this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale; }; Uv.prototype.clone = function () {
      return new Uv({
        opacity: this.getOpacity(), scale: this.getScale(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(),
      });
    }, Uv.prototype.getOpacity = function () { return this.opacity_; }, Uv.prototype.getRotateWithView = function () { return this.rotateWithView_; }, Uv.prototype.getRotation = function () { return this.rotation_; }, Uv.prototype.getScale = function () { return this.scale_; }, Uv.prototype.getSnapToPixel = function () { return !1; }, Uv.prototype.getAnchor = function () { return W(); }, Uv.prototype.getImage = function (t) { return W(); }, Uv.prototype.getHitDetectionImage = function (t) { return W(); }, Uv.prototype.getImageState = function () { return W(); }, Uv.prototype.getImageSize = function () { return W(); }, Uv.prototype.getHitDetectionImageSize = function () { return W(); }, Uv.prototype.getOrigin = function () { return W(); }, Uv.prototype.getSize = function () { return W(); }, Uv.prototype.setOpacity = function (t) { this.opacity_ = t; }, Uv.prototype.setRotateWithView = function (t) { this.rotateWithView_ = t; }, Uv.prototype.setRotation = function (t) { this.rotation_ = t; }, Uv.prototype.setScale = function (t) { this.scale_ = t; }, Uv.prototype.setSnapToPixel = function (t) {}, Uv.prototype.listenImageChange = function (t, e) { return W(); }, Uv.prototype.load = function () { W(); }, Uv.prototype.unlistenImageChange = function (t, e) { W(); }; const zv = Uv; const Yv = (function (t) {
      function e(e) {
        const n = void 0 !== e.rotateWithView && e.rotateWithView; t.call(this, {
          opacity: 1, rotateWithView: n, rotation: void 0 !== e.rotation ? e.rotation : 0, scale: 1,
        }), this.checksums_ = null, this.canvas_ = null, this.hitDetectionCanvas_ = null, this.fill_ = void 0 !== e.fill ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = void 0 !== e.radius ? e.radius : e.radius1, this.radius2_ = e.radius2, this.angle_ = void 0 !== e.angle ? e.angle : 0, this.stroke_ = void 0 !== e.stroke ? e.stroke : null, this.anchor_ = null, this.size_ = null, this.imageSize_ = null, this.hitDetectionImageSize_ = null, this.atlasManager_ = e.atlasManager, this.render_(this.atlasManager_);
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () {
        const t = new e({
          fill: this.getFill() ? this.getFill().clone() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this.getRadius2(), angle: this.getAngle(), stroke: this.getStroke() ? this.getStroke().clone() : void 0, rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), atlasManager: this.atlasManager_,
        }); return t.setOpacity(this.getOpacity()), t.setScale(this.getScale()), t;
      }, e.prototype.getAnchor = function () { return this.anchor_; }, e.prototype.getAngle = function () { return this.angle_; }, e.prototype.getFill = function () { return this.fill_; }, e.prototype.getHitDetectionImage = function (t) { return this.hitDetectionCanvas_; }, e.prototype.getImage = function (t) { return this.canvas_; }, e.prototype.getImageSize = function () { return this.imageSize_; }, e.prototype.getHitDetectionImageSize = function () { return this.hitDetectionImageSize_; }, e.prototype.getImageState = function () { return _v.LOADED; }, e.prototype.getOrigin = function () { return this.origin_; }, e.prototype.getPoints = function () { return this.points_; }, e.prototype.getRadius = function () { return this.radius_; }, e.prototype.getRadius2 = function () { return this.radius2_; }, e.prototype.getSize = function () { return this.size_; }, e.prototype.getStroke = function () { return this.stroke_; }, e.prototype.listenImageChange = function (t, e) {}, e.prototype.load = function () {}, e.prototype.unlistenImageChange = function (t, e) {}, e.prototype.render_ = function (t) {
        let e; let n; let i = ''; let r = ''; let o = 0; let s = null; let a = 0; let u = 0; this.stroke_ && (n = this.stroke_.getColor(), n === null && (n = Cv), n = av(n), u = this.stroke_.getWidth(), void 0 === u && (u = Lv), s = this.stroke_.getLineDash(), a = this.stroke_.getLineDashOffset(), dv || (s = null, a = 0), r = this.stroke_.getLineJoin(), void 0 === r && (r = Tv), i = this.stroke_.getLineCap(), void 0 === i && (i = xv), o = this.stroke_.getMiterLimit(), void 0 === o && (o = Ov)); let c = 2 * (this.radius_ + u) + 1; const h = {
          strokeStyle: n, strokeWidth: u, size: c, lineCap: i, lineDash: s, lineDashOffset: a, lineJoin: r, miterLimit: o,
        }; if (void 0 === t) { const l = ke(c, c); this.canvas_ = l.canvas, c = this.canvas_.width, e = c, this.draw_(h, l, 0, 0), this.createHitDetectionCanvas_(h); } else { c = Math.round(c); let f; const p = !this.fill_; p && (f = this.drawHitDetectionCanvas_.bind(this, h)); const d = this.getChecksum(); const v = t.add(d, c, c, this.draw_.bind(this, h), f); this.canvas_ = v.image, this.origin_ = [v.offsetX, v.offsetY], e = v.image.width, p ? (this.hitDetectionCanvas_ = v.hitImage, this.hitDetectionImageSize_ = [v.hitImage.width, v.hitImage.height]) : (this.hitDetectionCanvas_ = this.canvas_, this.hitDetectionImageSize_ = [e, e]); } this.anchor_ = [c / 2, c / 2], this.size_ = [c, c], this.imageSize_ = [e, e];
      }, e.prototype.draw_ = function (t, e, n, i) { let r; let o; let s; e.setTransform(1, 0, 0, 1, 0, 0), e.translate(n, i), e.beginPath(); let a = this.points_; if (a === 1 / 0)e.arc(t.size / 2, t.size / 2, this.radius_, 0, 2 * Math.PI, !0); else { const u = void 0 !== this.radius2_ ? this.radius2_ : this.radius_; for (u !== this.radius_ && (a *= 2), r = 0; r <= a; r++)o = 2 * r * Math.PI / a - Math.PI / 2 + this.angle_, s = r % 2 === 0 ? this.radius_ : u, e.lineTo(t.size / 2 + s * Math.cos(o), t.size / 2 + s * Math.sin(o)); } if (this.fill_) { let c = this.fill_.getColor(); c === null && (c = wv), e.fillStyle = av(c), e.fill(); } this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke()), e.closePath(); }, e.prototype.createHitDetectionCanvas_ = function (t) { if (this.hitDetectionImageSize_ = [t.size, t.size], this.fill_) this.hitDetectionCanvas_ = this.canvas_; else { const e = ke(t.size, t.size); this.hitDetectionCanvas_ = e.canvas, this.drawHitDetectionCanvas_(t, e, 0, 0); } }, e.prototype.drawHitDetectionCanvas_ = function (t, e, n, i) { e.setTransform(1, 0, 0, 1, 0, 0), e.translate(n, i), e.beginPath(); let r = this.points_; if (r === 1 / 0)e.arc(t.size / 2, t.size / 2, this.radius_, 0, 2 * Math.PI, !0); else { let o; let s; let a; const u = void 0 !== this.radius2_ ? this.radius2_ : this.radius_; for (u !== this.radius_ && (r *= 2), o = 0; o <= r; o++)a = 2 * o * Math.PI / r - Math.PI / 2 + this.angle_, s = o % 2 === 0 ? this.radius_ : u, e.lineTo(t.size / 2 + s * Math.cos(a), t.size / 2 + s * Math.sin(a)); }e.fillStyle = tv(wv), e.fill(), this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.stroke()), e.closePath(); }, e.prototype.getChecksum = function () {
        const t = this.stroke_ ? this.stroke_.getChecksum() : '-'; const e = this.fill_ ? this.fill_.getChecksum() : '-'; const
          n = !this.checksums_ || t != this.checksums_[1] || e != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6]; if (n) { const i = `r${t}${e}${void 0 !== this.radius_ ? this.radius_.toString() : '-'}${void 0 !== this.radius2_ ? this.radius2_.toString() : '-'}${void 0 !== this.angle_ ? this.angle_.toString() : '-'}${void 0 !== this.points_ ? this.points_.toString() : '-'}`; this.checksums_ = [i, t, e, this.radius_, this.radius2_, this.angle_, this.points_]; } return this.checksums_[0];
      }, e;
    }(zv)); const Xv = Yv; const Wv = (function (t) {
      function e(e) {
        const n = e || {}; t.call(this, {
          points: 1 / 0, fill: n.fill, radius: n.radius, stroke: n.stroke, atlasManager: n.atlasManager,
        });
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () {
        const t = new e({
          fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, radius: this.getRadius(), atlasManager: this.atlasManager_,
        }); return t.setOpacity(this.getOpacity()), t.setScale(this.getScale()), t;
      }, e.prototype.setRadius = function (t) { this.radius_ = t, this.render_(this.atlasManager_); }, e;
    }(Xv)); const Kv = Wv; const Hv = function (t) { const e = t || {}; this.color_ = void 0 !== e.color ? e.color : null, this.checksum_ = void 0; }; Hv.prototype.clone = function () { const t = this.getColor(); return new Hv({ color: Array.isArray(t) ? t.slice() : t || void 0 }); }, Hv.prototype.getColor = function () { return this.color_; }, Hv.prototype.setColor = function (t) { this.color_ = t, this.checksum_ = void 0; }, Hv.prototype.getChecksum = function () { if (void 0 === this.checksum_) { const t = this.color_; t ? Array.isArray(t) || typeof t === 'string' ? this.checksum_ = `f${tv(t)}` : this.checksum_ = H(this.color_) : this.checksum_ = 'f-'; } return this.checksum_; }; const qv = Hv; const Zv = { FRACTION: 'fraction', PIXELS: 'pixels' }; const Jv = function () { this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32; }; function Qv(t, e, n) { const i = n ? tv(n) : 'null'; return `${e}:${t}:${i}`; }Jv.prototype.clear = function () { this.cache_ = {}, this.cacheSize_ = 0; }, Jv.prototype.expire = function () { if (this.cacheSize_ > this.maxCacheSize_) { let t = 0; for (const e in this.cache_) { const n = this.cache_[e]; (3 & t++) !== 0 || n.hasListener() || (delete this.cache_[e], --this.cacheSize_); } } }, Jv.prototype.get = function (t, e, n) { const i = Qv(t, e, n); return i in this.cache_ ? this.cache_[i] : null; }, Jv.prototype.set = function (t, e, n, i) { const r = Qv(t, e, n); this.cache_[r] = i, ++this.cacheSize_; }, Jv.prototype.setSize = function (t) { this.maxCacheSize_ = t, this.expire(); }; const tg = new Jv(); const
      eg = (function (t) { function e(e, n, i, r, o, s) { t.call(this), this.hitDetectionImage_ = null, this.image_ = e || new Image(), r !== null && (this.image_.crossOrigin = r), this.canvas_ = s ? document.createElement('canvas') : null, this.color_ = s, this.imageListenerKeys_ = null, this.imageState_ = o, this.size_ = i, this.src_ = n, this.tainted_; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isTainted_ = function () { if (void 0 === this.tainted_ && this.imageState_ === _v.LOADED) { this.tainted_ = !1; const t = ke(1, 1); try { t.drawImage(this.image_, 0, 0), t.getImageData(0, 0, 1, 1); } catch (e) { this.tainted_ = !0; } } return !0 === this.tainted_; }, e.prototype.dispatchChangeEvent_ = function () { this.dispatchEvent(Ae.CHANGE); }, e.prototype.handleImageError_ = function () { this.imageState_ = _v.ERROR, this.unlistenImage_(), this.dispatchChangeEvent_(); }, e.prototype.handleImageLoad_ = function () { this.imageState_ = _v.LOADED, this.size_ && (this.image_.width = this.size_[0], this.image_.height = this.size_[1]), this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.replaceColor_(), this.dispatchChangeEvent_(); }, e.prototype.getImage = function (t) { return this.canvas_ ? this.canvas_ : this.image_; }, e.prototype.getImageState = function () { return this.imageState_; }, e.prototype.getHitDetectionImage = function (t) { if (!this.hitDetectionImage_) if (this.isTainted_()) { const e = this.size_[0]; const n = this.size_[1]; const i = ke(e, n); i.fillRect(0, 0, e, n), this.hitDetectionImage_ = i.canvas; } else this.hitDetectionImage_ = this.image_; return this.hitDetectionImage_; }, e.prototype.getSize = function () { return this.size_; }, e.prototype.getSrc = function () { return this.src_; }, e.prototype.load = function () { if (this.imageState_ == _v.IDLE) { this.imageState_ = _v.LOADING, this.imageListenerKeys_ = [be(this.image_, Ae.ERROR, this.handleImageError_, this), be(this.image_, Ae.LOAD, this.handleImageLoad_, this)]; try { this.image_.src = this.src_; } catch (t) { this.handleImageError_(); } } }, e.prototype.replaceColor_ = function () { if (this.color_ && !this.isTainted_()) { this.canvas_.width = this.image_.width, this.canvas_.height = this.image_.height; const t = this.canvas_.getContext('2d'); t.drawImage(this.image_, 0, 0); for (var e = t.getImageData(0, 0, this.image_.width, this.image_.height), n = e.data, i = this.color_[0] / 255, r = this.color_[1] / 255, o = this.color_[2] / 255, s = 0, a = n.length; s < a; s += 4)n[s] *= i, n[s + 1] *= r, n[s + 2] *= o; t.putImageData(e, 0, 0); } }, e.prototype.unlistenImage_ = function () { this.imageListenerKeys_.forEach(xe), this.imageListenerKeys_ = null; }, e; }(Le)); function ng(t, e, n, i, r, o) { let s = tg.get(e, i, o); return s || (s = new eg(t, e, n, i, r, o), tg.set(e, i, o, s)), s; } const ig = {
      BOTTOM_LEFT: 'bottom-left', BOTTOM_RIGHT: 'bottom-right', TOP_LEFT: 'top-left', TOP_RIGHT: 'top-right',
    }; const rg = (function (t) {
      function e(e) {
        const n = e || {}; const i = void 0 !== n.opacity ? n.opacity : 1; const r = void 0 !== n.rotation ? n.rotation : 0; const o = void 0 !== n.scale ? n.scale : 1; const s = void 0 !== n.rotateWithView && n.rotateWithView; t.call(this, {
          opacity: i, rotation: r, scale: o, rotateWithView: s,
        }), this.anchor_ = void 0 !== n.anchor ? n.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = void 0 !== n.anchorOrigin ? n.anchorOrigin : ig.TOP_LEFT, this.anchorXUnits_ = void 0 !== n.anchorXUnits ? n.anchorXUnits : Zv.FRACTION, this.anchorYUnits_ = void 0 !== n.anchorYUnits ? n.anchorYUnits : Zv.FRACTION, this.crossOrigin_ = void 0 !== n.crossOrigin ? n.crossOrigin : null; const a = void 0 !== n.img ? n.img : null; const u = void 0 !== n.imgSize ? n.imgSize : null; let c = n.src; Q(!(void 0 !== c && a), 4), Q(!a || a && u, 5), void 0 !== c && c.length !== 0 || !a || (c = a.src || H(a)), Q(void 0 !== c && c.length > 0, 6); const h = void 0 !== n.src ? _v.IDLE : _v.LOADED; this.color_ = void 0 !== n.color ? iv(n.color) : null, this.iconImage_ = ng(a, c, u, this.crossOrigin_, h, this.color_), this.offset_ = void 0 !== n.offset ? n.offset : [0, 0], this.offsetOrigin_ = void 0 !== n.offsetOrigin ? n.offsetOrigin : ig.TOP_LEFT, this.origin_ = null, this.size_ = void 0 !== n.size ? n.size : null;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clone = function () {
        return new e({
          anchor: this.anchor_.slice(), anchorOrigin: this.anchorOrigin_, anchorXUnits: this.anchorXUnits_, anchorYUnits: this.anchorYUnits_, crossOrigin: this.crossOrigin_, color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0, src: this.getSrc(), offset: this.offset_.slice(), offsetOrigin: this.offsetOrigin_, size: this.size_ !== null ? this.size_.slice() : void 0, opacity: this.getOpacity(), scale: this.getScale(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(),
        });
      }, e.prototype.getAnchor = function () { if (this.normalizedAnchor_) return this.normalizedAnchor_; let t = this.anchor_; const e = this.getSize(); if (this.anchorXUnits_ == Zv.FRACTION || this.anchorYUnits_ == Zv.FRACTION) { if (!e) return null; t = this.anchor_.slice(), this.anchorXUnits_ == Zv.FRACTION && (t[0] *= e[0]), this.anchorYUnits_ == Zv.FRACTION && (t[1] *= e[1]); } if (this.anchorOrigin_ != ig.TOP_LEFT) { if (!e) return null; t === this.anchor_ && (t = this.anchor_.slice()), this.anchorOrigin_ != ig.TOP_RIGHT && this.anchorOrigin_ != ig.BOTTOM_RIGHT || (t[0] = -t[0] + e[0]), this.anchorOrigin_ != ig.BOTTOM_LEFT && this.anchorOrigin_ != ig.BOTTOM_RIGHT || (t[1] = -t[1] + e[1]); } return this.normalizedAnchor_ = t, this.normalizedAnchor_; }, e.prototype.setAnchor = function (t) { this.anchor_ = t, this.normalizedAnchor_ = null; }, e.prototype.getColor = function () { return this.color_; }, e.prototype.getImage = function (t) { return this.iconImage_.getImage(t); }, e.prototype.getImageSize = function () { return this.iconImage_.getSize(); }, e.prototype.getHitDetectionImageSize = function () { return this.getImageSize(); }, e.prototype.getImageState = function () { return this.iconImage_.getImageState(); }, e.prototype.getHitDetectionImage = function (t) { return this.iconImage_.getHitDetectionImage(t); }, e.prototype.getOrigin = function () { if (this.origin_) return this.origin_; let t = this.offset_; if (this.offsetOrigin_ != ig.TOP_LEFT) { const e = this.getSize(); const n = this.iconImage_.getSize(); if (!e || !n) return null; t = t.slice(), this.offsetOrigin_ != ig.TOP_RIGHT && this.offsetOrigin_ != ig.BOTTOM_RIGHT || (t[0] = n[0] - e[0] - t[0]), this.offsetOrigin_ != ig.BOTTOM_LEFT && this.offsetOrigin_ != ig.BOTTOM_RIGHT || (t[1] = n[1] - e[1] - t[1]); } return this.origin_ = t, this.origin_; }, e.prototype.getSrc = function () { return this.iconImage_.getSrc(); }, e.prototype.getSize = function () { return this.size_ ? this.size_ : this.iconImage_.getSize(); }, e.prototype.listenImageChange = function (t, e) { return _e(this.iconImage_, Ae.CHANGE, t, e); }, e.prototype.load = function () { this.iconImage_.load(); }, e.prototype.unlistenImageChange = function (t, e) { we(this.iconImage_, Ae.CHANGE, t, e); }, e;
    }(zv)); const og = rg; const sg = function (t) { const e = t || {}; this.color_ = void 0 !== e.color ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = void 0 !== e.lineDash ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width, this.checksum_ = void 0; }; sg.prototype.clone = function () {
      const t = this.getColor(); return new sg({
        color: Array.isArray(t) ? t.slice() : t || void 0, lineCap: this.getLineCap(), lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this.getLineJoin(), miterLimit: this.getMiterLimit(), width: this.getWidth(),
      });
    }, sg.prototype.getColor = function () { return this.color_; }, sg.prototype.getLineCap = function () { return this.lineCap_; }, sg.prototype.getLineDash = function () { return this.lineDash_; }, sg.prototype.getLineDashOffset = function () { return this.lineDashOffset_; }, sg.prototype.getLineJoin = function () { return this.lineJoin_; }, sg.prototype.getMiterLimit = function () { return this.miterLimit_; }, sg.prototype.getWidth = function () { return this.width_; }, sg.prototype.setColor = function (t) { this.color_ = t, this.checksum_ = void 0; }, sg.prototype.setLineCap = function (t) { this.lineCap_ = t, this.checksum_ = void 0; }, sg.prototype.setLineDash = function (t) { this.lineDash_ = t, this.checksum_ = void 0; }, sg.prototype.setLineDashOffset = function (t) { this.lineDashOffset_ = t, this.checksum_ = void 0; }, sg.prototype.setLineJoin = function (t) { this.lineJoin_ = t, this.checksum_ = void 0; }, sg.prototype.setMiterLimit = function (t) { this.miterLimit_ = t, this.checksum_ = void 0; }, sg.prototype.setWidth = function (t) { this.width_ = t, this.checksum_ = void 0; }, sg.prototype.getChecksum = function () { return void 0 === this.checksum_ && (this.checksum_ = 's', this.color_ ? typeof this.color_ === 'string' ? this.checksum_ += this.color_ : this.checksum_ += H(this.color_) : this.checksum_ += '-', this.checksum_ += `,${void 0 !== this.lineCap_ ? this.lineCap_.toString() : '-'},${this.lineDash_ ? this.lineDash_.toString() : '-'},${void 0 !== this.lineDashOffset_ ? this.lineDashOffset_ : '-'},${void 0 !== this.lineJoin_ ? this.lineJoin_ : '-'},${void 0 !== this.miterLimit_ ? this.miterLimit_.toString() : '-'},${void 0 !== this.width_ ? this.width_.toString() : '-'}`), this.checksum_; }; const ag = sg; const ug = function (t) { const e = t || {}; this.geometry_ = null, this.geometryFunction_ = pg, void 0 !== e.geometry && this.setGeometry(e.geometry), this.fill_ = void 0 !== e.fill ? e.fill : null, this.image_ = void 0 !== e.image ? e.image : null, this.renderer_ = void 0 !== e.renderer ? e.renderer : null, this.stroke_ = void 0 !== e.stroke ? e.stroke : null, this.text_ = void 0 !== e.text ? e.text : null, this.zIndex_ = e.zIndex; }; function cg(t) { let e; if (typeof t === 'function')e = t; else { let n; if (Array.isArray(t))n = t; else { Q(typeof t.getZIndex === 'function', 41); const i = t; n = [i]; }e = function () { return n; }; } return e; }ug.prototype.clone = function () {
      let t = this.getGeometry(); return t && typeof t === 'object' && (t = t.clone()), new ug({
        geometry: t, fill: this.getFill() ? this.getFill().clone() : void 0, image: this.getImage() ? this.getImage().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex(),
      });
    }, ug.prototype.getRenderer = function () { return this.renderer_; }, ug.prototype.setRenderer = function (t) { this.renderer_ = t; }, ug.prototype.getGeometry = function () { return this.geometry_; }, ug.prototype.getGeometryFunction = function () { return this.geometryFunction_; }, ug.prototype.getFill = function () { return this.fill_; }, ug.prototype.setFill = function (t) { this.fill_ = t; }, ug.prototype.getImage = function () { return this.image_; }, ug.prototype.setImage = function (t) { this.image_ = t; }, ug.prototype.getStroke = function () { return this.stroke_; }, ug.prototype.setStroke = function (t) { this.stroke_ = t; }, ug.prototype.getText = function () { return this.text_; }, ug.prototype.setText = function (t) { this.text_ = t; }, ug.prototype.getZIndex = function () { return this.zIndex_; }, ug.prototype.setGeometry = function (t) { typeof t === 'function' ? this.geometryFunction_ = t : typeof t === 'string' ? this.geometryFunction_ = function (e) { return e.get(t); } : t ? void 0 !== t && (this.geometryFunction_ = function () { return t; }) : this.geometryFunction_ = pg, this.geometry_ = t; }, ug.prototype.setZIndex = function (t) { this.zIndex_ = t; }; let hg = null; function lg(t, e) { if (!hg) { const n = new qv({ color: 'rgba(255,255,255,0.4)' }); const i = new ag({ color: '#3399CC', width: 1.25 }); hg = [new ug({ image: new Kv({ fill: n, stroke: i, radius: 5 }), fill: n, stroke: i })]; } return hg; } function fg() { const t = {}; const e = [255, 255, 255, 1]; const n = [0, 153, 255, 1]; const i = 3; return t[en.POLYGON] = [new ug({ fill: new qv({ color: [255, 255, 255, 0.5] }) })], t[en.MULTI_POLYGON] = t[en.POLYGON], t[en.LINE_STRING] = [new ug({ stroke: new ag({ color: e, width: i + 2 }) }), new ug({ stroke: new ag({ color: n, width: i }) })], t[en.MULTI_LINE_STRING] = t[en.LINE_STRING], t[en.CIRCLE] = t[en.POLYGON].concat(t[en.LINE_STRING]), t[en.POINT] = [new ug({ image: new Kv({ radius: 2 * i, fill: new qv({ color: n }), stroke: new ag({ color: e, width: i / 2 }) }), zIndex: 1 / 0 })], t[en.MULTI_POINT] = t[en.POINT], t[en.GEOMETRY_COLLECTION] = t[en.POLYGON].concat(t[en.LINE_STRING], t[en.POINT]), t; } function pg(t) { return t.getGeometry(); } const dg = ug; const vg = { POINT: 'point', LINE: 'line' }; const gg = '#333'; const yg = function (t) { const e = t || {}; this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.text_ = e.text, this.textAlign_ = e.textAlign, this.textBaseline_ = e.textBaseline, this.fill_ = void 0 !== e.fill ? e.fill : new qv({ color: gg }), this.maxAngle_ = void 0 !== e.maxAngle ? e.maxAngle : Math.PI / 4, this.placement_ = void 0 !== e.placement ? e.placement : vg.POINT, this.overflow_ = !!e.overflow, this.stroke_ = void 0 !== e.stroke ? e.stroke : null, this.offsetX_ = void 0 !== e.offsetX ? e.offsetX : 0, this.offsetY_ = void 0 !== e.offsetY ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = void 0 === e.padding ? null : e.padding; }; yg.prototype.clone = function () {
      return new yg({
        font: this.getFont(), placement: this.getPlacement(), maxAngle: this.getMaxAngle(), overflow: this.getOverflow(), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), scale: this.getScale(), text: this.getText(), textAlign: this.getTextAlign(), textBaseline: this.getTextBaseline(), fill: this.getFill() ? this.getFill().clone() : void 0, stroke: this.getStroke() ? this.getStroke().clone() : void 0, offsetX: this.getOffsetX(), offsetY: this.getOffsetY(), backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0, backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      });
    }, yg.prototype.getOverflow = function () { return this.overflow_; }, yg.prototype.getFont = function () { return this.font_; }, yg.prototype.getMaxAngle = function () { return this.maxAngle_; }, yg.prototype.getPlacement = function () { return this.placement_; }, yg.prototype.getOffsetX = function () { return this.offsetX_; }, yg.prototype.getOffsetY = function () { return this.offsetY_; }, yg.prototype.getFill = function () { return this.fill_; }, yg.prototype.getRotateWithView = function () { return this.rotateWithView_; }, yg.prototype.getRotation = function () { return this.rotation_; }, yg.prototype.getScale = function () { return this.scale_; }, yg.prototype.getStroke = function () { return this.stroke_; }, yg.prototype.getText = function () { return this.text_; }, yg.prototype.getTextAlign = function () { return this.textAlign_; }, yg.prototype.getTextBaseline = function () { return this.textBaseline_; }, yg.prototype.getBackgroundFill = function () { return this.backgroundFill_; }, yg.prototype.getBackgroundStroke = function () { return this.backgroundStroke_; }, yg.prototype.getPadding = function () { return this.padding_; }, yg.prototype.setOverflow = function (t) { this.overflow_ = t; }, yg.prototype.setFont = function (t) { this.font_ = t; }, yg.prototype.setMaxAngle = function (t) { this.maxAngle_ = t; }, yg.prototype.setOffsetX = function (t) { this.offsetX_ = t; }, yg.prototype.setOffsetY = function (t) { this.offsetY_ = t; }, yg.prototype.setPlacement = function (t) { this.placement_ = t; }, yg.prototype.setFill = function (t) { this.fill_ = t; }, yg.prototype.setRotation = function (t) { this.rotation_ = t; }, yg.prototype.setScale = function (t) { this.scale_ = t; }, yg.prototype.setStroke = function (t) { this.stroke_ = t; }, yg.prototype.setText = function (t) { this.text_ = t; }, yg.prototype.setTextAlign = function (t) { this.textAlign_ = t; }, yg.prototype.setTextBaseline = function (t) { this.textBaseline_ = t; }, yg.prototype.setBackgroundFill = function (t) { this.backgroundFill_ = t; }, yg.prototype.setBackgroundStroke = function (t) { this.backgroundStroke_ = t; }, yg.prototype.setPadding = function (t) { this.padding_ = t; }; const mg = yg; const _g = n('48da'); const bg = n.n(_g); function wg() {
      const t = {}; const e = [255, 255, 255, 1]; const n = [0, 153, 255, 1]; const i = 3; return t[To.LINE_STRING] = [{ strokeColor: e, strokeWidth: i + 2 }, { strokeColor: n, strokeWidth: i }], t[To.MULTI_LINE_STRING] = t[To.LINE_STRING], t[To.POLYGON] = [{ fillColor: [255, 255, 255, 0.5] }].concat(t[To.LINE_STRING]), t[To.MULTI_POLYGON] = t[To.POLYGON], t[To.CIRCLE] = t[To.POLYGON].concat(t[To.LINE_STRING]), t[To.POINT] = [{
        imageRadius: 2 * i, fillColor: n, strokeColor: e, strokeWidth: i / 2, zIndex: 1 / 0,
      }], t[To.MULTI_POINT] = t[To.POINT], t[To.GEOMETRY_COLLECTION] = t[To.POLYGON].concat(t[To.LINE_STRING], t[To.POINT]), t;
    } const xg = function (t) { return t == null || typeof t !== 'number' && ((typeof t === 'string' || Fo()(t)) && !t.length || !ur()(t).length); }; function Eg(t) {
      if (!xg(t)) {
        const e = {
          text: Ig(t), fill: Og(t), stroke: Cg(t), image: Rg(t), geometry: Pg(t), zIndex: t.zIndex,
        }; return xg(e) ? void 0 : new dg(e);
      }
    } const Sg = function (t) { return function (e) { return t + (t ? Object(gr.A)(e) : e); }; }; function Tg(t) { let e = t; return typeof t === 'string' && (e = bg()(t).rgba), e; } function Og(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''; const n = Sg(e); const i = ['fillColor'].map(n); const
        r = n('fill'); if (t[r] instanceof qv) return t[r]; const o = Object(gr.x)(t, (t, e, r) => (!1 === i.includes(r) ? t : (r = Object(gr.q)(r.replace(new RegExp(n('fill')), '')), r === 'color' && (e = Tg(e)), t[r] = e, t)), {}); return xg(o) ? void 0 : new qv(o);
    } function Cg(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''; const n = Sg(e); const i = ['strokeColor', 'strokeWidth', 'strokeDash', 'strokeCap', 'strokeJoin'].map(n); const
        r = n('stroke'); if (t[r] instanceof ag) return t[r]; const o = Object(gr.x)(t, (t, e, r) => { if (!1 === i.includes(r)) return t; switch (r) { case n('strokeColor'): case n('strokeWidth'): r = Object(gr.q)(r.replace(new RegExp(n('stroke')), '')); break; case n('strokeDash'): case n('strokeCap'): case n('strokeJoin'): r = `line${r.replace(new RegExp(n('stroke')), '')}`; break; } return r === 'color' && (e = Tg(e)), t[r] = e, t; }, {}); return xg(o) ? void 0 : new ag(o);
    } function Rg(t) {
      let e; let n; if (!(xg(t.imageSrc) && xg(t.image) && xg(t.imagePoints)) || Object(gr.n)(t.imageRadius)) {
        return t.image instanceof zv ? t.image : (xg(t.imageSrc) && xg(t.image) ? t.imagePoints != null ? (n = Xv, e = fr({}, t, {
          points: t.imagePoints, radius: t.imageRadius, radius1: t.imageRadius1, radius2: t.imageRadius2, angle: t.imageAngle, rotation: t.imageRotation,
        })) : (n = Kv, e = fr({}, t, { radius: t.imageRadius })) : (n = og, e = fr({}, t, {
          anchor: t.imageAnchor, anchorOrigin: t.imageAnchorOrigin, color: t.imageColor, offset: t.imageOffset, offsetOrigin: t.imageOffsetOrigin, opacity: t.imageOpacity, scale: t.imageScale, rotation: t.imageRotation, size: t.imageSize, img: t.image, imgSize: t.imageImgSize, src: t.imageSrc, crossOrigin: t.imageCrossOrigin,
        })), e = fr({}, e, { fill: Og(t, 'image') || Og(t), stroke: Cg(t, 'image') || Cg(t), snapToPixel: !0 }), xg(e) ? void 0 : new n(e));
      }
    } function Ig(t) {
      if (t.text != null) {
        if (t.text instanceof mg) return t.text; const e = { text: t.text }; const n = t.textFontSize ? `${t.textFontSize}px` : void 0; const i = ['normal', n, t.textFont].filter(t => !!t).join(' '); return Zd()(e, Object(gr.u)(['textAlign', 'textBaseline'], t), {
          font: i, fill: Og(t, 'text') || Og(t), stroke: Cg(t, 'text') || Cg(t), scale: t.textScale, rotation: t.textRotation, offsetX: t.textOffsetX, offsetY: t.textOffsetY, rotateWithView: t.textRotateWithView, padding: t.textPadding, maxAngle: t.textMaxAngle, overflow: t.textOverflow, placement: t.textPlacement, backgroundFill: Og(t, 'textBackground'), backgroundStroke: Cg(t, 'textBackground'),
        }), xg(e) ? void 0 : new mg(e);
      }
    } function Pg(t) { return Object(gr.l)(t.geom) ? function (e) { return t.geom(e, i); } : t.geom; }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const Lg = function (t) { return Object(gr.x)(t, (t, e, n) => { const i = ['LAYERS', 'VERSION', 'STYLES', 'FORMAT', 'TRANSPARENT', 'BGCOLOR', 'TIME']; return n = n.toUpperCase(), i.includes(n) ? t : (t[n] = e, t); }, {}); }; const Ag = {
      extParams: Object, layers: { type: String, required: !0 }, styles: String, version: { type: String, default: Ro }, transparent: { type: Boolean, default: !0 }, format: { type: String, default: 'image/png' }, bgColor: String, time: String,
    }; const Fg = {
      cleanExtParams() { return this.extParams ? Lg(this.extParams) : void 0; },
      allParams() {
        return fr({}, this.cleanExtParams, {
          LAYERS: this.layers, STYLES: this.styles, VERSION: this.version, FORMAT: this.format, TRANSPARENT: this.transparent, BGCOLOR: this.bgColor, TIME: this.time,
        });
      },
    }; const jg = { getFeatureInfoUrl(t, e, n) { let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return ro(this), uo(this), e || (e = this.$view.getResolution()), n || (n = this.projection), i = fr({}, this.allParams, i), this.$source.getGetFeatureInfoUrl(t, e, n, i); } }; const kg = {
      layers(t) { this.$source && this.$source.updateParams({ LAYERS: t }); }, version(t) { this.$source && this.$source.updateParams({ VERSION: t }); }, styles(t) { this.$source && this.$source.updateParams({ STYLES: t }); }, transparent(t) { this.$source && this.$source.updateParams({ TRANSPARENT: t }); }, time(t) { this.$source && this.$source.updateParams({ TIME: t }); }, bgColor(t) { this.$source && this.$source.updateParams({ BGCOLOR: t }); }, extParams(t) { this.$source && this.$source.updateParams(t ? Lg(t) : void 0); },
    }; const Mg = {
      props: Ag, computed: Fg, methods: jg, watch: kg,
    }; const Ng = Mg; const Dg = (function (t) {
      function e(e) {
        const n = e || {}; const i = void 0 !== n.projection ? n.projection : 'EPSG:3857'; const r = void 0 !== n.tileGrid ? n.tileGrid : Gi({
          extent: Ui(i), maxZoom: n.maxZoom, minZoom: n.minZoom, tileSize: n.tileSize,
        }); t.call(this, {
          attributions: n.attributions, cacheSize: n.cacheSize, crossOrigin: n.crossOrigin, opaque: n.opaque, projection: i, reprojectionErrorThreshold: n.reprojectionErrorThreshold, tileGrid: r, tileLoadFunction: n.tileLoadFunction, tilePixelRatio: n.tilePixelRatio, tileUrlFunction: n.tileUrlFunction, url: n.url, urls: n.urls, wrapX: void 0 === n.wrapX || n.wrapX, transition: n.transition, attributionsCollapsible: n.attributionsCollapsible,
        });
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
    }(Ji)); const $g = Dg; const Gg = {
      createSource() {
        return new $g({
          attributions: this.attributions, cacheSize: this.cacheSize, crossOrigin: this.crossOrigin, maxZoom: this.maxZoom, minZoom: this.minZoom, opaque: this.opaque, projection: this.projection, reprojectionErrorThreshold: this.reprojectionErrorThreshold, tileGrid: this._tileGrid, tilePixelRatio: this.tilePixelRatio, tileUrlFunction: this.createUrlFunc(), tileLoadFunction: this.tileLoadFunction, wrapX: this.wrapX, transition: this.transition,
        });
      },
    }; const Vg = {}; const Bg = { mixins: [Id], methods: Gg, watch: Vg }; const Ug = Bg; const zg = { url: { type: String, required: !0, validator(t) { return !!t.length; } } }; const Yg = {
      createSource() {
        return new nr({
          attributions: this.attributions, cacheSize: this.cacheSize, crossOrigin: this.crossOrigin, params: this.allParams, logo: this.logo, tileGrid: this._tileGrid, projection: this.projection, reprojectionErrorThreshold: this.reprojectionErrorThreshold, tileLoadFunction: this.tileLoadFunction, url: this.urlTmpl, wrapX: this.wrapX, transition: this.transition,
        });
      },
    }; const Xg = {
      name: 'vl-source-arcgis-rest', mixins: [Id, Sr], props: zg, methods: Yg,
    }; const Wg = Xg; const Kg = void 0; const Hg = void 0; const qg = void 0; const Zg = void 0; function Jg(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Qg = Jg({}, Kg, Wg, Hg, Zg, qg, void 0, void 0); function ty(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; ty.installed || (ty.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Qg, e), t.component(Qg.name, Qg)); } var ey = ty; function ny(t, e, n, i) { const r = document.createElement('script'); const o = `olc_${H(e)}`; function s() { delete window[o], r.parentNode.removeChild(r); }r.async = !0, r.src = `${t + (t.indexOf('?') == -1 ? '?' : '&') + (i || 'callback')}=${o}`; const a = setTimeout(() => { s(), n && n(); }, 1e4); window[o] = function (t) { clearTimeout(a), s(), e(t); }, document.getElementsByTagName('head')[0].appendChild(r); } const iy = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html">Terms of Use</a>'; const ry = (function (t) {
      function e(e) {
        const n = void 0 !== e.hidpi && e.hidpi; t.call(this, {
          cacheSize: e.cacheSize, crossOrigin: 'anonymous', opaque: !0, projection: jn('EPSG:3857'), reprojectionErrorThreshold: e.reprojectionErrorThreshold, state: vi.LOADING, tileLoadFunction: e.tileLoadFunction, tilePixelRatio: n ? 2 : 1, wrapX: void 0 === e.wrapX || e.wrapX, transition: e.transition,
        }), this.hidpi_ = n, this.culture_ = void 0 !== e.culture ? e.culture : 'en-us', this.maxZoom_ = void 0 !== e.maxZoom ? e.maxZoom : -1, this.apiKey_ = e.key, this.imagerySet_ = e.imagerySet; const i = `https://dev.virtualearth.net/REST/v1/Imagery/Metadata/${this.imagerySet_}?uriScheme=https&include=ImageryProviders&key=${this.apiKey_}&c=${this.culture_}`; ny(i, this.handleImageryMetadataResponse.bind(this), void 0, 'jsonp');
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getApiKey = function () { return this.apiKey_; }, e.prototype.getImagerySet = function () { return this.imagerySet_; }, e.prototype.handleImageryMetadataResponse = function (t) {
        if (t.statusCode == 200 && t.statusDescription == 'OK' && t.authenticationResultCode == 'ValidCredentials' && t.resourceSets.length == 1 && t.resourceSets[0].resources.length == 1) {
          const e = t.resourceSets[0].resources[0]; const n = this.maxZoom_ == -1 ? e.zoomMax : this.maxZoom_; const i = this.getProjection(); const r = Ui(i); const o = this.hidpi_ ? 2 : 1; const s = e.imageWidth == e.imageHeight ? e.imageWidth / o : [e.imageWidth / o, e.imageHeight / o]; const a = Gi({
            extent: r, minZoom: e.zoomMin, maxZoom: n, tileSize: s,
          }); this.tileGrid = a; const u = this.culture_; const c = this.hidpi_; if (this.tileUrlFunction = ri(e.imageUrlSubdomains.map((t) => { const n = [0, 0, 0]; const i = e.imageUrl.replace('{subdomain}', t).replace('{culture}', u); return function (t, e, r) { if (t) { Xe(t[0], t[1], -t[2] - 1, n); let o = i; return c && (o += '&dpi=d1&device=mobile'), o.replace('{quadkey}', Ze(n)); } }; })), e.imageryProviders) { const h = Bn(jn('EPSG:4326'), this.getProjection()); this.setAttributions((t) => { const n = []; const i = t.viewState; const r = this.getTileGrid(); const o = r.getTileCoordForCoordAndResolution(i.center, i.resolution); const s = o[0]; return e.imageryProviders.map((e) => { for (var i = !1, r = e.coverageAreas, o = 0, a = r.length; o < a; ++o) { const u = r[o]; if (s >= u.zoomMin && s <= u.zoomMax) { const c = u.bbox; const l = [c[1], c[0], c[3], c[2]]; const f = Gt(l, h); if (kt(f, t.extent)) { i = !0; break; } } }i && n.push(e.attribution); }), n.push(iy), n; }); } this.setState(vi.READY);
        } else this.setState(vi.ERROR);
      }, e;
    }(Ji)); const oy = ry; const sy = 21; const ay = 'en-us'; const uy = {
      hidpi: { type: Boolean, default: !1 }, culture: { type: String, default: ay }, apiKey: { type: String, required: !0 }, imagerySet: { type: String, required: !0 }, maxZoom: { type: Number, default: sy }, url: String,
    }; const cy = {
      createSource() {
        return new oy({
          cacheSize: this.cacheSize, hidpi: this.hidpi, culture: this.culture, key: this.apiKey, imagerySet: this.imagerySet, maxZoom: this.maxZoom, reprojectionErrorThreshold: this.reprojectionErrorThreshold, wrapX: this.wrapX, transition: this.transition, tileLoadFunction: this.tileLoadFunction,
        });
      },
    }; const hy = Sf(['apiKey', 'imagerySet'], () => function () { this.scheduleRecreate(); }); const ly = {
      name: 'vl-source-bingmaps', mixins: [Id], props: uy, methods: cy, watch: hy,
    }; const fy = ly; const py = void 0; const dy = void 0; const vy = void 0; const gy = void 0; function yy(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var my = yy({}, py, fy, dy, gy, vy, void 0, void 0); function _y(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; _y.installed || (_y.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(my, e), t.component(my.name, my)); } var by = _y; const wy = { coordinates: { type: Array, required: !0, validator(t) { return t.length === 2; } }, radius: { type: Number, default: 0 } }; const xy = { type: Object(gr.c)(To.POINT), coordinatesViewProj() { if (this.rev && this.$geometry) return this.$geometry.getCenter(); } }; const Ey = { createGeometry() { return new Hu(this.toViewProj(this.coordinates), this.radius); }, getCoordinates() { return co(this), this.toDataProj(this.$geometry.getCenter()); }, setCoordinates(t) { co(this), this.$geometry.setCenter(this.toViewProj(t)); } }; const Sy = { radius(t) { this.$geometry && t !== this.$geometry.getRadius() && this.$geometry.setRadius(t); } }; const Ty = {
      name: 'vl-geom-circle', mixins: [$f], props: wy, computed: xy, methods: Ey, watch: Sy,
    }; const Oy = Ty; const Cy = void 0; const Ry = void 0; const Iy = void 0; const Py = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Ly(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Ay = Ly({}, Cy, Oy, Ry, Py, Iy, void 0, void 0); function Fy(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Fy.installed || (Fy.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Ay, e), t.component(Ay.name, Ay)); } var jy = Fy; const ky = { radius: { type: Number, default: 5 } }; const My = {
      createStyle() { return new Kv({ radius: this.radius, fill: this._fill, stroke: this._stroke }); }, getServices() { const t = this; return xl(ap.methods.getServices.call(this), { get stylesContainer() { return t; } }); }, setFill(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._fill && (this._fill = t, this.scheduleRefresh()); }, setStroke(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._stroke && (this._stroke = t, this.scheduleRefresh()); },
    }; const Ny = { radius(t) { this.$style && !Object(gr.j)(t, this.$style.getRadius()) && this.scheduleRefresh(); } }; const Dy = {
      name: 'vl-style-circle', mixins: [ap, Kd], props: ky, methods: My, watch: Ny,
    }; const $y = Dy; const Gy = void 0; const Vy = void 0; const By = void 0; const Uy = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function zy(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Yy = zy({}, Gy, $y, Vy, Uy, By, void 0, void 0); function Xy(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Xy.installed || (Xy.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Yy, e), t.component(Yy.name, Yy)); } var Wy = Xy; function Ky(t, e, n) { const i = void 0 !== n ? t.toFixed(n) : `${t}`; let r = i.indexOf('.'); return r = r === -1 ? i.length : r, r > e ? i : new Array(1 + e - r).join('0') + i; } function Hy(t, e) { for (let n = (`${t}`).split('.'), i = (`${e}`).split('.'), r = 0; r < Math.max(n.length, i.length); r++) { const o = parseInt(n[r] || '0', 10); const s = parseInt(i[r] || '0', 10); if (o > s) return 1; if (s > o) return -1; } return 0; } function qy(t, e) { return t[0] += e[0], t[1] += e[1], t; } function Zy(t, e) { const n = e.getRadius(); const i = e.getCenter(); const r = i[0]; const o = i[1]; const s = t[0]; const a = t[1]; let u = s - r; const c = a - o; u === 0 && c === 0 && (u = 1); const h = Math.sqrt(u * u + c * c); const l = r + n * u / h; const f = o + n * c / h; return [l, f]; } function Jy(t, e) { let n; let i; const r = t[0]; const o = t[1]; const s = e[0]; const a = e[1]; const u = s[0]; const c = s[1]; const h = a[0]; const l = a[1]; const f = h - u; const p = l - c; const d = f === 0 && p === 0 ? 0 : (f * (r - u) + p * (o - c)) / (f * f + p * p || 0); return d <= 0 ? (n = u, i = c) : d >= 1 ? (n = h, i = l) : (n = u + d * f, i = c + d * p), [n, i]; } function Qy(t, e, n) { const i = Kt(e + 180, 360) - 180; const r = Math.abs(3600 * i); const o = n || 0; const s = Math.pow(10, o); let a = Math.floor(r / 3600); let u = Math.floor((r - 3600 * a) / 60); let c = r - 3600 * a - 60 * u; return c = Math.ceil(c * s) / s, c >= 60 && (c = 0, u += 1), u >= 60 && (u = 0, a += 1), `${a}° ${Ky(u, 2)}′ ${Ky(c, 2, o)}″${i == 0 ? '' : ` ${t.charAt(i < 0 ? 1 : 0)}`}`; } function tm(t, e) { for (var n = !0, i = t.length - 1; i >= 0; --i) if (t[i] != e[i]) { n = !1; break; } return n; } function em(t, e) { const n = Math.cos(e); const i = Math.sin(e); const r = t[0] * n - t[1] * i; const o = t[1] * n + t[0] * i; return t[0] = r, t[1] = o, t; } function nm(t, e) { return t[0] *= e, t[1] *= e, t; } function im(t, e) { const n = t[0] - e[0]; const i = t[1] - e[1]; return n * n + i * i; } function rm(t, e) { return Math.sqrt(im(t, e)); } function om(t, e) { return im(t, Jy(t, e)); } const sm = { ADD: 'add', REMOVE: 'remove' }; const am = { LENGTH: 'length' }; const um = (function (t) { function e(e, n) { t.call(this, e), this.element = n; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const cm = (function (t) { function e(e, n) { t.call(this); const i = n || {}; if (this.unique_ = !!i.unique, this.array_ = e || [], this.unique_) for (let r = 0, o = this.array_.length; r < o; ++r) this.assertUnique_(this.array_[r], r); this.updateLength_(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clear = function () { while (this.getLength() > 0) this.pop(); }, e.prototype.extend = function (t) { for (let e = 0, n = t.length; e < n; ++e) this.push(t[e]); return this; }, e.prototype.forEach = function (t) { for (let e = this.array_, n = 0, i = e.length; n < i; ++n)t(e[n], n, e); }, e.prototype.getArray = function () { return this.array_; }, e.prototype.item = function (t) { return this.array_[t]; }, e.prototype.getLength = function () { return this.get(am.LENGTH); }, e.prototype.insertAt = function (t, e) { this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new um(sm.ADD, e)); }, e.prototype.pop = function () { return this.removeAt(this.getLength() - 1); }, e.prototype.push = function (t) { this.unique_ && this.assertUnique_(t); const e = this.getLength(); return this.insertAt(e, t), this.getLength(); }, e.prototype.remove = function (t) { for (let e = this.array_, n = 0, i = e.length; n < i; ++n) if (e[n] === t) return this.removeAt(n); }, e.prototype.removeAt = function (t) { const e = this.array_[t]; return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new um(sm.REMOVE, e)), e; }, e.prototype.setAt = function (t, e) { const n = this.getLength(); if (t < n) { this.unique_ && this.assertUnique_(e, t); const i = this.array_[t]; this.array_[t] = e, this.dispatchEvent(new um(sm.REMOVE, i)), this.dispatchEvent(new um(sm.ADD, e)); } else { for (let r = n; r < t; ++r) this.insertAt(r, void 0); this.insertAt(t, e); } }, e.prototype.updateLength_ = function () { this.set(am.LENGTH, this.array_.length); }, e.prototype.assertUnique_ = function (t, e) { for (let n = 0, i = this.array_.length; n < i; ++n) if (this.array_[n] === t && n !== e) throw new J(58); }, e; }(di)); const hm = cm; function lm(t, e, n, i) { return function (r, o, s) { const a = new XMLHttpRequest(); a.open('GET', typeof t === 'function' ? t(r, o, s) : t, !0), e.getType() == Uo.ARRAY_BUFFER && (a.responseType = 'arraybuffer'), a.onload = function (t) { if (!a.status || a.status >= 200 && a.status < 300) { let r; const o = e.getType(); o == Uo.JSON || o == Uo.TEXT ? r = a.responseText : o == Uo.XML ? (r = a.responseXML, r || (r = (new DOMParser()).parseFromString(a.responseText, 'application/xml'))) : o == Uo.ARRAY_BUFFER && (r = a.response), r ? n.call(this, e.readFeatures(r, { featureProjection: s }), e.readProjection(r), e.getLastExtent()) : i.call(this); } else i.call(this); }.bind(this), a.onerror = function () { i.call(this); }.bind(this), a.send(); }; } function fm(t, e) { return lm(t, e, function (t, e) { const n = this; typeof n.addFeatures === 'function' && n.addFeatures(t); }, Oe); } const pm = {
      ADDFEATURE: 'addfeature', CHANGEFEATURE: 'changefeature', CLEAR: 'clear', REMOVEFEATURE: 'removefeature',
    }; const dm = n('0354'); const vm = n.n(dm); const gm = function (t) { this.rbush_ = vm()(t, void 0), this.items_ = {}; }; gm.prototype.insert = function (t, e) {
      const n = {
        minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e,
      }; this.rbush_.insert(n), this.items_[H(e)] = n;
    }, gm.prototype.load = function (t, e) {
      for (var n = new Array(e.length), i = 0, r = e.length; i < r; i++) {
        const o = t[i]; const s = e[i]; const a = {
          minX: o[0], minY: o[1], maxX: o[2], maxY: o[3], value: s,
        }; n[i] = a, this.items_[H(s)] = a;
      } this.rbush_.load(n);
    }, gm.prototype.remove = function (t) { const e = H(t); const n = this.items_[e]; return delete this.items_[e], this.rbush_.remove(n) !== null; }, gm.prototype.update = function (t, e) { const n = this.items_[H(e)]; const i = [n.minX, n.minY, n.maxX, n.maxY]; yt(i, t) || (this.remove(e), this.insert(t, e)); }, gm.prototype.getAll = function () { const t = this.rbush_.all(); return t.map(t => t.value); }, gm.prototype.getInExtent = function (t) {
      const e = {
        minX: t[0], minY: t[1], maxX: t[2], maxY: t[3],
      }; const n = this.rbush_.search(e); return n.map(t => t.value);
    }, gm.prototype.forEach = function (t, e) { return this.forEach_(this.getAll(), t, e); }, gm.prototype.forEachInExtent = function (t, e, n) { return this.forEach_(this.getInExtent(t), e, n); }, gm.prototype.forEach_ = function (t, e, n) { for (var i, r = 0, o = t.length; r < o; r++) if (i = e.call(n, t[r]), i) return i; return i; }, gm.prototype.isEmpty = function () { return Qt(this.items_); }, gm.prototype.clear = function () { this.rbush_.clear(), this.items_ = {}; }, gm.prototype.getExtent = function (t) { const e = this.rbush_.toJSON(); return ft(e.minX, e.minY, e.maxX, e.maxY, t); }, gm.prototype.concat = function (t) { for (const e in this.rbush_.load(t.rbush_.all()), t.items_) this.items_[e] = t.items_[e]; }; const ym = gm; const mm = (function (t) { function e(e, n) { t.call(this, e), this.feature = n; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const _m = (function (t) {
      function e(e) {
        const n = e || {}; t.call(this, {
          attributions: n.attributions, projection: void 0, state: vi.READY, wrapX: void 0 === n.wrapX || n.wrapX,
        }), this.loader_ = Oe, this.format_ = n.format, this.overlaps_ = void 0 == n.overlaps || n.overlaps, this.url_ = n.url, void 0 !== n.loader ? this.loader_ = n.loader : void 0 !== this.url_ && (Q(this.format_, 7), this.loader_ = fm(this.url_, this.format_)), this.strategy_ = void 0 !== n.strategy ? n.strategy : Hd; let i; let r; const o = void 0 === n.useSpatialIndex || n.useSpatialIndex; this.featuresRtree_ = o ? new ym() : null, this.loadedExtentsRtree_ = new ym(), this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.undefIdIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null, Array.isArray(n.features) ? r = n.features : n.features && (i = n.features, r = i.getArray()), o || void 0 !== i || (i = new hm(r)), void 0 !== r && this.addFeaturesInternal(r), void 0 !== i && this.bindFeaturesCollection_(i);
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.addFeature = function (t) { this.addFeatureInternal(t), this.changed(); }, e.prototype.addFeatureInternal = function (t) { const e = H(t); if (this.addToIndex_(e, t)) { this.setupChangeEvents_(e, t); const n = t.getGeometry(); if (n) { const i = n.getExtent(); this.featuresRtree_ && this.featuresRtree_.insert(i, t); } else this.nullGeometryFeatures_[e] = t; this.dispatchEvent(new mm(pm.ADDFEATURE, t)); } }, e.prototype.setupChangeEvents_ = function (t, e) { this.featureChangeKeys_[t] = [_e(e, Ae.CHANGE, this.handleFeatureChange_, this), _e(e, ai.PROPERTYCHANGE, this.handleFeatureChange_, this)]; }, e.prototype.addToIndex_ = function (t, e) { let n = !0; const i = e.getId(); return void 0 !== i ? i.toString() in this.idIndex_ ? n = !1 : this.idIndex_[i.toString()] = e : (Q(!(t in this.undefIdIndex_), 30), this.undefIdIndex_[t] = e), n; }, e.prototype.addFeatures = function (t) { this.addFeaturesInternal(t), this.changed(); }, e.prototype.addFeaturesInternal = function (t) { for (var e = [], n = [], i = [], r = 0, o = t.length; r < o; r++) { const s = t[r]; const a = H(s); this.addToIndex_(a, s) && n.push(s); } for (let u = 0, c = n.length; u < c; u++) { const h = n[u]; const l = H(h); this.setupChangeEvents_(l, h); const f = h.getGeometry(); if (f) { const p = f.getExtent(); e.push(p), i.push(h); } else this.nullGeometryFeatures_[l] = h; } this.featuresRtree_ && this.featuresRtree_.load(e, i); for (let d = 0, v = n.length; d < v; d++) this.dispatchEvent(new mm(pm.ADDFEATURE, n[d])); }, e.prototype.bindFeaturesCollection_ = function (t) { let e = !1; _e(this, pm.ADDFEATURE, (n) => { e || (e = !0, t.push(n.feature), e = !1); }), _e(this, pm.REMOVEFEATURE, (n) => { e || (e = !0, t.remove(n.feature), e = !1); }), _e(t, sm.ADD, function (t) { e || (e = !0, this.addFeature(t.element), e = !1); }, this), _e(t, sm.REMOVE, function (t) { e || (e = !0, this.removeFeature(t.element), e = !1); }, this), this.featuresCollection_ = t; }, e.prototype.clear = function (t) { if (t) { for (const e in this.featureChangeKeys_) { const n = this.featureChangeKeys_[e]; n.forEach(xe); } this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.undefIdIndex_ = {}); } else if (this.featuresRtree_) for (const i in this.featuresRtree_.forEach(this.removeFeatureInternal, this), this.nullGeometryFeatures_) this.removeFeatureInternal(this.nullGeometryFeatures_[i]); this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.loadedExtentsRtree_.clear(), this.nullGeometryFeatures_ = {}; const r = new mm(pm.CLEAR); this.dispatchEvent(r), this.changed(); }, e.prototype.forEachFeature = function (t) { if (this.featuresRtree_) return this.featuresRtree_.forEach(t); this.featuresCollection_ && this.featuresCollection_.forEach(t); }, e.prototype.forEachFeatureAtCoordinateDirect = function (t, e) { const n = [t[0], t[1], t[0], t[1]]; return this.forEachFeatureInExtent(n, (n) => { const i = n.getGeometry(); return i.intersectsCoordinate(t) ? e(n) : void 0; }); }, e.prototype.forEachFeatureInExtent = function (t, e) { if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e); this.featuresCollection_ && this.featuresCollection_.forEach(e); }, e.prototype.forEachFeatureIntersectingExtent = function (t, e) { return this.forEachFeatureInExtent(t, (n) => { const i = n.getGeometry(); if (i.intersectsExtent(t)) { const r = e(n); if (r) return r; } }); }, e.prototype.getFeaturesCollection = function () { return this.featuresCollection_; }, e.prototype.getFeatures = function () { let t; return this.featuresCollection_ ? t = this.featuresCollection_.getArray() : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), Qt(this.nullGeometryFeatures_) || Ii(t, Jt(this.nullGeometryFeatures_))), t; }, e.prototype.getFeaturesAtCoordinate = function (t) { const e = []; return this.forEachFeatureAtCoordinateDirect(t, (t) => { e.push(t); }), e; }, e.prototype.getFeaturesInExtent = function (t) { return this.featuresRtree_.getInExtent(t); }, e.prototype.getClosestFeatureToCoordinate = function (t, e) { const n = t[0]; const i = t[1]; let r = null; const o = [NaN, NaN]; let s = 1 / 0; const a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0]; const u = e || Se; return this.featuresRtree_.forEachInExtent(a, (t) => { if (u(t)) { const e = t.getGeometry(); const c = s; if (s = e.closestPointXY(n, i, o, s), s < c) { r = t; const h = Math.sqrt(s); a[0] = n - h, a[1] = i - h, a[2] = n + h, a[3] = i + h; } } }), r; }, e.prototype.getExtent = function (t) { return this.featuresRtree_.getExtent(t); }, e.prototype.getFeatureById = function (t) { const e = this.idIndex_[t.toString()]; return void 0 !== e ? e : null; }, e.prototype.getFormat = function () { return this.format_; }, e.prototype.getOverlaps = function () { return this.overlaps_; }, e.prototype.getUrl = function () { return this.url_; }, e.prototype.handleFeatureChange_ = function (t) { const e = t.target; const n = H(e); const i = e.getGeometry(); if (i) { const r = i.getExtent(); n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(r, e)) : this.featuresRtree_ && this.featuresRtree_.update(r, e); } else n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[n] = e); const o = e.getId(); if (void 0 !== o) { const s = o.toString(); n in this.undefIdIndex_ ? (delete this.undefIdIndex_[n], this.idIndex_[s] = e) : this.idIndex_[s] !== e && (this.removeFromIdIndex_(e), this.idIndex_[s] = e); } else n in this.undefIdIndex_ || (this.removeFromIdIndex_(e), this.undefIdIndex_[n] = e); this.changed(), this.dispatchEvent(new mm(pm.CHANGEFEATURE, e)); }, e.prototype.hasFeature = function (t) { const e = t.getId(); return void 0 !== e ? e in this.idIndex_ : H(t) in this.undefIdIndex_; }, e.prototype.isEmpty = function () { return this.featuresRtree_.isEmpty() && Qt(this.nullGeometryFeatures_); }, e.prototype.loadFeatures = function (t, e, n) { const i = this; const r = this.loadedExtentsRtree_; const o = this.strategy_(t, e); this.loading = !1; for (let s = function (t, s) { const a = o[t]; const u = r.forEachInExtent(a, t => ut(t.extent, a)); u || (i.loader_.call(i, a, e, n), r.insert(a, { extent: a.slice() }), i.loading = i.loader_ !== Oe); }, a = 0, u = o.length; a < u; ++a)s(a, u); }, e.prototype.removeLoadedExtent = function (t) { let e; const n = this.loadedExtentsRtree_; n.forEachInExtent(t, (n) => { if (yt(n.extent, t)) return e = n, !0; }), e && n.remove(e); }, e.prototype.removeFeature = function (t) { const e = H(t); e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t), this.removeFeatureInternal(t), this.changed(); }, e.prototype.removeFeatureInternal = function (t) { const e = H(t); this.featureChangeKeys_[e].forEach(xe), delete this.featureChangeKeys_[e]; const n = t.getId(); void 0 !== n ? delete this.idIndex_[n.toString()] : delete this.undefIdIndex_[e], this.dispatchEvent(new mm(pm.REMOVEFEATURE, t)); }, e.prototype.removeFromIdIndex_ = function (t) { let e = !1; for (const n in this.idIndex_) if (this.idIndex_[n] === t) { delete this.idIndex_[n], e = !0; break; } return e; }, e.prototype.setLoader = function (t) { this.loader_ = t; }, e;
    }(mi)); const bm = _m; const wm = (function (t) { function e(e) { t.call(this, { attributions: e.attributions, wrapX: e.wrapX }), this.resolution = void 0, this.distance = void 0 !== e.distance ? e.distance : 20, this.features = [], this.geometryFunction = e.geometryFunction || function (t) { const e = t.getGeometry(); return Q(e.getType() == en.POINT, 10), e; }, this.source = e.source, _e(this.source, Ae.CHANGE, this.refresh, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDistance = function () { return this.distance; }, e.prototype.getSource = function () { return this.source; }, e.prototype.loadFeatures = function (t, e, n) { this.source.loadFeatures(t, e, n), e !== this.resolution && (this.clear(), this.resolution = e, this.cluster(), this.addFeatures(this.features)); }, e.prototype.setDistance = function (t) { this.distance = t, this.refresh(); }, e.prototype.refresh = function () { this.clear(), this.cluster(), this.addFeatures(this.features), t.prototype.refresh.call(this); }, e.prototype.cluster = function () { if (void 0 !== this.resolution) { this.features.length = 0; for (var t = lt(), e = this.distance * this.resolution, n = this.source.getFeatures(), i = {}, r = 0, o = n.length; r < o; r++) { const s = n[r]; if (!(H(s) in i)) { const a = this.geometryFunction(s); if (a) { const u = a.getCoordinates(); dt(u, t), rt(t, e, t); let c = this.source.getFeaturesInExtent(t); c = c.filter((t) => { const e = H(t); return !(e in i) && (i[e] = !0, !0); }), this.features.push(this.createCluster(c)); } } } } }, e.prototype.createCluster = function (t) { for (var e = [0, 0], n = t.length - 1; n >= 0; --n) { const i = this.geometryFunction(t[n]); i ? qy(e, i.getCoordinates()) : t.splice(n, 1); }nm(e, 1 / t.length); const r = new Cr(new sa(e)); return r.set('features', t), r; }, e; }(bm)); const xm = wm; const Em = (function () {
      function t() { Fr(this, t); } return ko(t, [{ key: 'getSource', value() { return this.source; } }, { key: 'setSource', value(t) { return this.source = t, this; } }, { key: 'setAttributions', value(t) { return this.attributions = t, this; } }, { key: 'setDistance', value(t) { return this.distance = t, this; } }, { key: 'setGeometryFunction', value(t) { return this.geometryFunction = t, this; } }, { key: 'setLogo', value(t) { return this.logo = t, this; } }, { key: 'setProjection', value(t) { return this.projection = t, this; } }, { key: 'setWrapX', value(t) { return this.wrapX = t, this; } }, { key: 'set', value(t, e) { this.values || (this.values = {}), this.values[t] = e; } }, {
        key: 'build',
        value() {
          eo(this.source, 'source is provided'); const t = new xm({
            attributions: this.attributions, distance: this.distance, geometryFunction: this.geometryFunction, logo: this.logo, projection: this.projection, source: this.source, wrapX: this.wrapX,
          }); return t.setProperties(this.values), t;
        },
      }, { key: 'promise', value() { const t = this; return Pl(100).pipe(tf(() => !t.source), Ql(), dh(this.build.bind(this))).toPromise(Ol.a); } }]), t;
    }()); const Sm = { distance: { type: Number, default: 20 }, geomFuncFactory: { type: Function, default: Im } }; const Tm = { geomFunc() { return this.geomFuncFactory(); } }; const Om = {
      createSource() {
        return this._sourceBuilder = (new Em()).setAttributions(this.attributions).setDistance(this.distance).setGeometryFunction(this.geomFunc)
          .setLogo(this.logo)
          .setProjection(this.projection)
          .setWrapX(this.wrapX), this._sourceBuilder.promise();
      },
      getServices() { return xl(Yd.methods.getServices.call(this), Cp.methods.getServices.call(this)); },
      getSourceTarget() { return this._sourceBuilder; },
    }; const Cm = { distance(t) { this.$source && t !== this.$source.getDistance() && this.$source.setDistance(t); } }; const Rm = {
      name: 'vl-source-cluster', mixins: [Yd, Cp], props: Sm, computed: Tm, methods: Om, watch: Cm,
    }; function Im() { return function (t) { const e = t.getGeometry(); if (e) { const n = sc(e); return n ? qu(n) : void 0; } }; } const Pm = Rm; const Lm = void 0; const Am = void 0; const Fm = void 0; const jm = void 0; function km(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Mm = km({}, Lm, Pm, Am, jm, Fm, void 0, void 0); function Nm(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Nm.installed || (Nm.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Mm, e), t.component(Mm.name, Mm)); } var Dm = Nm; const $m = n('db0c'); const Gm = n.n($m); const Vm = {
      SINGLECLICK: 'singleclick', CLICK: Ae.CLICK, DBLCLICK: Ae.DBLCLICK, POINTERDRAG: 'pointerdrag', POINTERMOVE: 'pointermove', POINTERDOWN: 'pointerdown', POINTERUP: 'pointerup', POINTEROVER: 'pointerover', POINTEROUT: 'pointerout', POINTERENTER: 'pointerenter', POINTERLEAVE: 'pointerleave', POINTERCANCEL: 'pointercancel',
    }; const Bm = function (t) { const e = t.originalEvent; return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey; }; const Um = function (t) { const e = t.originalEvent; return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey; }; const zm = function (t) { return t.target.getTargetElement() === document.activeElement; }; const Ym = Se; const Xm = function (t) { const e = t.originalEvent; return e.button == 0 && !(lv && fv && e.ctrlKey); }; const Wm = Te; const Km = function (t) { return t.type == 'pointermove'; }; const Hm = function (t) { return t.type == Vm.SINGLECLICK; }; const qm = function (t) { const e = t.originalEvent; return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey; }; const Zm = function (t) { const e = t.originalEvent; return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey; }; const Jm = function (t) { const e = t.originalEvent.target; const n = e.tagName; return n !== 'INPUT' && n !== 'SELECT' && n !== 'TEXTAREA'; }; const Qm = function (t) { const e = t.pointerEvent; return Q(void 0 !== e, 56), e.pointerType == 'mouse'; }; const t_ = function (t) { const e = t.pointerEvent; return Q(void 0 !== e, 56), e.isPrimary && e.button === 0; }; const e_ = (function (t) { function e(e, n, i) { t.call(this, e), this.map = n, this.frameState = void 0 !== i ? i : null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const n_ = e_; const i_ = (function (t) { function e(e, n, i, r, o) { t.call(this, e, n, o), this.originalEvent = i, this.pixel = n.getEventPixel(i), this.coordinate = n.getCoordinateFromPixel(this.pixel), this.dragging = void 0 !== r && r; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.preventDefault = function () { t.prototype.preventDefault.call(this), this.originalEvent.preventDefault(); }, e.prototype.stopPropagation = function () { t.prototype.stopPropagation.call(this), this.originalEvent.stopPropagation(); }, e; }(n_)); const r_ = i_; const o_ = (function (t) { function e(e, n, i, r, o) { t.call(this, e, n, i.originalEvent, r, o), this.pointerEvent = i; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(r_)); const s_ = o_; const a_ = function (t, e) { this.dispatcher = t, this.mapping_ = e; }; a_.prototype.getEvents = function () { return Object.keys(this.mapping_); }, a_.prototype.getHandlerForEvent = function (t) { return this.mapping_[t]; }; const u_ = a_; const c_ = 1; const h_ = 'mouse'; const l_ = 25; function f_(t) { if (!this.isEventSimulatedFromTouch_(t)) { c_.toString() in this.pointerMap && this.cancel(t); const e = m_(t, this.dispatcher); this.pointerMap[c_.toString()] = t, this.dispatcher.down(e, t); } } function p_(t) { if (!this.isEventSimulatedFromTouch_(t)) { const e = m_(t, this.dispatcher); this.dispatcher.move(e, t); } } function d_(t) { if (!this.isEventSimulatedFromTouch_(t)) { const e = this.pointerMap[c_.toString()]; if (e && e.button === t.button) { const n = m_(t, this.dispatcher); this.dispatcher.up(n, t), this.cleanupMouse(); } } } function v_(t) { if (!this.isEventSimulatedFromTouch_(t)) { const e = m_(t, this.dispatcher); this.dispatcher.enterOver(e, t); } } function g_(t) { if (!this.isEventSimulatedFromTouch_(t)) { const e = m_(t, this.dispatcher); this.dispatcher.leaveOut(e, t); } } const y_ = (function (t) {
      function e(e) {
        const n = {
          mousedown: f_, mousemove: p_, mouseup: d_, mouseover: v_, mouseout: g_,
        }; t.call(this, e, n), this.pointerMap = e.pointerMap, this.lastTouches = [];
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isEventSimulatedFromTouch_ = function (t) { for (let e = this.lastTouches, n = t.clientX, i = t.clientY, r = 0, o = e.length, s = void 0; r < o && (s = e[r]); r++) { const a = Math.abs(n - s[0]); const u = Math.abs(i - s[1]); if (a <= l_ && u <= l_) return !0; } return !1; }, e.prototype.cancel = function (t) { const e = m_(t, this.dispatcher); this.dispatcher.cancel(e, t), this.cleanupMouse(); }, e.prototype.cleanupMouse = function () { delete this.pointerMap[c_.toString()]; }, e;
    }(u_)); function m_(t, e) { const n = e.cloneEvent(t, t); const i = n.preventDefault; return n.preventDefault = function () { t.preventDefault(), i(); }, n.pointerId = c_, n.isPrimary = !0, n.pointerType = h_, n; } const __ = y_; const b_ = (function (t) { function e(e) { const n = e || {}; t.call(this, n), n.handleDownEvent && (this.handleDownEvent = n.handleDownEvent), n.handleDragEvent && (this.handleDragEvent = n.handleDragEvent), n.handleMoveEvent && (this.handleMoveEvent = n.handleMoveEvent), n.handleUpEvent && (this.handleUpEvent = n.handleUpEvent), n.stopDown && (this.stopDown = n.stopDown), this.handlingDownUpSequence = !1, this.trackedPointers_ = {}, this.targetPointers = []; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleDownEvent = function (t) { return !1; }, e.prototype.handleDragEvent = function (t) {}, e.prototype.handleEvent = function (t) { if (!t.pointerEvent) return !0; let e = !1; if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) { if (t.type == Vm.POINTERDRAG) this.handleDragEvent(t); else if (t.type == Vm.POINTERUP) { const n = this.handleUpEvent(t); this.handlingDownUpSequence = n && this.targetPointers.length > 0; } } else if (t.type == Vm.POINTERDOWN) { const i = this.handleDownEvent(t); i && t.preventDefault(), this.handlingDownUpSequence = i, e = this.stopDown(i); } else t.type == Vm.POINTERMOVE && this.handleMoveEvent(t); return !e; }, e.prototype.handleMoveEvent = function (t) {}, e.prototype.handleUpEvent = function (t) { return !1; }, e.prototype.stopDown = function (t) { return t; }, e.prototype.updateTrackedPointers_ = function (t) { if (x_(t)) { const e = t.pointerEvent; const n = e.pointerId.toString(); t.type == Vm.POINTERUP ? delete this.trackedPointers_[n] : t.type == Vm.POINTERDOWN ? this.trackedPointers_[n] = e : n in this.trackedPointers_ && (this.trackedPointers_[n] = e), this.targetPointers = Jt(this.trackedPointers_); } }, e; }(wp)); function w_(t) { for (var e = t.length, n = 0, i = 0, r = 0; r < e; r++)n += t[r].clientX, i += t[r].clientY; return [n / e, i / e]; } function x_(t) { const e = t.type; return e === Vm.POINTERDOWN || e === Vm.POINTERDRAG || e === Vm.POINTERUP; } const E_ = b_; const S_ = {
      IMAGE: 'IMAGE', TILE: 'TILE', VECTOR_TILE: 'VECTOR_TILE', VECTOR: 'VECTOR',
    }; const T_ = {
      POSTCOMPOSE: 'postcompose', PRECOMPOSE: 'precompose', RENDER: 'render', RENDERCOMPLETE: 'rendercomplete',
    }; const O_ = (function (t) { function e(e) { const n = qt({}, e); delete n.source, t.call(this, n), this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, e.map && this.setMap(e.map), _e(this, pi(Fp.SOURCE), this.handleSourcePropertyChange_, this); const i = e.source ? e.source : null; this.setSource(i); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getLayersArray = function (t) { const e = t || []; return e.push(this), e; }, e.prototype.getLayerStatesArray = function (t) { const e = t || []; return e.push(this.getLayerState()), e; }, e.prototype.getSource = function () { const t = this.get(Fp.SOURCE); return t || null; }, e.prototype.getSourceState = function () { const t = this.getSource(); return t ? t.getState() : vi.UNDEFINED; }, e.prototype.handleSourceChange_ = function () { this.changed(); }, e.prototype.handleSourcePropertyChange_ = function () { this.sourceChangeKey_ && (xe(this.sourceChangeKey_), this.sourceChangeKey_ = null); const t = this.getSource(); t && (this.sourceChangeKey_ = _e(t, Ae.CHANGE, this.handleSourceChange_, this)), this.changed(); }, e.prototype.setMap = function (t) { this.mapPrecomposeKey_ && (xe(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (xe(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = _e(t, T_.PRECOMPOSE, function (t) { const e = t; const n = this.getLayerState(); n.managed = !1, void 0 === this.getZIndex() && (n.zIndex = 1 / 0), e.frameState.layerStatesArray.push(n), e.frameState.layerStates[H(this)] = n; }, this), this.mapRenderKey_ = _e(this, Ae.CHANGE, t.render, t), this.changed()); }, e.prototype.setSource = function (t) { this.set(Fp.SOURCE, t); }, e; }(kp)); function C_(t, e) { return t.visible && e >= t.minResolution && e < t.maxResolution; } const R_ = O_; const I_ = { IMAGE: 'image', VECTOR: 'vector' }; const P_ = { RENDER_ORDER: 'renderOrder' }; const L_ = (function (t) { function e(e) { const n = e || {}; const i = qt({}, n); delete i.style, delete i.renderBuffer, delete i.updateWhileAnimating, delete i.updateWhileInteracting, t.call(this, i), this.declutter_ = void 0 !== n.declutter && n.declutter, this.renderBuffer_ = void 0 !== n.renderBuffer ? n.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(n.style), this.updateWhileAnimating_ = void 0 !== n.updateWhileAnimating && n.updateWhileAnimating, this.updateWhileInteracting_ = void 0 !== n.updateWhileInteracting && n.updateWhileInteracting, this.renderMode_ = n.renderMode || I_.VECTOR, this.type = S_.VECTOR; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDeclutter = function () { return this.declutter_; }, e.prototype.setDeclutter = function (t) { this.declutter_ = t; }, e.prototype.getRenderBuffer = function () { return this.renderBuffer_; }, e.prototype.getRenderOrder = function () { return this.get(P_.RENDER_ORDER); }, e.prototype.getStyle = function () { return this.style_; }, e.prototype.getStyleFunction = function () { return this.styleFunction_; }, e.prototype.getUpdateWhileAnimating = function () { return this.updateWhileAnimating_; }, e.prototype.getUpdateWhileInteracting = function () { return this.updateWhileInteracting_; }, e.prototype.setRenderOrder = function (t) { this.set(P_.RENDER_ORDER, t); }, e.prototype.setStyle = function (t) { this.style_ = void 0 !== t ? t : lg, this.styleFunction_ = t === null ? void 0 : cg(this.style_), this.changed(); }, e.prototype.getRenderMode = function () { return this.renderMode_; }, e; }(R_)); L_.prototype.getSource; const A_ = L_; const F_ = {
      POINT: 'Point', LINE_STRING: 'LineString', POLYGON: 'Polygon', CIRCLE: 'Circle',
    }; const j_ = { DRAWSTART: 'drawstart', DRAWEND: 'drawend' }; const k_ = (function (t) { function e(e, n) { t.call(this, e), this.feature = n; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const M_ = (function (t) { function e(e) { const n = e; n.stopDown || (n.stopDown = Te), t.call(this, n), this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = e.type, this.mode_ = D_(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === F_.POLYGON ? 3 : 2, this.maxPoints_ = e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : Se; let i = e.geometryFunction; if (!i) if (this.type_ === en.CIRCLE)i = function (t, e) { const n = e || new Hu([NaN, NaN]); const i = im(t[0], t[1]); return n.setCenterAndRadius(t[0], Math.sqrt(i)), n; }; else { let r; const o = this.mode_; o === F_.POINT ? r = sa : o === F_.LINE_STRING ? r = na : o === F_.POLYGON && (r = Ea), i = function (t, e) { let n = e; return n ? o === F_.POLYGON ? t[0].length ? n.setCoordinates([t[0].concat([t[0][0]])]) : n.setCoordinates([]) : n.setCoordinates(t) : n = new r(t), n; }; } this.geometryFunction_ = i, this.dragVertexDelay_ = void 0 !== e.dragVertexDelay ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new A_({ source: new bm({ useSpatialIndex: !1, wrapX: !!e.wrapX && e.wrapX }), style: e.style ? e.style : N_(), updateWhileInteracting: !0 }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : qm, this.freehandCondition_, e.freehand ? this.freehandCondition_ = Ym : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : Zm, _e(this, pi(pp.ACTIVE), this.updateState_, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setMap = function (e) { t.prototype.setMap.call(this, e), this.updateState_(); }, e.prototype.getOverlay = function () { return this.overlay_; }, e.prototype.handleEvent = function (e) { e.originalEvent.type === Ae.CONTEXTMENU && e.preventDefault(), this.freehand_ = this.mode_ !== F_.POINT && this.freehandCondition_(e); let n = e.type === Vm.POINTERMOVE; let i = !0; if (!this.freehand_ && this.lastDragTime_ && e.type === Vm.POINTERDRAG) { const r = Date.now(); r - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, n = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && void 0 !== this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0); } return this.freehand_ && e.type === Vm.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e), i = !1) : this.freehand_ && e.type === Vm.POINTERDOWN ? i = !1 : n ? (i = e.type === Vm.POINTERMOVE, i && this.freehand_ ? i = this.handlePointerMove_(e) : (e.pointerEvent.pointerType == h_ || e.type === Vm.POINTERDRAG && void 0 === this.downTimeout_) && this.handlePointerMove_(e)) : e.type === Vm.DBLCLICK && (i = !1), t.prototype.handleEvent.call(this, e) && i; }, e.prototype.handleDownEvent = function (t) { return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t), !0) : !!this.condition_(t) && (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => { this.handlePointerMove_(new s_(Vm.POINTERMOVE, t.map, t.pointerEvent, !1, t.frameState)); }, this.dragVertexDelay_), this.downPx_ = t.pixel, !0); }, e.prototype.handleUpEvent = function (t) { let e = !0; this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t); const n = this.mode_ === F_.CIRCLE; return this.shouldHandle_ ? (this.finishCoordinate_ ? this.freehand_ || n ? this.finishDrawing() : this.atFinish_(t) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t) : (this.startDrawing_(t), this.mode_ === F_.POINT && this.finishDrawing()), e = !1) : this.freehand_ && (this.finishCoordinate_ = null, this.abortDrawing_()), !e && this.stopClick_ && t.stopPropagation(), e; }, e.prototype.handlePointerMove_ = function (t) { if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) { const e = this.downPx_; const n = t.pixel; const i = e[0] - n[0]; const r = e[1] - n[1]; const o = i * i + r * r; if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_) return !0; } return this.finishCoordinate_ ? this.modifyDrawing_(t) : this.createOrUpdateSketchPoint_(t), !0; }, e.prototype.atFinish_ = function (t) { let e = !1; if (this.sketchFeature_) { let n = !1; let i = [this.finishCoordinate_]; if (this.mode_ === F_.LINE_STRING)n = this.sketchCoords_.length > this.minPoints_; else if (this.mode_ === F_.POLYGON) { const r = this.sketchCoords_; n = r[0].length > this.minPoints_, i = [r[0][0], r[0][r[0].length - 2]]; } if (n) for (let o = t.map, s = 0, a = i.length; s < a; s++) { const u = i[s]; const c = o.getPixelFromCoordinate(u); const h = t.pixel; const l = h[0] - c[0]; const f = h[1] - c[1]; const p = this.freehand_ ? 1 : this.snapTolerance_; if (e = Math.sqrt(l * l + f * f) <= p, e) { this.finishCoordinate_ = u; break; } } } return e; }, e.prototype.createOrUpdateSketchPoint_ = function (t) { const e = t.coordinate.slice(); if (this.sketchPoint_) { const n = this.sketchPoint_.getGeometry(); n.setCoordinates(e); } else this.sketchPoint_ = new Cr(new sa(e)), this.updateSketchFeatures_(); }, e.prototype.startDrawing_ = function (t) { const e = t.coordinate; this.finishCoordinate_ = e, this.mode_ === F_.POINT ? this.sketchCoords_ = e.slice() : this.mode_ === F_.POLYGON ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Cr(new na(this.sketchLineCoords_))); const n = this.geometryFunction_(this.sketchCoords_); this.sketchFeature_ = new Cr(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(n), this.updateSketchFeatures_(), this.dispatchEvent(new k_(j_.DRAWSTART, this.sketchFeature_)); }, e.prototype.modifyDrawing_ = function (t) { let e; let n; let i; let r = t.coordinate; const o = this.sketchFeature_.getGeometry(); if (this.mode_ === F_.POINT ? n = this.sketchCoords_ : this.mode_ === F_.POLYGON ? (e = this.sketchCoords_[0], n = e[e.length - 1], this.atFinish_(t) && (r = this.finishCoordinate_.slice())) : (e = this.sketchCoords_, n = e[e.length - 1]), n[0] = r[0], n[1] = r[1], this.geometryFunction_(this.sketchCoords_, o), this.sketchPoint_) { const s = this.sketchPoint_.getGeometry(); s.setCoordinates(r); } if (o.getType() == en.POLYGON && this.mode_ !== F_.POLYGON) { this.sketchLine_ || (this.sketchLine_ = new Cr()); const a = o.getLinearRing(0); i = this.sketchLine_.getGeometry(), i ? (i.setFlatCoordinates(a.getLayout(), a.getFlatCoordinates()), i.changed()) : (i = new na(a.getFlatCoordinates(), a.getLayout()), this.sketchLine_.setGeometry(i)); } else this.sketchLineCoords_ && (i = this.sketchLine_.getGeometry(), i.setCoordinates(this.sketchLineCoords_)); this.updateSketchFeatures_(); }, e.prototype.addToDrawing_ = function (t) { let e; let n; const i = t.coordinate; const r = this.sketchFeature_.getGeometry(); this.mode_ === F_.LINE_STRING ? (this.finishCoordinate_ = i.slice(), n = this.sketchCoords_, n.length >= this.maxPoints_ && (this.freehand_ ? n.pop() : e = !0), n.push(i.slice()), this.geometryFunction_(n, r)) : this.mode_ === F_.POLYGON && (n = this.sketchCoords_[0], n.length >= this.maxPoints_ && (this.freehand_ ? n.pop() : e = !0), n.push(i.slice()), e && (this.finishCoordinate_ = n[0]), this.geometryFunction_(this.sketchCoords_, r)), this.updateSketchFeatures_(), e && this.finishDrawing(); }, e.prototype.removeLastPoint = function () { if (this.sketchFeature_) { let t; let e; const n = this.sketchFeature_.getGeometry(); this.mode_ === F_.LINE_STRING ? (t = this.sketchCoords_, t.splice(-2, 1), this.geometryFunction_(t, n), t.length >= 2 && (this.finishCoordinate_ = t[t.length - 2].slice())) : this.mode_ === F_.POLYGON && (t = this.sketchCoords_[0], t.splice(-2, 1), e = this.sketchLine_.getGeometry(), e.setCoordinates(t), this.geometryFunction_(this.sketchCoords_, n)), t.length === 0 && (this.finishCoordinate_ = null), this.updateSketchFeatures_(); } }, e.prototype.finishDrawing = function () { const t = this.abortDrawing_(); if (t) { let e = this.sketchCoords_; const n = t.getGeometry(); this.mode_ === F_.LINE_STRING ? (e.pop(), this.geometryFunction_(e, n)) : this.mode_ === F_.POLYGON && (e[0].pop(), this.geometryFunction_(e, n), e = n.getCoordinates()), this.type_ === en.MULTI_POINT ? t.setGeometry(new ua([e])) : this.type_ === en.MULTI_LINE_STRING ? t.setGeometry(new ra([e])) : this.type_ === en.MULTI_POLYGON && t.setGeometry(new Pa([e])), this.dispatchEvent(new k_(j_.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t); } }, e.prototype.abortDrawing_ = function () { this.finishCoordinate_ = null; const t = this.sketchFeature_; return t && (this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0)), t; }, e.prototype.extend = function (t) { const e = t.getGeometry(); const n = e; this.sketchFeature_ = t, this.sketchCoords_ = n.getCoordinates(); const i = this.sketchCoords_[this.sketchCoords_.length - 1]; this.finishCoordinate_ = i.slice(), this.sketchCoords_.push(i.slice()), this.updateSketchFeatures_(), this.dispatchEvent(new k_(j_.DRAWSTART, this.sketchFeature_)); }, e.prototype.updateSketchFeatures_ = function () { const t = []; this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_); const e = this.overlay_.getSource(); e.clear(!0), e.addFeatures(t); }, e.prototype.updateState_ = function () { const t = this.getMap(); const e = this.getActive(); t && e || this.abortDrawing_(), this.overlay_.setMap(e ? t : null); }, e; }(E_)); function N_() { const t = fg(); return function (e, n) { return t[e.getGeometry().getType()]; }; } function D_(t) { let e; return t === en.POINT || t === en.MULTI_POINT ? e = F_.POINT : t === en.LINE_STRING || t === en.MULTI_LINE_STRING ? e = F_.LINE_STRING : t === en.POLYGON || t === en.MULTI_POLYGON ? e = F_.POLYGON : t === en.CIRCLE && (e = F_.CIRCLE), e; } const $_ = M_; const G_ = function (t) { return Object(gr.A)(Object(gr.a)(t)); }; const V_ = {
      source: { type: String, required: !0 }, clickTolerance: { type: Number, default: 6 }, snapTolerance: { type: Number, default: 12 }, type: { type: String, required: !0, validator(t) { return Gm()(To).includes(G_(t)); } }, stopClick: { type: Boolean, default: !1 }, maxPoints: Number, minPoints: Number, finishCondition: Function, geometryFunction: Function, geometryName: { type: String, default: 'geometry' }, condition: { type: Function, default: qm }, freehand: { type: Boolean, default: !1 }, freehandCondition: { type: Function, default: Zm }, wrapX: { type: Boolean, default: !1 },
    }; const B_ = {
      createInteraction: (function () {
        const t = Rl(Sl.a.mark(function t() {
          let e; let n; let i; return Sl.a.wrap(function (t) {
            while (1) {
              switch (t.prev = t.next) {
                case 0: return e = this.makeIdent(this.source), t.next = 3, this.$identityMap.get(e, this.$options.INSTANCE_PROMISE_POOL); case 3: return n = t.sent, Object(gr.l)(n.getFeatures) && (i = n.getFeatures(), Oc(i) && (n = i)), t.abrupt('return', new $_({
                  source: Cc(n) ? n : void 0, features: Oc(n) ? n : void 0, clickTolerance: this.clickTolerance, snapTolerance: this.snapTolerance, type: G_(this.type), stopClick: this.stopClick, maxPoints: this.maxPoints, minPoints: this.minPoints, finishCondition: this.finishCondition, style: this.createStyleFunc(), geometryFunction: this.geometryFunction, geometryName: this.geometryName, condition: this.condition, freehand: this.freehand, freehandCondition: this.freehandCondition, wrapX: this.wrapX,
                })); case 6: case 'end': return t.stop();
              }
            }
          }, t, this);
        })); return function () { return t.apply(this, arguments); };
      }()),
      getDefaultStyles() { const t = Object(gr.s)(wg(), t => t.map(Eg)); return function (e) { if (e.getGeometry()) return t[e.getGeometry().getType()]; }; },
      getServices() { return xl(fp.methods.getServices.call(this), td.methods.getServices.call(this)); },
      getStyleTarget() { return this.$interaction; },
      mount() { fp.methods.mount.call(this); },
      unmount() { fp.methods.unmount.call(this); },
      setStyle(t) { t !== this._styles && (this._styles = t, this.scheduleRefresh()); },
      subscribeAll() { Y_.call(this); },
    }; const U_ = Sf(['source', 'type'], () => function () { this.scheduleRecreate(); }); const z_ = {
      name: 'vl-interaction-draw', mixins: [fp, td], props: V_, methods: B_, watch: U_, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } },
    };
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Y_() { const t = this; ho(this); const e = gl(ml(this.$interaction, 'drawstart').pipe(dh(t => Lr(t.feature), t)), ml(this.$interaction, 'drawend')); this.subscribeTo(e, (e) => { ++t.rev, t.$emit(e.type, e); }); } const X_ = z_; const W_ = void 0; const K_ = void 0; const H_ = void 0; const q_ = void 0; function Z_(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'interaction.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var J_ = Z_({}, W_, X_, K_, q_, H_, void 0, void 0); function Q_(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Q_.installed || (Q_.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(J_, e), t.component(J_.name, J_)); } var tb = Q_; const eb = { id: { type: [String, Number], default() { return Pr()(); } }, properties: { type: Object, default() { return Br()(null); } } }; const nb = {
      geometry() { if (this.rev && this.resolvedDataProjection && this.$geometry) return this.writeGeometryInDataProj(this.$geometry); }, point() { if (this.pointViewProj && this.resolvedDataProjection) return this.pointToDataProj(this.pointViewProj); }, geometryViewProj() { if (this.rev && this.resolvedDataProjection && this.$geometry) return this.writeGeometryInViewProj(this.$geometry); }, pointViewProj() { if (this.rev && this.$geometry) return sc(this.$geometry); },
    }; const ib = {
      createOlObject() { const t = new Cr(this.properties); return t.setId(this.id), t.setGeometry(this.$geometry), t; }, getGeometryTarget() { return this.$feature; }, getServices() { const t = this; return xl(Ef.methods.getServices.call(this), Bf.methods.getServices.call(this), td.methods.getServices.call(this), { get feature() { return t.$feature; } }); }, getStyleTarget() { return this.$feature; }, isAtPixel(t) { const e = this; return io(this), this.$map.forEachFeatureAtPixel(t, t => t === e.$feature, { layerFilter(t) { return t === e.$layer; } }); }, mount() { this.$featuresContainer && this.$featuresContainer.addFeature(this), this.subscribeAll(); }, unmount() { this.unsubscribeAll(), this.$featuresContainer && this.$featuresContainer.removeFeature(this); }, subscribeAll() { sb.call(this); },
    }; const rb = { id(t) { this.$feature && t !== this.$feature.getId() && this.$feature.setId(t); }, properties(t) { t = Object(gr.v)(t), this.$feature && !Object(gr.j)(t, Object(gr.v)(this.$feature.getProperties())) && this.$feature.setProperties(Object(gr.v)(t)); } }; const ob = {
      name: 'vl-feature',
      mixins: [Ef, Lf, Bf, td, $c],
      props: eb,
      computed: nb,
      methods: ib,
      watch: rb,
      created() {
        const t = this; zc()(this, {
          $feature: { enumerable: !0, get() { return t.$olObject; } }, $layer: { enumerable: !0, get() { return t.$services && t.$services.layer; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $featuresContainer: { enumerable: !0, get() { return t.$services && t.$services.featuresContainer; } },
        });
      },
    };
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function sb() { const t = this; so(this); const e = function (e) { return t.$feature.get(e); }; const n = 100; const i = ml(this.$feature, 'propertychange', (t) => { const n = t.key; return { prop: n, value: e(n) }; }).pipe(Bh(n), lh(gr.j)); const r = ml(this.$feature, 'change').pipe(dh(() => Ih.create((e) => { t.$feature.getId() !== t.id && e.next({ prop: 'id', value: t.$feature.getId() }); })), vl(), Bh(n), lh(gr.j)); const o = gl(i, r); this.subscribeTo(o, (e) => { const n = e.prop; const i = e.value; ++t.rev, n === 'id' ? t.$emit('update:'.concat(n), i) : n !== t.$feature.getGeometryName() && t.$emit('update:properties', Zd()({}, t.properties, lr({}, n, i))); }); } const ab = ob; const ub = function () {
      const t = this; const e = t.$createElement; const n = t._self._c || e; return n('i', { class: [t.$options.name], staticStyle: { display: 'none !important' }, attrs: { id: [t.$options.name, t.id].join('-') } }, [t._t('default', null, {
        id: t.id, properties: t.properties, geometry: t.geometry, point: t.point,
      })], 2);
    }; const cb = []; const hb = void 0; const lb = void 0; const fb = void 0; const pb = !1; function db(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'feature.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var vb = db({ render: ub, staticRenderFns: cb }, hb, ab, lb, pb, fb, void 0, void 0); function gb(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; gb.installed || (gb.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(vb, e), t.component(vb.name, vb)); } var yb = gb; const mb = { color: [String, Array] }; const _b = { createStyle() { return new qv({ color: this.color }); }, mount() { this.$stylesContainer && this.$stylesContainer.setFill(this); }, unmount() { this.$stylesContainer && this.$stylesContainer.setFill(void 0); } }; const bb = { color(t) { this.$style && !Object(gr.j)(t, this.$style.getColor()) && (this.$style.setColor(t), this.scheduleRefresh()); } }; const wb = {
      name: 'vl-style-fill', mixins: [np], props: mb, methods: _b, watch: bb,
    }; const xb = wb; const Eb = void 0; const Sb = void 0; const Tb = void 0; const Ob = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Cb(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Rb = Cb({}, Eb, xb, Sb, Ob, Tb, void 0, void 0); function Ib(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Ib.installed || (Ib.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Rb, e), t.component(Rb.name, Rb)); } var Pb = Ib; const Lb = {
      ACCURACY: 'accuracy', ACCURACY_GEOMETRY: 'accuracyGeometry', ALTITUDE: 'altitude', ALTITUDE_ACCURACY: 'altitudeAccuracy', HEADING: 'heading', POSITION: 'position', PROJECTION: 'projection', SPEED: 'speed', TRACKING: 'tracking', TRACKING_OPTIONS: 'trackingOptions',
    }; const Ab = (function (t) { function e(e) { t.call(this, Ae.ERROR), this.code = e.code, this.message = e.message; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const Fb = (function (t) { function e(e) { t.call(this); const n = e || {}; this.position_ = null, this.transform_ = Ln, this.watchId_ = void 0, _e(this, pi(Lb.PROJECTION), this.handleProjectionChanged_, this), _e(this, pi(Lb.TRACKING), this.handleTrackingChanged_, this), void 0 !== n.projection && this.setProjection(n.projection), void 0 !== n.trackingOptions && this.setTrackingOptions(n.trackingOptions), this.setTracking(void 0 !== n.tracking && n.tracking); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.setTracking(!1), t.prototype.disposeInternal.call(this); }, e.prototype.handleProjectionChanged_ = function () { const t = this.getProjection(); t && (this.transform_ = Bn(jn('EPSG:4326'), t), this.position_ && this.set(Lb.POSITION, this.transform_(this.position_))); }, e.prototype.handleTrackingChanged_ = function () { if (vv) { const t = this.getTracking(); t && void 0 === this.watchId_ ? this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions()) : t || void 0 === this.watchId_ || (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0); } }, e.prototype.positionChange_ = function (t) { const e = t.coords; this.set(Lb.ACCURACY, e.accuracy), this.set(Lb.ALTITUDE, e.altitude === null ? void 0 : e.altitude), this.set(Lb.ALTITUDE_ACCURACY, e.altitudeAccuracy === null ? void 0 : e.altitudeAccuracy), this.set(Lb.HEADING, e.heading === null ? void 0 : Wt(e.heading)), this.position_ ? (this.position_[0] = e.longitude, this.position_[1] = e.latitude) : this.position_ = [e.longitude, e.latitude]; const n = this.transform_(this.position_); this.set(Lb.POSITION, n), this.set(Lb.SPEED, e.speed === null ? void 0 : e.speed); const i = Sa(this.position_, e.accuracy); i.applyTransform(this.transform_), this.set(Lb.ACCURACY_GEOMETRY, i), this.changed(); }, e.prototype.positionError_ = function (t) { this.setTracking(!1), this.dispatchEvent(new Ab(t)); }, e.prototype.getAccuracy = function () { return this.get(Lb.ACCURACY); }, e.prototype.getAccuracyGeometry = function () { return this.get(Lb.ACCURACY_GEOMETRY) || null; }, e.prototype.getAltitude = function () { return this.get(Lb.ALTITUDE); }, e.prototype.getAltitudeAccuracy = function () { return this.get(Lb.ALTITUDE_ACCURACY); }, e.prototype.getHeading = function () { return this.get(Lb.HEADING); }, e.prototype.getPosition = function () { return this.get(Lb.POSITION); }, e.prototype.getProjection = function () { return this.get(Lb.PROJECTION); }, e.prototype.getSpeed = function () { return this.get(Lb.SPEED); }, e.prototype.getTracking = function () { return this.get(Lb.TRACKING); }, e.prototype.getTrackingOptions = function () { return this.get(Lb.TRACKING_OPTIONS); }, e.prototype.setProjection = function (t) { this.set(Lb.PROJECTION, jn(t)); }, e.prototype.setTracking = function (t) { this.set(Lb.TRACKING, t); }, e.prototype.setTrackingOptions = function (t) { this.set(Lb.TRACKING_OPTIONS, t); }, e; }(di)); const jb = Fb; const kb = { tracking: { type: Boolean, default: !0 }, trackingOptions: Object, projection: String }; const Mb = {
      accuracy() { if (this.rev && this.$geolocation) return this.$geolocation.getAccuracy(); }, altitude() { if (this.rev && this.$geolocation) return this.$geolocation.getAltitude(); }, altitudeAccuracy() { if (this.rev && this.$geolocation) return this.$geolocation.getAltitudeAccuracy(); }, heading() { if (this.rev && this.$geolocation) return this.$geolocation.getHeading(); }, speed() { if (this.rev && this.$geolocation) return this.$geolocation.getSpeed(); }, position() { if (this.rev && this.$geolocation) return this.$geolocation.getPosition(); }, positionViewProj() { if (this.position && this.resolvedDataProjection) return this.pointToViewProj(this.position); },
    }; const Nb = {
      createOlObject() { return new jb({ tracking: this.tracking, trackingOptions: this.trackingOptions, projection: this.resolvedDataProjection }); }, mount() { this.subscribeAll(); }, unmount() { oo(this), this.unsubscribeAll(), this.$geolocation.setTracking(!1); }, subscribeAll() { Gb.call(this); },
    }; const Db = { tracking(t) { this.$geolocation && t !== this.$geolocation.getTracking() && this.$geolocation.setTracking(t); }, tracingOptions(t) { this.$geolocation && this.$geolocation.setTrackingOptions(t); }, resolvedDataProjection(t) { this.$geolocation && this.$geolocation.setProjection(t); } }; const $b = {
      name: 'vl-geoloc', mixins: [Ef, Lf, $c], props: kb, computed: Mb, methods: Nb, watch: Db, stubVNode: { empty() { return this.$options.name; } }, created() { const t = this; zc()(this, { $geolocation: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } } }); },
    }; function Gb() { const t = this; oo(this); const e = 100; const n = gl(Qf(this.$geolocation, ['accuracy', 'altitude', 'altitudeaccuracy', 'heading', 'speed'], !0, e), Qf(this.$geolocation, 'position', !0, e, () => t.position)); this.subscribeTo(n, (e) => { const n = e.prop; const i = e.value; ++t.rev, t.$emit('update:'.concat(n), i); }); } const Vb = $b; const Bb = function () {
      const t = this; const e = t.$createElement; const n = t._self._c || e; return n('i', { class: [t.$options.name], staticStyle: { display: 'none !important' } }, [t._t('default', null, {
        accuracy: t.accuracy, altitude: t.altitude, altitudeAccuracy: t.altitudeAccuracy, heading: t.heading, position: t.position, speed: t.speed,
      })], 2);
    }; const Ub = []; const zb = void 0; const Yb = void 0; const Xb = void 0; const Wb = !1; function Kb(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geoloc.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Hb = Kb({ render: Bb, staticRenderFns: Ub }, zb, Vb, Yb, Wb, Xb, void 0, void 0); function qb(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; qb.installed || (qb.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Hb, e), t.component(Hb.name, Hb)); } var Zb = qb; function Jb(t, e, n) { let i; let r; let o; let s; let a; let u; const c = []; let h = t(0); let l = t(1); let f = e(h); let p = e(l); const d = [l, h]; const v = [p, f]; const g = [1, 0]; const y = {}; let m = 1e5; while (--m > 0 && g.length > 0)o = g.pop(), h = d.pop(), f = v.pop(), u = o.toString(), u in y || (c.push(f[0], f[1]), y[u] = !0), s = g.pop(), l = d.pop(), p = v.pop(), a = (o + s) / 2, i = t(a), r = e(i), Ut(r[0], r[1], f[0], f[1], p[0], p[1]) < n ? (c.push(p[0], p[1]), u = s.toString(), y[u] = !0) : (g.push(s, a, a, o), v.push(p, r, r, f), d.push(l, i, i, h)); return c; } function Qb(t, e, n, i, r) { const o = jn('EPSG:4326'); return Jb(i => [t, e + (n - e) * i], Un(o, i), r); } function tw(t, e, n, i, r) { const o = jn('EPSG:4326'); return Jb(i => [e + (n - e) * i, t], Un(o, i), r); } const ew = new ag({ color: 'rgba(0,0,0,0.2)' }); const nw = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]; const iw = function (t) {
      const e = t || {}; this.map_ = null, this.postcomposeListenerKey_ = null, this.projection_ = null, this.maxLat_ = 1 / 0, this.maxLon_ = 1 / 0, this.minLat_ = -1 / 0, this.minLon_ = -1 / 0, this.maxLatP_ = 1 / 0, this.maxLonP_ = 1 / 0, this.minLatP_ = -1 / 0, this.minLonP_ = -1 / 0, this.targetSize_ = void 0 !== e.targetSize ? e.targetSize : 100, this.maxLines_ = void 0 !== e.maxLines ? e.maxLines : 100, this.meridians_ = [], this.parallels_ = [], this.strokeStyle_ = void 0 !== e.strokeStyle ? e.strokeStyle : ew, this.fromLonLatTransform_ = void 0, this.toLonLatTransform_ = void 0, this.projectionCenterLonLat_ = null, this.meridiansLabels_ = null, this.parallelsLabels_ = null, e.showLabels == 1 && (this.lonLabelFormatter_ = void 0 == e.lonLabelFormatter ? Qy.bind(this, 'EW') : e.lonLabelFormatter, this.latLabelFormatter_ = void 0 == e.latLabelFormatter ? Qy.bind(this, 'NS') : e.latLabelFormatter, this.lonLabelPosition_ = void 0 == e.lonLabelPosition ? 0 : e.lonLabelPosition, this.latLabelPosition_ = void 0 == e.latLabelPosition ? 1 : e.latLabelPosition, this.lonLabelStyle_ = void 0 !== e.lonLabelStyle ? e.lonLabelStyle : new mg({
        font: '12px Calibri,sans-serif', textBaseline: 'bottom', fill: new qv({ color: 'rgba(0,0,0,1)' }), stroke: new ag({ color: 'rgba(255,255,255,1)', width: 3 }),
      }), this.latLabelStyle_ = void 0 !== e.latLabelStyle ? e.latLabelStyle : new mg({
        font: '12px Calibri,sans-serif', textAlign: 'end', fill: new qv({ color: 'rgba(0,0,0,1)' }), stroke: new ag({ color: 'rgba(255,255,255,1)', width: 3 }),
      }), this.meridiansLabels_ = [], this.parallelsLabels_ = []), this.intervals_ = void 0 !== e.intervals ? e.intervals : nw, this.setMap(void 0 !== e.map ? e.map : null);
    }; iw.prototype.addMeridian_ = function (t, e, n, i, r, o) { const s = this.getMeridian_(t, e, n, i, o); if (kt(s.getExtent(), r)) { if (this.meridiansLabels_) { const a = this.getMeridianPoint_(s, r, o); this.meridiansLabels_[o] = { geom: a, text: this.lonLabelFormatter_(t) }; } this.meridians_[o++] = s; } return o; }, iw.prototype.getMeridianPoint_ = function (t, e, n) { let i; const r = t.getFlatCoordinates(); const o = Math.max(e[1], r[1]); const s = Math.min(e[3], r[r.length - 1]); const a = Vt(e[1] + Math.abs(e[1] - e[3]) * this.lonLabelPosition_, o, s); const u = [r[0], a]; return n in this.meridiansLabels_ ? (i = this.meridiansLabels_[n].geom, i.setCoordinates(u)) : i = new sa(u), i; }, iw.prototype.addParallel_ = function (t, e, n, i, r, o) { const s = this.getParallel_(t, e, n, i, o); if (kt(s.getExtent(), r)) { if (this.parallelsLabels_) { const a = this.getParallelPoint_(s, r, o); this.parallelsLabels_[o] = { geom: a, text: this.latLabelFormatter_(t) }; } this.parallels_[o++] = s; } return o; }, iw.prototype.getParallelPoint_ = function (t, e, n) { let i; const r = t.getFlatCoordinates(); const o = Math.max(e[0], r[0]); const s = Math.min(e[2], r[r.length - 2]); const a = Vt(e[0] + Math.abs(e[0] - e[2]) * this.latLabelPosition_, o, s); const u = [a, r[1]]; return n in this.parallelsLabels_ ? (i = this.parallelsLabels_[n].geom, i.setCoordinates(u)) : i = new sa(u), i; }, iw.prototype.createGraticule_ = function (t, e, n, i) { const r = this.getInterval_(n); if (r == -1) return this.meridians_.length = this.parallels_.length = 0, this.meridiansLabels_ && (this.meridiansLabels_.length = 0), void (this.parallelsLabels_ && (this.parallelsLabels_.length = 0)); let o; let s; let a; let u; const c = this.toLonLatTransform_(e); let h = c[0]; let l = c[1]; const f = this.maxLines_; let p = [Math.max(t[0], this.minLonP_), Math.max(t[1], this.minLatP_), Math.min(t[2], this.maxLonP_), Math.min(t[3], this.maxLatP_)]; p = Yn(p, this.projection_, 'EPSG:4326'); const d = p[3]; const v = p[2]; const g = p[1]; const y = p[0]; h = Math.floor(h / r) * r, u = Vt(h, this.minLon_, this.maxLon_), s = this.addMeridian_(u, g, d, i, t, 0), o = 0; while (u != this.minLon_ && o++ < f)u = Math.max(u - r, this.minLon_), s = this.addMeridian_(u, g, d, i, t, s); u = Vt(h, this.minLon_, this.maxLon_), o = 0; while (u != this.maxLon_ && o++ < f)u = Math.min(u + r, this.maxLon_), s = this.addMeridian_(u, g, d, i, t, s); this.meridians_.length = s, this.meridiansLabels_ && (this.meridiansLabels_.length = s), l = Math.floor(l / r) * r, a = Vt(l, this.minLat_, this.maxLat_), s = this.addParallel_(a, y, v, i, t, 0), o = 0; while (a != this.minLat_ && o++ < f)a = Math.max(a - r, this.minLat_), s = this.addParallel_(a, y, v, i, t, s); a = Vt(l, this.minLat_, this.maxLat_), o = 0; while (a != this.maxLat_ && o++ < f)a = Math.min(a + r, this.maxLat_), s = this.addParallel_(a, y, v, i, t, s); this.parallels_.length = s, this.parallelsLabels_ && (this.parallelsLabels_.length = s); }, iw.prototype.getInterval_ = function (t) { for (var e = this.projectionCenterLonLat_[0], n = this.projectionCenterLonLat_[1], i = -1, r = Math.pow(this.targetSize_ * t, 2), o = [], s = [], a = 0, u = this.intervals_.length; a < u; ++a) { const c = this.intervals_[a] / 2; o[0] = e - c, o[1] = n - c, s[0] = e + c, s[1] = n + c, this.fromLonLatTransform_(o, o), this.fromLonLatTransform_(s, s); const h = Math.pow(s[0] - o[0], 2) + Math.pow(s[1] - o[1], 2); if (h <= r) break; i = this.intervals_[a]; } return i; }, iw.prototype.getMap = function () { return this.map_; }, iw.prototype.getMeridian_ = function (t, e, n, i, r) { const o = Qb(t, e, n, this.projection_, i); let s = this.meridians_[r]; return s ? (s.setFlatCoordinates(vs.XY, o), s.changed()) : s = this.meridians_[r] = new na(o, vs.XY), s; }, iw.prototype.getMeridians = function () { return this.meridians_; }, iw.prototype.getParallel_ = function (t, e, n, i, r) { const o = tw(t, e, n, this.projection_, i); let s = this.parallels_[r]; return s ? (s.setFlatCoordinates(vs.XY, o), s.changed()) : s = new na(o, vs.XY), s; }, iw.prototype.getParallels = function () { return this.parallels_; }, iw.prototype.handlePostCompose_ = function (t) { let e; let n; let i; let r; const o = t.vectorContext; const s = t.frameState; const a = s.extent; const u = s.viewState; const c = u.center; const h = u.projection; const l = u.resolution; const f = s.pixelRatio; const p = l * l / (4 * f * f); const d = !this.projection_ || !Vn(this.projection_, h); for (d && this.updateProjectionInfo_(h), this.createGraticule_(a, c, l, p), o.setFillStrokeStyle(null, this.strokeStyle_), e = 0, n = this.meridians_.length; e < n; ++e)i = this.meridians_[e], o.drawGeometry(i); for (e = 0, n = this.parallels_.length; e < n; ++e)i = this.parallels_[e], o.drawGeometry(i); if (this.meridiansLabels_) for (e = 0, n = this.meridiansLabels_.length; e < n; ++e)r = this.meridiansLabels_[e], this.lonLabelStyle_.setText(r.text), o.setTextStyle(this.lonLabelStyle_), o.drawGeometry(r.geom); if (this.parallelsLabels_) for (e = 0, n = this.parallelsLabels_.length; e < n; ++e)r = this.parallelsLabels_[e], this.latLabelStyle_.setText(r.text), o.setTextStyle(this.latLabelStyle_), o.drawGeometry(r.geom); }, iw.prototype.updateProjectionInfo_ = function (t) { const e = jn('EPSG:4326'); const n = t.getWorldExtent(); const i = Yn(n, e, t); this.maxLat_ = n[3], this.maxLon_ = n[2], this.minLat_ = n[1], this.minLon_ = n[0], this.maxLatP_ = i[3], this.maxLonP_ = i[2], this.minLatP_ = i[1], this.minLonP_ = i[0], this.fromLonLatTransform_ = Un(e, t), this.toLonLatTransform_ = Un(t, e), this.projectionCenterLonLat_ = this.toLonLatTransform_(Ct(t.getExtent())), this.projection_ = t; }, iw.prototype.setMap = function (t) { this.map_ && (xe(this.postcomposeListenerKey_), this.postcomposeListenerKey_ = null, this.map_.render()), t && (this.postcomposeListenerKey_ = _e(t, T_.POSTCOMPOSE, this.handlePostCompose_, this), t.render()), this.map_ = t; }; const rw = iw; const ow = {
      maxLines: { type: Number, default: 100 }, targetSize: { type: Number, default: 100 }, showLabels: { type: Boolean, default: !1 }, lonLabelFormatter: Function, latLabelFormatter: Function, lonLabelPosition: { type: Number, default: 0 }, latLabelPosition: { type: Number, default: 1 }, intervals: { type: Array, default() { return [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]; } },
    }; const sw = { meridians() { const t = this; return this.$graticule && this.rev ? Object(gr.r)(this.getMeridians(), e => t.lineToDataProj(e.getCoordinates())) : []; }, parallels() { const t = this; return this.$graticule && this.rev ? Object(gr.r)(this.getParallels(), e => t.lineToDataProj(e.getCoordinates())) : []; } }; const aw = {
      createOlObject() {
        return new rw({
          maxLines: this.maxLines, targetSize: this.targetSize, showLabels: this.showLabels, strokeStyle: this._strokeStyle, lonLabelFormatter: this.lonLabelFormatter, latLabelFormatter: this.latLabelFormatter, lonLabelPosition: this.lonLabelPosition, latLabelPosition: this.latLabelPosition, lonLabelStyle: this._lonLabelStyle, latLabelStyle: this._latLabelStyle, intervals: this.intervals,
        });
      },
      init() { return Ef.methods.init.call(this); },
      deinit() { return Ef.methods.deinit.call(this); },
      mount() { this.$map && this.$graticule.setMap(this.$map), this.subscribeAll(); },
      unmount() { this.unsubscribeAll(), this.$graticule.setMap(void 0); },
      getMeridians() { return fo(this), this.$graticule.getMeridians(); },
      getParallels() { return fo(this), this.$graticule.getParallels(); },
      setStroke(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._strokeStyle && (this._strokeStyle = t, this.scheduleRefresh()); },
      setText(t) { let e; t = t instanceof Rr.a ? t.$style : t, t && (e = Object(gr.e)(t[this.$options.VM_PROP])); const n = function (t) { return t.componentInstance && t.componentInstance === e; }; t == null && this.$slots.lon == null || Fo()(this.$slots.lon) && this.$slots.lon.some(n) ? t !== this._lonLabelStyle && (this._lonLabelStyle = t, this.scheduleRefresh()) : (t == null && this.$slots.lat == null || Fo()(this.$slots.lat) && this.$slots.lat.some(n)) && t !== this._latLabelStyle && (this._latLabelStyle = t, this.scheduleRefresh()); },
      getServices() { const t = this; return xl(Ef.methods.getServices.call(this), { get stylesContainer() { return t; } }); },
      refresh() { return this.recreate(); },
      subscribeAll() { const t = this; io(this); const e = 1e3 / 60; const n = ml(this.$map, 'postcompose').pipe(Bh(e)); this.subscribeTo(n, () => { ++t.rev; }); },
    }; const uw = Sf(ur()(ow), () => function () { this.scheduleRefresh(); }); const cw = {
      name: 'vl-graticule', mixins: [Ef, Lf, $c], props: ow, computed: sw, methods: aw, watch: uw, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } }, created() { const t = this; zc()(this, { $graticule: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } } }); },
    }; const hw = cw; const lw = function () { const t = this; const e = t.$createElement; const n = t._self._c || e; return n('i', { class: t.$options.name, staticStyle: { display: 'none !important' } }, [t._t('lon'), t._v(' '), t._t('lat'), t._v(' '), t._t('stroke')], 2); }; const fw = []; const pw = void 0; const dw = void 0; const vw = void 0; const gw = !1;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function yw(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'graticule.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var mw = yw({ render: lw, staticRenderFns: fw }, pw, hw, dw, gw, vw, void 0, void 0); function _w(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; _w.installed || (_w.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(mw, e), t.component(mw.name, mw)); } var bw = _w; const ww = { LAYERS: 'layers' }; const xw = (function (t) { function e(e) { const n = e || {}; const i = qt({}, n); delete i.layers; let r = n.layers; t.call(this, i), this.layersListenerKeys_ = [], this.listenerKeys_ = {}, _e(this, pi(ww.LAYERS), this.handleLayersChanged_, this), r ? Array.isArray(r) ? r = new hm(r.slice(), { unique: !0 }) : Q(typeof r.getArray === 'function', 43) : r = new hm(void 0, { unique: !0 }), this.setLayers(r); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleLayerChange_ = function () { this.changed(); }, e.prototype.handleLayersChanged_ = function () { this.layersListenerKeys_.forEach(xe), this.layersListenerKeys_.length = 0; const t = this.getLayers(); for (const e in this.layersListenerKeys_.push(_e(t, sm.ADD, this.handleLayersAdd_, this), _e(t, sm.REMOVE, this.handleLayersRemove_, this)), this.listenerKeys_) this.listenerKeys_[e].forEach(xe); Zt(this.listenerKeys_); for (let n = t.getArray(), i = 0, r = n.length; i < r; i++) { const o = n[i]; this.listenerKeys_[H(o)] = [_e(o, ai.PROPERTYCHANGE, this.handleLayerChange_, this), _e(o, Ae.CHANGE, this.handleLayerChange_, this)]; } this.changed(); }, e.prototype.handleLayersAdd_ = function (t) { const e = t.element; this.listenerKeys_[H(e)] = [_e(e, ai.PROPERTYCHANGE, this.handleLayerChange_, this), _e(e, Ae.CHANGE, this.handleLayerChange_, this)], this.changed(); }, e.prototype.handleLayersRemove_ = function (t) { const e = t.element; const n = H(e); this.listenerKeys_[n].forEach(xe), delete this.listenerKeys_[n], this.changed(); }, e.prototype.getLayers = function () { return this.get(ww.LAYERS); }, e.prototype.setLayers = function (t) { this.set(ww.LAYERS, t); }, e.prototype.getLayersArray = function (t) { const e = void 0 !== t ? t : []; return this.getLayers().forEach((t) => { t.getLayersArray(e); }), e; }, e.prototype.getLayerStatesArray = function (t) { const e = void 0 !== t ? t : []; const n = e.length; this.getLayers().forEach((t) => { t.getLayerStatesArray(e); }); for (let i = this.getLayerState(), r = n, o = e.length; r < o; r++) { const s = e[r]; s.opacity *= i.opacity, s.visible = s.visible && i.visible, s.maxResolution = Math.min(s.maxResolution, i.maxResolution), s.minResolution = Math.max(s.minResolution, i.minResolution), void 0 !== i.extent && (void 0 !== s.extent ? s.extent = Lt(s.extent, i.extent) : s.extent = i.extent); } return e; }, e.prototype.getSourceState = function () { return vi.READY; }, e; }(kp)); const Ew = xw; const Sw = {
      createLayer() {
        return new Ew({
          id: this.id, minResolution: this.minResolution, maxResolution: this.maxResolution, opacity: this.opacity, visible: this.visible, extent: this.extent, zIndex: this.zIndex,
        });
      },
      getLayersTarget() { return ao(this), this._layersTarget == null && (this._layersTarget = new Dd(this.$layer.getLayers(), (t => t.get('id')))), this._layersTarget; },
      getServices() { return xl(Ap.methods.getServices.call(this), Dp.methods.getServices.call(this)); },
    }; const Tw = { name: 'vl-layer-group', mixins: [Ap, Dp], methods: Sw }; const Ow = Tw; const Cw = void 0; const Rw = void 0; const Iw = void 0; const Pw = void 0; function Lw(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'layer.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Aw = Lw({}, Cw, Ow, Rw, Pw, Iw, void 0, void 0); function Fw(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Fw.installed || (Fw.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Aw, e), t.component(Aw.name, Aw)); } var jw = Fw; const kw = {
      src: { type: String, required: !0 }, size: { type: Array, validator(t) { return t.length === 2; } }, anchor: { type: Array, default() { return [0.5, 0.5]; }, validator(t) { return t.length === 2; } }, anchorOrigin: { type: String, default: 'top-left' }, anchorXUnits: { type: String, default: 'fraction' }, anchorYUnits: { type: String, default: 'fraction' }, color: [Array, String], crossOrigin: String, offset: { type: Array, default() { return [0, 0]; }, validator(t) { return t.length === 2; } }, offsetOrigin: { type: String, default: 'top-left' }, opacity: { type: Number, default: 1 }, scale: { type: Number, default: 1 }, rotateWithView: { type: Boolean, default: !1 }, rotation: { type: Number, default: 0 },
    }; const Mw = {
      createStyle() {
        return new og({
          anchor: this.anchor, anchorOrigin: this.anchorOrigin, anchorXUnits: this.anchorXUnits, anchorYUnits: this.anchorYUnits, color: this.color, crossOrigin: this.crossOrigin, offset: this.offset, offsetOrigin: this.offsetOrigin, opacity: this.opacity, scale: this.scale, rotateWithView: this.rotateWithView, rotation: this.rotation, size: this.size, src: this.src,
        });
      },
    }; const Nw = {
      src(t) { this.$style && !Object(gr.j)(t, this.$style.getSrc()) && this.scheduleRefresh(); }, size(t) { this.$style && !Object(gr.j)(t, this.$style.getSize()) && this.scheduleRefresh(); }, anchor(t) { this.$style && !Object(gr.j)(t, this.$style.getAnchor()) && this.scheduleRefresh(); }, scale(t) { this.$style && !Object(gr.j)(t, this.$style.getScale()) && this.scheduleRefresh(); },
    }; const Dw = {
      name: 'vl-style-icon', mixins: [ap], props: kw, methods: Mw, watch: Nw,
    }; const $w = Dw; const Gw = void 0; const Vw = void 0; const Bw = void 0; const Uw = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function zw(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Yw = zw({}, Gw, $w, Vw, Uw, Bw, void 0, void 0); function Xw(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Xw.installed || (Xw.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Yw, e), t.component(Yw.name, Yw)); } var Ww = Xw; const Kw = (function (t) { function e(e) { const n = e || {}; t.call(this, n), this.type = S_.IMAGE; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(R_)); Kw.prototype.getSource; const Hw = Kw; const qw = {}; const Zw = {
      createLayer() {
        return new Hw({
          id: this.id, minResolution: this.minResolution, maxResolution: this.maxResolution, opacity: this.opacity, visible: this.visible, extent: this.extent, zIndex: this.zIndex, source: this._source,
        });
      },
    }; const Jw = {
      name: 'vl-layer-image', mixins: [Ap], props: qw, methods: Zw,
    }; const Qw = Jw; const tx = void 0; const ex = void 0; const nx = void 0; const ix = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function rx(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'layer.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var ox = rx({}, tx, Qw, ex, ix, nx, void 0, void 0); function sx(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; sx.installed || (sx.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(ox, e), t.component(ox.name, ox)); } var ax = sx; const ux = (function (t) { function e(e, n, i, r) { t.call(this), this.extent = e, this.pixelRatio_ = i, this.resolution = n, this.state = r; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.changed = function () { this.dispatchEvent(Ae.CHANGE); }, e.prototype.getExtent = function () { return this.extent; }, e.prototype.getImage = function () { return W(); }, e.prototype.getPixelRatio = function () { return this.pixelRatio_; }, e.prototype.getResolution = function () { return this.resolution; }, e.prototype.getState = function () { return this.state; }, e.prototype.load = function () { W(); }, e; }(Le)); const cx = ux; const hx = (function (t) { function e(e, n, i, r, o, s) { t.call(this, e, n, i, _v.IDLE), this.src_ = r, this.image_ = new Image(), o !== null && (this.image_.crossOrigin = o), this.imageListenerKeys_ = null, this.state = _v.IDLE, this.imageLoadFunction_ = s; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getImage = function () { return this.image_; }, e.prototype.handleImageError_ = function () { this.state = _v.ERROR, this.unlistenImage_(), this.changed(); }, e.prototype.handleImageLoad_ = function () { void 0 === this.resolution && (this.resolution = Pt(this.extent) / this.image_.height), this.state = _v.LOADED, this.unlistenImage_(), this.changed(); }, e.prototype.load = function () { this.state != _v.IDLE && this.state != _v.ERROR || (this.state = _v.LOADING, this.changed(), this.imageListenerKeys_ = [be(this.image_, Ae.ERROR, this.handleImageError_, this), be(this.image_, Ae.LOAD, this.handleImageLoad_, this)], this.imageLoadFunction_(this, this.src_)); }, e.prototype.setImage = function (t) { this.image_ = t; }, e.prototype.unlistenImage_ = function () { this.imageListenerKeys_.forEach(xe), this.imageListenerKeys_ = null; }, e; }(cx)); const lx = hx; const fx = (function (t) { function e(e, n, i, r, o, s) { const a = e.getExtent(); const u = n.getExtent(); const c = u ? Lt(i, u) : i; const h = Ct(c); const l = Wn(e, n, h, r); const f = re; const p = new Qn(e, n, c, a, l * f); const d = p.calculateSourceExtent(); const v = s(d, l, o); let g = _v.LOADED; v && (g = _v.IDLE); const y = v ? v.getPixelRatio() : 1; t.call(this, i, r, y, g), this.targetProj_ = n, this.maxSourceExtent_ = a, this.triangulation_ = p, this.targetResolution_ = r, this.targetExtent_ = i, this.sourceImage_ = v, this.sourcePixelRatio_ = y, this.canvas_ = null, this.sourceListenerKey_ = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.state == _v.LOADING && this.unlistenSource_(), t.prototype.disposeInternal.call(this); }, e.prototype.getImage = function () { return this.canvas_; }, e.prototype.getProjection = function () { return this.targetProj_; }, e.prototype.reproject_ = function () { const t = this.sourceImage_.getState(); if (t == _v.LOADED) { const e = jt(this.targetExtent_) / this.targetResolution_; const n = Pt(this.targetExtent_) / this.targetResolution_; this.canvas_ = Hn(e, n, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{ extent: this.sourceImage_.getExtent(), image: this.sourceImage_.getImage() }], 0); } this.state = t, this.changed(); }, e.prototype.load = function () { if (this.state == _v.IDLE) { this.state = _v.LOADING, this.changed(); const t = this.sourceImage_.getState(); t == _v.LOADED || t == _v.ERROR ? this.reproject_() : (this.sourceListenerKey_ = _e(this.sourceImage_, Ae.CHANGE, function (t) { const e = this.sourceImage_.getState(); e != _v.LOADED && e != _v.ERROR || (this.unlistenSource_(), this.reproject_()); }, this), this.sourceImage_.load()); } }, e.prototype.unlistenSource_ = function () { xe(this.sourceListenerKey_), this.sourceListenerKey_ = null; }, e; }(cx)); const px = fx; const dx = { IMAGELOADSTART: 'imageloadstart', IMAGELOADEND: 'imageloadend', IMAGELOADERROR: 'imageloaderror' }; const vx = (function (t) { function e(e, n) { t.call(this, e), this.image = n; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const gx = (function (t) { function e(e) { t.call(this, { attributions: e.attributions, projection: e.projection, state: e.state }), this.resolutions_ = void 0 !== e.resolutions ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getResolutions = function () { return this.resolutions_; }, e.prototype.findNearestResolution = function (t) { if (this.resolutions_) { const e = Ci(this.resolutions_, t, 0); t = this.resolutions_[e]; } return t; }, e.prototype.getImage = function (t, e, n, i) { const r = this.getProjection(); if (oe && r && i && !Vn(r, i)) { if (this.reprojectedImage_) { if (this.reprojectedRevision_ == this.getRevision() && Vn(this.reprojectedImage_.getProjection(), i) && this.reprojectedImage_.getResolution() == e && yt(this.reprojectedImage_.getExtent(), t)) return this.reprojectedImage_; this.reprojectedImage_.dispose(), this.reprojectedImage_ = null; } return this.reprojectedImage_ = new px(r, i, t, e, n, ((t, e, n) => this.getImageInternal(t, e, n, r))), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_; } return r && (i = r), this.getImageInternal(t, e, n, i); }, e.prototype.getImageInternal = function (t, e, n, i) { return W(); }, e.prototype.handleImageChange = function (t) { const e = t.target; switch (e.getState()) { case _v.LOADING: this.loading = !0, this.dispatchEvent(new vx(dx.IMAGELOADSTART, e)); break; case _v.LOADED: this.loading = !1, this.dispatchEvent(new vx(dx.IMAGELOADEND, e)); break; case _v.ERROR: this.loading = !1, this.dispatchEvent(new vx(dx.IMAGELOADERROR, e)); break; default: } }, e; }(mi)); function yx(t, e) { t.getImage().src = e; } const mx = gx; const _x = (function (t) { function e(e) { const n = void 0 !== e.crossOrigin ? e.crossOrigin : null; const i = void 0 !== e.imageLoadFunction ? e.imageLoadFunction : yx; t.call(this, { attributions: e.attributions, projection: jn(e.projection) }), this.url_ = e.url, this.imageExtent_ = e.imageExtent, this.image_ = new lx(this.imageExtent_, void 0, 1, this.url_, n, i), this.imageSize_ = e.imageSize ? e.imageSize : null, _e(this.image_, Ae.CHANGE, this.handleImageChange, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getImageExtent = function () { return this.imageExtent_; }, e.prototype.getImageInternal = function (t, e, n, i) { return kt(t, this.image_.getExtent()) ? this.image_ : null; }, e.prototype.getUrl = function () { return this.url_; }, e.prototype.handleImageChange = function (e) { if (this.image_.getState() == _v.LOADED) { let n; let i; const r = this.image_.getExtent(); const o = this.image_.getImage(); this.imageSize_ ? (n = this.imageSize_[0], i = this.imageSize_[1]) : (n = o.width, i = o.height); const s = Pt(r) / i; const a = Math.ceil(jt(r) / s); if (a != n) { const u = ke(a, i); const c = u.canvas; u.drawImage(o, 0, 0, n, i, 0, 0, c.width, c.height), this.image_.setImage(c); } }t.prototype.handleImageChange.call(this, e); }, e; }(mx)); const bx = _x; const wx = {
      extent: { type: Array, required: !0, validator(t) { return t.length === 4; } }, loadFunc: Function, size: { type: Array, validator(t) { return t.length === 2; } }, url: { type: String, required: !0, validator(t) { return !!t.length; } },
    }; const xx = {
      createSource() {
        return new bx({
          attributions: this.attributions, crossOrigin: this.crossOrigin, imageExtent: this.extent, imageLoadFunction: this.loadFunc, logo: this.logo, projection: this.projection, imageSize: this.size, url: this.urlTmpl,
        });
      },
    }; const Ex = Sf(ur()(wx), () => function () { this.scheduleRecreate(); }); const Sx = {
      name: 'vl-source-image-static', mixins: [Zf, Ed], props: wx, methods: xx, watch: Ex,
    }; const Tx = Sx; const Ox = void 0; const Cx = void 0; const Rx = void 0; const Ix = void 0; function Px(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Lx = Px({}, Ox, Tx, Cx, Ix, Rx, void 0, void 0); function Ax(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Ax.installed || (Ax.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Lx, e), t.component(Lx.name, Lx)); } var Fx = Ax; const jx = '1.3.0'; const kx = {
      CARMENTA_SERVER: 'carmentaserver', GEOSERVER: 'geoserver', MAPSERVER: 'mapserver', QGIS: 'qgis',
    }; const Mx = [101, 101]; const Nx = (function (t) {
      function e(e) { const n = e || {}; t.call(this, { attributions: n.attributions, projection: n.projection, resolutions: n.resolutions }), this.crossOrigin_ = void 0 !== n.crossOrigin ? n.crossOrigin : null, this.url_ = n.url, this.imageLoadFunction_ = void 0 !== n.imageLoadFunction ? n.imageLoadFunction : yx, this.params_ = n.params || {}, this.v13_ = !0, this.updateV13_(), this.serverType_ = n.serverType, this.hidpi_ = void 0 === n.hidpi || n.hidpi, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = void 0 !== n.ratio ? n.ratio : 1.5; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getGetFeatureInfoUrl = function (t, e, n, i) {
        if (void 0 !== this.url_) {
          const r = jn(n); const o = this.getProjection(); o && o !== r && (e = Wn(o, r, t, e), t = zn(t, r, o)); const s = It(t, e, 0, Mx); const a = {
            SERVICE: 'WMS', VERSION: jx, REQUEST: 'GetFeatureInfo', FORMAT: 'image/png', TRANSPARENT: !0, QUERY_LAYERS: this.params_.LAYERS,
          }; qt(a, this.params_, i); const u = Math.floor((t[0] - s[0]) / e); const c = Math.floor((s[3] - t[1]) / e); return a[this.v13_ ? 'I' : 'X'] = u, a[this.v13_ ? 'J' : 'Y'] = c, this.getRequestUrl_(s, Mx, 1, o || r, a);
        }
      }, e.prototype.getParams = function () { return this.params_; }, e.prototype.getImageInternal = function (t, e, n, i) {
        if (void 0 === this.url_) return null; e = this.findNearestResolution(e), n == 1 || this.hidpi_ && void 0 !== this.serverType_ || (n = 1); const r = e / n; const o = Ct(t); const s = Math.ceil(jt(t) / r); const a = Math.ceil(Pt(t) / r); const u = It(o, r, 0, [s, a]); const c = Math.ceil(this.ratio_ * jt(t) / r); const h = Math.ceil(this.ratio_ * Pt(t) / r); const l = It(o, r, 0, [c, h]); const f = this.image_; if (f && this.renderedRevision_ == this.getRevision() && f.getResolution() == e && f.getPixelRatio() == n && ut(f.getExtent(), u)) return f; const p = {
          SERVICE: 'WMS', VERSION: jx, REQUEST: 'GetMap', FORMAT: 'image/png', TRANSPARENT: !0,
        }; qt(p, this.params_), this.imageSize_[0] = Math.round(jt(l) / r), this.imageSize_[1] = Math.round(Pt(l) / r); const d = this.getRequestUrl_(l, this.imageSize_, n, i, p); return this.image_ = new lx(l, e, n, d, this.crossOrigin_, this.imageLoadFunction_), this.renderedRevision_ = this.getRevision(), _e(this.image_, Ae.CHANGE, this.handleImageChange, this), this.image_;
      }, e.prototype.getImageLoadFunction = function () { return this.imageLoadFunction_; }, e.prototype.getRequestUrl_ = function (t, e, n, i, r) { if (Q(void 0 !== this.url_, 9), r[this.v13_ ? 'CRS' : 'SRS'] = i.getCode(), 'STYLES' in this.params_ || (r.STYLES = ''), n != 1) switch (this.serverType_) { case kx.GEOSERVER: var o = 90 * n + 0.5 | 0; 'FORMAT_OPTIONS' in r ? r.FORMAT_OPTIONS += `;dpi:${o}` : r.FORMAT_OPTIONS = `dpi:${o}`; break; case kx.MAPSERVER: r.MAP_RESOLUTION = 90 * n; break; case kx.CARMENTA_SERVER: case kx.QGIS: r.DPI = 90 * n; break; default: Q(!1, 8); break; }r.WIDTH = e[0], r.HEIGHT = e[1]; let s; const a = i.getAxisOrientation(); return s = this.v13_ && a.substr(0, 2) == 'ne' ? [t[1], t[0], t[3], t[2]] : t, r.BBOX = s.join(','), Qi(this.url_, r); }, e.prototype.getUrl = function () { return this.url_; }, e.prototype.setImageLoadFunction = function (t) { this.image_ = null, this.imageLoadFunction_ = t, this.changed(); }, e.prototype.setUrl = function (t) { t != this.url_ && (this.url_ = t, this.image_ = null, this.changed()); }, e.prototype.updateParams = function (t) { qt(this.params_, t), this.updateV13_(), this.image_ = null, this.changed(); }, e.prototype.updateV13_ = function () { const t = this.params_.VERSION || jx; this.v13_ = Hy(t, '1.3') >= 0; }, e;
    }(mx)); const Dx = Nx; const $x = {
      hidpi: { type: Boolean, default: !0 }, serverType: { type: String, validator(t) { return !t | Gm()(kx).includes(t); } }, imageLoadFunction: Function, ratio: { type: Number, default: 1.5 }, resolutions: Array, url: { type: String, required: !0, validator(t) { return !!t.length; } },
    }; const Gx = {
      createOlObject() {
        return new Dx({
          attributions: this.attributions, crossOrigin: this.crossOrigin, hidpi: this.hidpi, serverType: this.serverType, imageLoadFunction: this.imageLoadFunction, params: this.allParams, projection: this.projection, ratio: this.ratio, resolutions: this.resolutions, url: this.urlTmpl,
        });
      },
    }; const Vx = {
      name: 'vl-source-image-wms', mixins: [Zf, Ed, Ng], props: $x, methods: Gx,
    }; const Bx = Vx; const Ux = void 0; const zx = void 0; const Yx = void 0; const Xx = void 0; function Wx(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Kx = Wx({}, Ux, Bx, zx, Xx, Yx, void 0, void 0); function Hx(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Hx.installed || (Hx.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Kx, e), t.component(Kx.name, Kx)); } var qx = Hx; const Zx = {}; const Jx = { type: Object(gr.c)(To.LINE_STRING) }; const Qx = { createGeometry() { return new na(this.toViewProj(this.coordinates)); } }; const tE = {
      name: 'vl-geom-line-string', mixins: [$f], props: Zx, computed: Jx, methods: Qx,
    }; const eE = tE; const nE = void 0; const iE = void 0; const rE = void 0; const oE = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function sE(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var aE = sE({}, nE, eE, iE, oE, rE, void 0, void 0); function uE(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; uE.installed || (uE.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(aE, e), t.component(aE.name, aE)); } var cE = uE; const hE = (function (t) { function e(e) { t.call(this), this.element = e.element ? e.element : null, this.target_ = null, this.map_ = null, this.listenerKeys = [], this.render = e.render ? e.render : Oe, e.target && this.setTarget(e.target); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { $e(this.element), t.prototype.disposeInternal.call(this); }, e.prototype.getMap = function () { return this.map_; }, e.prototype.setMap = function (t) { this.map_ && $e(this.element); for (let e = 0, n = this.listenerKeys.length; e < n; ++e)xe(this.listenerKeys[e]); if (this.listenerKeys.length = 0, this.map_ = t, this.map_) { const i = this.target_ ? this.target_ : t.getOverlayContainerStopEvent(); i.appendChild(this.element), this.render !== Oe && this.listenerKeys.push(_e(t, $p.POSTRENDER, this.render, this)), t.render(); } }, e.prototype.setTarget = function (t) { this.target_ = typeof t === 'string' ? document.getElementById(t) : t; }, e; }(di)); const lE = hE; const fE = (function (t) {
      function e(e) {
        const n = e || {}; t.call(this, { element: document.createElement('div'), render: n.render || pE, target: n.target }), this.ulElement_ = document.createElement('ul'), this.collapsed_ = void 0 === n.collapsed || n.collapsed, this.overrideCollapsible_ = void 0 !== n.collapsible, this.collapsible_ = void 0 === n.collapsible || n.collapsible, this.collapsible_ || (this.collapsed_ = !1); const i = void 0 !== n.className ? n.className : 'ol-attribution'; const r = void 0 !== n.tipLabel ? n.tipLabel : 'Attributions'; const
          o = void 0 !== n.collapseLabel ? n.collapseLabel : '»'; typeof o === 'string' ? (this.collapseLabel_ = document.createElement('span'), this.collapseLabel_.textContent = o) : this.collapseLabel_ = o; const s = void 0 !== n.label ? n.label : 'i'; typeof s === 'string' ? (this.label_ = document.createElement('span'), this.label_.textContent = s) : this.label_ = s; const a = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_; const u = document.createElement('button'); u.setAttribute('type', 'button'), u.title = r, u.appendChild(a), _e(u, Ae.CLICK, this.handleClick_, this); const c = `${i} ${Up} ${zp}${this.collapsed_ && this.collapsible_ ? ` ${Yp}` : ''}${this.collapsible_ ? '' : ' ol-uncollapsible'}`; const h = this.element; h.className = c, h.appendChild(this.ulElement_), h.appendChild(u), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.collectSourceAttributions_ = function (t) { for (var e = {}, n = [], i = t.layerStatesArray, r = t.viewState.resolution, o = 0, s = i.length; o < s; ++o) { const a = i[o]; if (C_(a, r)) { const u = a.layer.getSource(); if (u) { const c = u.getAttributions(); if (c) { const h = c(t); if (h) if (this.overrideCollapsible_ || !1 !== u.getAttributionsCollapsible() || this.setCollapsible(!1), Array.isArray(h)) for (let l = 0, f = h.length; l < f; ++l)h[l] in e || (n.push(h[l]), e[h[l]] = !0); else h in e || (n.push(h), e[h] = !0); } } } } return n; }, e.prototype.updateElement_ = function (t) { if (t) { const e = this.collectSourceAttributions_(t); const n = e.length > 0; if (this.renderedVisible_ != n && (this.element.style.display = n ? '' : 'none', this.renderedVisible_ = n), !Li(e, this.renderedAttributions_)) { Ge(this.ulElement_); for (let i = 0, r = e.length; i < r; ++i) { const o = document.createElement('li'); o.innerHTML = e[i], this.ulElement_.appendChild(o); } this.renderedAttributions_ = e; } } else this.renderedVisible_ && (this.element.style.display = 'none', this.renderedVisible_ = !1); }, e.prototype.handleClick_ = function (t) { t.preventDefault(), this.handleToggle_(); }, e.prototype.handleToggle_ = function () { this.element.classList.toggle(Yp), this.collapsed_ ? De(this.collapseLabel_, this.label_) : De(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_; }, e.prototype.getCollapsible = function () { return this.collapsible_; }, e.prototype.setCollapsible = function (t) { this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle('ol-uncollapsible'), !t && this.collapsed_ && this.handleToggle_()); }, e.prototype.setCollapsed = function (t) { this.collapsible_ && this.collapsed_ !== t && this.handleToggle_(); }, e.prototype.getCollapsed = function () { return this.collapsed_; }, e;
    }(lE)); function pE(t) { this.updateElement_(t.frameState); } const dE = fE; const vE = (function (t) {
      function e(e) {
        const n = e || {}; t.call(this, { element: document.createElement('div'), render: n.render || gE, target: n.target }); const i = void 0 !== n.className ? n.className : 'ol-rotate'; const
          r = void 0 !== n.label ? n.label : '⇧'; this.label_ = null, typeof r === 'string' ? (this.label_ = document.createElement('span'), this.label_.className = 'ol-compass', this.label_.textContent = r) : (this.label_ = r, this.label_.classList.add('ol-compass')); const o = n.tipLabel ? n.tipLabel : 'Reset rotation'; const
          s = document.createElement('button'); s.className = `${i}-reset`, s.setAttribute('type', 'button'), s.title = o, s.appendChild(this.label_), _e(s, Ae.CLICK, this.handleClick_, this); const a = `${i} ${Up} ${zp}`; const u = this.element; u.className = a, u.appendChild(s), this.callResetNorth_ = n.resetNorth ? n.resetNorth : void 0, this.duration_ = void 0 !== n.duration ? n.duration : 250, this.autoHide_ = void 0 === n.autoHide || n.autoHide, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Vp);
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleClick_ = function (t) { t.preventDefault(), void 0 !== this.callResetNorth_ ? this.callResetNorth_() : this.resetNorth_(); }, e.prototype.resetNorth_ = function () { const t = this.getMap(); const e = t.getView(); e && void 0 !== e.getRotation() && (this.duration_ > 0 ? e.animate({ rotation: 0, duration: this.duration_, easing: ue }) : e.setRotation(0)); }, e;
    }(lE)); function gE(t) { const e = t.frameState; if (e) { const n = e.viewState.rotation; if (n != this.rotation_) { const i = `rotate(${n}rad)`; if (this.autoHide_) { const r = this.element.classList.contains(Vp); r || n !== 0 ? r && n !== 0 && this.element.classList.remove(Vp) : this.element.classList.add(Vp); } this.label_.style.msTransform = i, this.label_.style.webkitTransform = i, this.label_.style.transform = i; } this.rotation_ = n; } } const yE = vE; const mE = (function (t) {
      function e(e) {
        const n = e || {}; t.call(this, { element: document.createElement('div'), target: n.target }); const i = void 0 !== n.className ? n.className : 'ol-zoom'; const r = void 0 !== n.delta ? n.delta : 1; const o = void 0 !== n.zoomInLabel ? n.zoomInLabel : '+'; const s = void 0 !== n.zoomOutLabel ? n.zoomOutLabel : '−'; const a = void 0 !== n.zoomInTipLabel ? n.zoomInTipLabel : 'Zoom in'; const u = void 0 !== n.zoomOutTipLabel ? n.zoomOutTipLabel : 'Zoom out'; const
          c = document.createElement('button'); c.className = `${i}-in`, c.setAttribute('type', 'button'), c.title = a, c.appendChild(typeof o === 'string' ? document.createTextNode(o) : o), _e(c, Ae.CLICK, this.handleClick_.bind(this, r)); const h = document.createElement('button'); h.className = `${i}-out`, h.setAttribute('type', 'button'), h.title = u, h.appendChild(typeof s === 'string' ? document.createTextNode(s) : s), _e(h, Ae.CLICK, this.handleClick_.bind(this, -r)); const l = `${i} ${Up} ${zp}`; const f = this.element; f.className = l, f.appendChild(c), f.appendChild(h), this.duration_ = void 0 !== n.duration ? n.duration : 250;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleClick_ = function (t, e) { e.preventDefault(), this.zoomByDelta_(t); }, e.prototype.zoomByDelta_ = function (t) { const e = this.getMap(); const n = e.getView(); if (n) { const i = n.getResolution(); if (i) { const r = n.constrainResolution(i, t); this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({ resolution: r, duration: this.duration_, easing: ue })) : n.setResolution(r); } } }, e;
    }(lE)); const _E = mE; function bE(t) { const e = t || {}; const n = new hm(); const i = void 0 === e.zoom || e.zoom; i && n.push(new _E(e.zoomOptions)); const r = void 0 === e.rotate || e.rotate; r && n.push(new yE(e.rotateOptions)); const o = void 0 === e.attribution || e.attribution; return o && n.push(new dE(e.attributionOptions)), n; } const wE = {
      POINTERMOVE: 'pointermove', POINTERDOWN: 'pointerdown', POINTERUP: 'pointerup', POINTEROVER: 'pointerover', POINTEROUT: 'pointerout', POINTERENTER: 'pointerenter', POINTERLEAVE: 'pointerleave', POINTERCANCEL: 'pointercancel',
    }; const xE = ['', 'unavailable', 'touch', 'pen', 'mouse']; function EE(t) { this.pointerMap[t.pointerId.toString()] = t; const e = this.prepareEvent_(t); this.dispatcher.down(e, t); } function SE(t) { const e = this.prepareEvent_(t); this.dispatcher.move(e, t); } function TE(t) { const e = this.prepareEvent_(t); this.dispatcher.up(e, t), this.cleanup(t.pointerId); } function OE(t) { const e = this.prepareEvent_(t); this.dispatcher.leaveOut(e, t); } function CE(t) { const e = this.prepareEvent_(t); this.dispatcher.enterOver(e, t); } function RE(t) { const e = this.prepareEvent_(t); this.dispatcher.cancel(e, t), this.cleanup(t.pointerId); } function IE(t) { const e = this.dispatcher.makeEvent('lostpointercapture', t, t); this.dispatcher.dispatchEvent(e); } function PE(t) { const e = this.dispatcher.makeEvent('gotpointercapture', t, t); this.dispatcher.dispatchEvent(e); } const LE = (function (t) {
      function e(e) {
        const n = {
          MSPointerDown: EE, MSPointerMove: SE, MSPointerUp: TE, MSPointerOut: OE, MSPointerOver: CE, MSPointerCancel: RE, MSGotPointerCapture: PE, MSLostPointerCapture: IE,
        }; t.call(this, e, n), this.pointerMap = e.pointerMap;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvent_ = function (t) { let e = t; return typeof t.pointerType === 'number' && (e = this.dispatcher.cloneEvent(t, t), e.pointerType = xE[t.pointerType]), e; }, e.prototype.cleanup = function (t) { delete this.pointerMap[t.toString()]; }, e;
    }(u_)); const AE = LE; function FE(t) { this.dispatcher.fireNativeEvent(t); } function jE(t) { this.dispatcher.fireNativeEvent(t); } function kE(t) { this.dispatcher.fireNativeEvent(t); } function ME(t) { this.dispatcher.fireNativeEvent(t); } function NE(t) { this.dispatcher.fireNativeEvent(t); } function DE(t) { this.dispatcher.fireNativeEvent(t); } function $E(t) { this.dispatcher.fireNativeEvent(t); } function GE(t) { this.dispatcher.fireNativeEvent(t); } const VE = (function (t) {
      function e(e) {
        const n = {
          pointerdown: FE, pointermove: jE, pointerup: kE, pointerout: ME, pointerover: NE, pointercancel: DE, gotpointercapture: GE, lostpointercapture: $E,
        }; t.call(this, e, n);
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
    }(u_)); const BE = VE; let UE = !1; const zE = (function (t) { function e(e, n, i) { t.call(this, e), this.originalEvent = n; const r = i || {}; this.buttons = YE(r), this.pressure = XE(r, this.buttons), this.bubbles = 'bubbles' in r && r.bubbles, this.cancelable = 'cancelable' in r && r.cancelable, this.view = 'view' in r ? r.view : null, this.detail = 'detail' in r ? r.detail : null, this.screenX = 'screenX' in r ? r.screenX : 0, this.screenY = 'screenY' in r ? r.screenY : 0, this.clientX = 'clientX' in r ? r.clientX : 0, this.clientY = 'clientY' in r ? r.clientY : 0, this.ctrlKey = 'ctrlKey' in r && r.ctrlKey, this.altKey = 'altKey' in r && r.altKey, this.shiftKey = 'shiftKey' in r && r.shiftKey, this.metaKey = 'metaKey' in r && r.metaKey, this.button = 'button' in r ? r.button : 0, this.relatedTarget = 'relatedTarget' in r ? r.relatedTarget : null, this.pointerId = 'pointerId' in r ? r.pointerId : 0, this.width = 'width' in r ? r.width : 0, this.height = 'height' in r ? r.height : 0, this.tiltX = 'tiltX' in r ? r.tiltX : 0, this.tiltY = 'tiltY' in r ? r.tiltY : 0, this.pointerType = 'pointerType' in r ? r.pointerType : '', this.hwTimestamp = 'hwTimestamp' in r ? r.hwTimestamp : 0, this.isPrimary = 'isPrimary' in r && r.isPrimary, n.preventDefault && (this.preventDefault = function () { n.preventDefault(); }); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); function YE(t) { let e; if (t.buttons || UE)e = t.buttons; else switch (t.which) { case 1: e = 1; break; case 2: e = 4; break; case 3: e = 2; break; default: e = 0; } return e; } function XE(t, e) { let n = 0; return n = t.pressure ? t.pressure : e ? 0.5 : 0, n; }(function () { try { const t = new MouseEvent('click', { buttons: 1 }); UE = t.buttons === 1; } catch (e) {} }()); const WE = zE; const KE = 200; const HE = 'touch'; function qE(t) { this.vacuumTouches_(t), this.setPrimaryTouch_(t.changedTouches[0]), this.dedupSynthMouse_(t), this.clickCount_++, this.processTouches_(t, this.overDown_); } function ZE(t) { this.processTouches_(t, this.moveOverOut_); } function JE(t) { this.dedupSynthMouse_(t), this.processTouches_(t, this.upOut_); } function QE(t) { this.processTouches_(t, this.cancelOut_); } const tS = (function (t) {
      function e(e, n) {
        const i = {
          touchstart: qE, touchmove: ZE, touchend: JE, touchcancel: QE,
        }; t.call(this, e, i), this.pointerMap = e.pointerMap, this.mouseSource = n, this.firstTouchId_ = void 0, this.clickCount_ = 0, this.resetId_, this.dedupTimeout_ = 2500;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isPrimaryTouch_ = function (t) { return this.firstTouchId_ === t.identifier; }, e.prototype.setPrimaryTouch_ = function (t) { const e = Object.keys(this.pointerMap).length; (e === 0 || e === 1 && c_.toString() in this.pointerMap) && (this.firstTouchId_ = t.identifier, this.cancelResetClickCount_()); }, e.prototype.removePrimaryPointer_ = function (t) { t.isPrimary && (this.firstTouchId_ = void 0, this.resetClickCount_()); }, e.prototype.resetClickCount_ = function () { this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), KE); }, e.prototype.resetClickCountHandler_ = function () { this.clickCount_ = 0, this.resetId_ = void 0; }, e.prototype.cancelResetClickCount_ = function () { void 0 !== this.resetId_ && clearTimeout(this.resetId_); }, e.prototype.touchToPointer_ = function (t, e) { const n = this.dispatcher.cloneEvent(t, e); return n.pointerId = e.identifier + 2, n.bubbles = !0, n.cancelable = !0, n.detail = this.clickCount_, n.button = 0, n.buttons = 1, n.width = e.radiusX || 0, n.height = e.radiusY || 0, n.pressure = e.force || 0.5, n.isPrimary = this.isPrimaryTouch_(e), n.pointerType = HE, n.clientX = e.clientX, n.clientY = e.clientY, n.screenX = e.screenX, n.screenY = e.screenY, n; }, e.prototype.processTouches_ = function (t, e) { const n = Array.prototype.slice.call(t.changedTouches); const i = n.length; function r() { t.preventDefault(); } for (let o = 0; o < i; ++o) { const s = this.touchToPointer_(t, n[o]); s.preventDefault = r, e.call(this, t, s); } }, e.prototype.findTouch_ = function (t, e) { for (let n = t.length, i = 0; i < n; i++) { const r = t[i]; if (r.identifier === e) return !0; } return !1; }, e.prototype.vacuumTouches_ = function (t) { const e = t.touches; const n = Object.keys(this.pointerMap); const i = n.length; if (i >= e.length) { for (var r = [], o = 0; o < i; ++o) { const s = Number(n[o]); const a = this.pointerMap[s]; s == c_ || this.findTouch_(e, s - 2) || r.push(a.out); } for (let u = 0; u < r.length; ++u) this.cancelOut_(t, r[u]); } }, e.prototype.overDown_ = function (t, e) { this.pointerMap[e.pointerId] = { target: e.target, out: e, outTarget: e.target }, this.dispatcher.over(e, t), this.dispatcher.enter(e, t), this.dispatcher.down(e, t); }, e.prototype.moveOverOut_ = function (t, e) { const n = e; const i = this.pointerMap[n.pointerId]; if (i) { const r = i.out; const o = i.outTarget; this.dispatcher.move(n, t), r && o !== n.target && (r.relatedTarget = n.target, n.relatedTarget = o, r.target = o, n.target ? (this.dispatcher.leaveOut(r, t), this.dispatcher.enterOver(n, t)) : (n.target = o, n.relatedTarget = null, this.cancelOut_(t, n))), i.out = n, i.outTarget = n.target; } }, e.prototype.upOut_ = function (t, e) { this.dispatcher.up(e, t), this.dispatcher.out(e, t), this.dispatcher.leave(e, t), this.cleanUpPointer_(e); }, e.prototype.cancelOut_ = function (t, e) { this.dispatcher.cancel(e, t), this.dispatcher.out(e, t), this.dispatcher.leave(e, t), this.cleanUpPointer_(e); }, e.prototype.cleanUpPointer_ = function (t) { delete this.pointerMap[t.pointerId], this.removePrimaryPointer_(t); }, e.prototype.dedupSynthMouse_ = function (t) { const e = this.mouseSource.lastTouches; const n = t.changedTouches[0]; if (this.isPrimaryTouch_(n)) { const i = [n.clientX, n.clientY]; e.push(i), setTimeout(() => { Pi(e, i); }, this.dedupTimeout_); } }, e;
    }(u_)); const eS = tS; const nS = [['bubbles', !1], ['cancelable', !1], ['view', null], ['detail', null], ['screenX', 0], ['screenY', 0], ['clientX', 0], ['clientY', 0], ['ctrlKey', !1], ['altKey', !1], ['shiftKey', !1], ['metaKey', !1], ['button', 0], ['relatedTarget', null], ['buttons', 0], ['pointerId', 0], ['width', 0], ['height', 0], ['pressure', 0], ['tiltX', 0], ['tiltY', 0], ['pointerType', ''], ['hwTimestamp', 0], ['isPrimary', !1], ['type', ''], ['target', null], ['currentTarget', null], ['which', 0]]; const iS = (function (t) { function e(e) { t.call(this), this.element_ = e, this.pointerMap = {}, this.eventMap_ = {}, this.eventSourceList_ = [], this.registerSources(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.registerSources = function () { if (yv) this.registerSource('native', new BE(this)); else if (mv) this.registerSource('ms', new AE(this)); else { const t = new __(this); this.registerSource('mouse', t), gv && this.registerSource('touch', new eS(this, t)); } this.register_(); }, e.prototype.registerSource = function (t, e) { const n = e; const i = n.getEvents(); i && (i.forEach((t) => { const e = n.getHandlerForEvent(t); e && (this.eventMap_[t] = e.bind(n)); }), this.eventSourceList_.push(n)); }, e.prototype.register_ = function () { for (let t = this.eventSourceList_.length, e = 0; e < t; e++) { const n = this.eventSourceList_[e]; this.addEvents_(n.getEvents()); } }, e.prototype.unregister_ = function () { for (let t = this.eventSourceList_.length, e = 0; e < t; e++) { const n = this.eventSourceList_[e]; this.removeEvents_(n.getEvents()); } }, e.prototype.eventHandler_ = function (t) { const e = t.type; const n = this.eventMap_[e]; n && n(t); }, e.prototype.addEvents_ = function (t) { t.forEach((t) => { _e(this.element_, t, this.eventHandler_, this); }); }, e.prototype.removeEvents_ = function (t) { t.forEach((t) => { we(this.element_, t, this.eventHandler_, this); }); }, e.prototype.cloneEvent = function (t, e) { for (var n = {}, i = 0, r = nS.length; i < r; i++) { const o = nS[i][0]; n[o] = t[o] || e[o] || nS[i][1]; } return n; }, e.prototype.down = function (t, e) { this.fireEvent(wE.POINTERDOWN, t, e); }, e.prototype.move = function (t, e) { this.fireEvent(wE.POINTERMOVE, t, e); }, e.prototype.up = function (t, e) { this.fireEvent(wE.POINTERUP, t, e); }, e.prototype.enter = function (t, e) { t.bubbles = !1, this.fireEvent(wE.POINTERENTER, t, e); }, e.prototype.leave = function (t, e) { t.bubbles = !1, this.fireEvent(wE.POINTERLEAVE, t, e); }, e.prototype.over = function (t, e) { t.bubbles = !0, this.fireEvent(wE.POINTEROVER, t, e); }, e.prototype.out = function (t, e) { t.bubbles = !0, this.fireEvent(wE.POINTEROUT, t, e); }, e.prototype.cancel = function (t, e) { this.fireEvent(wE.POINTERCANCEL, t, e); }, e.prototype.leaveOut = function (t, e) { this.out(t, e), this.contains_(t.target, t.relatedTarget) || this.leave(t, e); }, e.prototype.enterOver = function (t, e) { this.over(t, e), this.contains_(t.target, t.relatedTarget) || this.enter(t, e); }, e.prototype.contains_ = function (t, e) { return !(!t || !e) && t.contains(e); }, e.prototype.makeEvent = function (t, e, n) { return new WE(t, n, e); }, e.prototype.fireEvent = function (t, e, n) { const i = this.makeEvent(t, e, n); this.dispatchEvent(i); }, e.prototype.fireNativeEvent = function (t) { const e = this.makeEvent(t.type, t, t); this.dispatchEvent(e); }, e.prototype.wrapMouseEvent = function (t, e) { const n = this.makeEvent(t, m_(e, this), e); return n; }, e.prototype.disposeInternal = function () { this.unregister_(), t.prototype.disposeInternal.call(this); }, e; }(Le)); const rS = iS; const oS = (function (t) { function e(e, n) { t.call(this), this.map_ = e, this.clickTimeoutId_, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = n ? n * pv : pv, this.down_ = null; const i = this.map_.getViewport(); this.activePointers_ = 0, this.trackedTouches_ = {}, this.pointerEventHandler_ = new rS(i), this.documentPointerEventHandler_ = null, this.pointerdownListenerKey_ = _e(this.pointerEventHandler_, wE.POINTERDOWN, this.handlePointerDown_, this), this.relayedListenerKey_ = _e(this.pointerEventHandler_, wE.POINTERMOVE, this.relayEvent_, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.emulateClick_ = function (t) { let e = new s_(Vm.CLICK, this.map_, t); this.dispatchEvent(e), void 0 !== this.clickTimeoutId_ ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new s_(Vm.DBLCLICK, this.map_, t), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(() => { this.clickTimeoutId_ = void 0; const e = new s_(Vm.SINGLECLICK, this.map_, t); this.dispatchEvent(e); }, 250); }, e.prototype.updateActivePointers_ = function (t) { const e = t; e.type == Vm.POINTERUP || e.type == Vm.POINTERCANCEL ? delete this.trackedTouches_[e.pointerId] : e.type == Vm.POINTERDOWN && (this.trackedTouches_[e.pointerId] = !0), this.activePointers_ = Object.keys(this.trackedTouches_).length; }, e.prototype.handlePointerUp_ = function (t) { this.updateActivePointers_(t); const e = new s_(Vm.POINTERUP, this.map_, t); this.dispatchEvent(e), e.propagationStopped || this.dragging_ || !this.isMouseActionButton_(t) || this.emulateClick_(this.down_), this.activePointers_ === 0 && (this.dragListenerKeys_.forEach(xe), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null, this.documentPointerEventHandler_.dispose(), this.documentPointerEventHandler_ = null); }, e.prototype.isMouseActionButton_ = function (t) { return t.button === 0; }, e.prototype.handlePointerDown_ = function (t) { this.updateActivePointers_(t); const e = new s_(Vm.POINTERDOWN, this.map_, t); this.dispatchEvent(e), this.down_ = t, this.dragListenerKeys_.length === 0 && (this.documentPointerEventHandler_ = new rS(document), this.dragListenerKeys_.push(_e(this.documentPointerEventHandler_, Vm.POINTERMOVE, this.handlePointerMove_, this), _e(this.documentPointerEventHandler_, Vm.POINTERUP, this.handlePointerUp_, this), _e(this.pointerEventHandler_, Vm.POINTERCANCEL, this.handlePointerUp_, this))); }, e.prototype.handlePointerMove_ = function (t) { if (this.isMoving_(t)) { this.dragging_ = !0; const e = new s_(Vm.POINTERDRAG, this.map_, t, this.dragging_); this.dispatchEvent(e); }t.preventDefault(); }, e.prototype.relayEvent_ = function (t) { const e = !(!this.down_ || !this.isMoving_(t)); this.dispatchEvent(new s_(t.type, this.map_, t, e)); }, e.prototype.isMoving_ = function (t) { return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_; }, e.prototype.disposeInternal = function () { this.relayedListenerKey_ && (xe(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.pointerdownListenerKey_ && (xe(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(xe), this.dragListenerKeys_.length = 0, this.documentPointerEventHandler_ && (this.documentPointerEventHandler_.dispose(), this.documentPointerEventHandler_ = null), this.pointerEventHandler_ && (this.pointerEventHandler_.dispose(), this.pointerEventHandler_ = null), t.prototype.disposeInternal.call(this); }, e; }(Le)); const sS = oS; const aS = {
      LAYERGROUP: 'layergroup', SIZE: 'size', TARGET: 'target', VIEW: 'view',
    }; const uS = 1 / 0; const cS = function (t, e) { this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {}; }; cS.prototype.clear = function () { this.elements_.length = 0, this.priorities_.length = 0, Zt(this.queuedElements_); }, cS.prototype.dequeue = function () { const t = this.elements_; const e = this.priorities_; const n = t[0]; t.length == 1 ? (t.length = 0, e.length = 0) : (t[0] = t.pop(), e[0] = e.pop(), this.siftUp_(0)); const i = this.keyFunction_(n); return delete this.queuedElements_[i], n; }, cS.prototype.enqueue = function (t) { Q(!(this.keyFunction_(t) in this.queuedElements_), 31); const e = this.priorityFunction_(t); return e != uS && (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0); }, cS.prototype.getCount = function () { return this.elements_.length; }, cS.prototype.getLeftChildIndex_ = function (t) { return 2 * t + 1; }, cS.prototype.getRightChildIndex_ = function (t) { return 2 * t + 2; }, cS.prototype.getParentIndex_ = function (t) { return t - 1 >> 1; }, cS.prototype.heapify_ = function () { let t; for (t = (this.elements_.length >> 1) - 1; t >= 0; t--) this.siftUp_(t); }, cS.prototype.isEmpty = function () { return this.elements_.length === 0; }, cS.prototype.isKeyQueued = function (t) { return t in this.queuedElements_; }, cS.prototype.isQueued = function (t) { return this.isKeyQueued(this.keyFunction_(t)); }, cS.prototype.siftUp_ = function (t) { const e = this.elements_; const n = this.priorities_; const i = e.length; const r = e[t]; const o = n[t]; const s = t; while (t < i >> 1) { const a = this.getLeftChildIndex_(t); const u = this.getRightChildIndex_(t); const c = u < i && n[u] < n[a] ? u : a; e[t] = e[c], n[t] = n[c], t = c; }e[t] = r, n[t] = o, this.siftDown_(s, t); }, cS.prototype.siftDown_ = function (t, e) { const n = this.elements_; const i = this.priorities_; const r = n[e]; const o = i[e]; while (e > t) { const s = this.getParentIndex_(e); if (!(i[s] > o)) break; n[e] = n[s], i[e] = i[s], e = s; }n[e] = r, i[e] = o; }, cS.prototype.reprioritize = function () { let t; let e; let n; const i = this.priorityFunction_; const r = this.elements_; const o = this.priorities_; let s = 0; const a = r.length; for (e = 0; e < a; ++e)t = r[e], n = i(t), n == uS ? delete this.queuedElements_[this.keyFunction_(t)] : (o[s] = n, r[s++] = t); r.length = s, o.length = s, this.heapify_(); }; const hS = cS; const lS = (function (t) { function e(e, n) { t.call(this, t => e(...t), t => t[0].getKey()), this.tileChangeCallback_ = n, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {}; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.enqueue = function (e) { const n = t.prototype.enqueue.call(this, e); if (n) { const i = e[0]; _e(i, Ae.CHANGE, this.handleTileChange, this); } return n; }, e.prototype.getTilesLoading = function () { return this.tilesLoading_; }, e.prototype.handleTileChange = function (t) { const e = t.target; const n = e.getState(); if (n === se.LOADED || n === se.ERROR || n === se.EMPTY || n === se.ABORT) { we(e, Ae.CHANGE, this.handleTileChange, this); const i = e.getKey(); i in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[i], --this.tilesLoading_), this.tileChangeCallback_(); } }, e.prototype.loadMoreTiles = function (t, e) { let n; let i; let r; let o = 0; let s = !1; while (this.tilesLoading_ < t && o < e && this.getCount() > 0)i = this.dequeue()[0], r = i.getKey(), n = i.getState(), n === se.ABORT ? s = !0 : n !== se.IDLE || r in this.tilesLoadingKeys_ || (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++o, i.load()); o === 0 && s && this.tileChangeCallback_(); }, e; }(hS)); const fS = lS; function pS(t) { return function (e) { return e ? [Vt(e[0], t[0], t[2]), Vt(e[1], t[1], t[3])] : void 0; }; } function dS(t) { return t; } function vS(t) { return function (e, n, i) { if (void 0 !== e) { let r = Ci(t, e, i); r = Vt(r + n, 0, t.length - 1); const o = Math.floor(r); if (r != o && o < t.length - 1) { const s = t[o] / t[o + 1]; return t[o] / Math.pow(s, r - o); } return t[o]; } }; } function gS(t, e, n) { return function (i, r, o) { if (void 0 !== i) { const s = -o / 2 + 0.5; const a = Math.floor(Math.log(e / i) / Math.log(t) + s); let u = Math.max(a + r, 0); return void 0 !== n && (u = Math.min(u, n)), e / Math.pow(t, u); } }; } function yS(t, e) { return void 0 !== t ? 0 : void 0; } function mS(t, e) { return void 0 !== t ? t + e : void 0; } function _S(t) { const e = 2 * Math.PI / t; return function (t, n) { return void 0 !== t ? (t = Math.floor((t + n) / e + 0.5) * e, t) : void 0; }; } function bS(t) { const e = t || Wt(5); return function (t, n) { return void 0 !== t ? Math.abs(t + n) <= e ? 0 : t + n : void 0; }; } const wS = { ANIMATING: 0, INTERACTING: 1 }; const xS = { CENTER: 'center', RESOLUTION: 'resolution', ROTATION: 'rotation' }; const ES = 0; const SS = (function (t) {
      function e(e) { t.call(this); const n = qt({}, e); this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.updateAnimations_ = this.updateAnimations_.bind(this), this.projection_ = Dn(n.projection, 'EPSG:3857'), this.applyOptions_(n); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.applyOptions_ = function (t) { const e = {}; e[xS.CENTER] = void 0 !== t.center ? t.center : null; const n = CS(t); this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = t.resolutions, this.minZoom_ = n.minZoom; const i = OS(t); const r = n.constraint; const o = RS(t); this.constraints_ = { center: i, resolution: r, rotation: o }, void 0 !== t.resolution ? e[xS.RESOLUTION] = t.resolution : void 0 !== t.zoom && (e[xS.RESOLUTION] = this.constrainResolution(this.maxResolution_, t.zoom - this.minZoom_), this.resolutions_ && (e[xS.RESOLUTION] = Vt(Number(this.getResolution() || e[xS.RESOLUTION]), this.minResolution_, this.maxResolution_))), e[xS.ROTATION] = void 0 !== t.rotation ? t.rotation : 0, this.setProperties(e), this.options_ = t; }, e.prototype.getUpdatedOptions_ = function (t) { const e = qt({}, this.options_); return void 0 !== e.resolution ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenter(), e.rotation = this.getRotation(), qt({}, e, t); }, e.prototype.animate = function (t) {
        let e; const n = arguments; let i = arguments.length; if (i > 1 && typeof arguments[i - 1] === 'function' && (e = arguments[i - 1], --i), !this.isDef()) { const r = arguments[i - 1]; return r.center && this.setCenter(r.center), void 0 !== r.zoom && this.setZoom(r.zoom), void 0 !== r.rotation && this.setRotation(r.rotation), void (e && TS(e, !0)); } for (var o = Date.now(), s = this.getCenter().slice(), a = this.getResolution(), u = this.getRotation(), c = [], h = 0; h < i; ++h) {
          const l = n[h]; const f = {
            start: o, complete: !1, anchor: l.anchor, duration: void 0 !== l.duration ? l.duration : 1e3, easing: l.easing || ce,
          }; if (l.center && (f.sourceCenter = s, f.targetCenter = l.center, s = f.targetCenter), void 0 !== l.zoom ? (f.sourceResolution = a, f.targetResolution = this.constrainResolution(this.maxResolution_, l.zoom - this.minZoom_, 0), a = f.targetResolution) : l.resolution && (f.sourceResolution = a, f.targetResolution = l.resolution, a = f.targetResolution), void 0 !== l.rotation) { f.sourceRotation = u; const p = Kt(l.rotation - u + Math.PI, 2 * Math.PI) - Math.PI; f.targetRotation = u + p, u = f.targetRotation; }f.callback = e, IS(f) ? f.complete = !0 : o += f.duration, c.push(f);
        } this.animations_.push(c), this.setHint(wS.ANIMATING, 1), this.updateAnimations_();
      }, e.prototype.getAnimating = function () { return this.hints_[wS.ANIMATING] > 0; }, e.prototype.getInteracting = function () { return this.hints_[wS.INTERACTING] > 0; }, e.prototype.cancelAnimations = function () { this.setHint(wS.ANIMATING, -this.hints_[wS.ANIMATING]); for (let t = 0, e = this.animations_.length; t < e; ++t) { const n = this.animations_[t]; n[0].callback && TS(n[0].callback, !1); } this.animations_.length = 0; }, e.prototype.updateAnimations_ = function () { if (void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), this.getAnimating()) { for (var t = Date.now(), e = !1, n = this.animations_.length - 1; n >= 0; --n) { for (var i = this.animations_[n], r = !0, o = 0, s = i.length; o < s; ++o) { const a = i[o]; if (!a.complete) { const u = t - a.start; let c = a.duration > 0 ? u / a.duration : 1; c >= 1 ? (a.complete = !0, c = 1) : r = !1; const h = a.easing(c); if (a.sourceCenter) { const l = a.sourceCenter[0]; const f = a.sourceCenter[1]; const p = a.targetCenter[0]; const d = a.targetCenter[1]; const v = l + h * (p - l); const g = f + h * (d - f); this.set(xS.CENTER, [v, g]); } if (a.sourceResolution && a.targetResolution) { const y = h === 1 ? a.targetResolution : a.sourceResolution + h * (a.targetResolution - a.sourceResolution); a.anchor && this.set(xS.CENTER, this.calculateCenterZoom(y, a.anchor)), this.set(xS.RESOLUTION, y); } if (void 0 !== a.sourceRotation && void 0 !== a.targetRotation) { const m = h === 1 ? Kt(a.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : a.sourceRotation + h * (a.targetRotation - a.sourceRotation); a.anchor && this.set(xS.CENTER, this.calculateCenterRotate(m, a.anchor)), this.set(xS.ROTATION, m); } if (e = !0, !a.complete) break; } } if (r) { this.animations_[n] = null, this.setHint(wS.ANIMATING, -1); const _ = i[0].callback; _ && TS(_, !0); } } this.animations_ = this.animations_.filter(Boolean), e && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_)); } }, e.prototype.calculateCenterRotate = function (t, e) { let n; const i = this.getCenter(); return void 0 !== i && (n = [i[0] - e[0], i[1] - e[1]], em(n, t - this.getRotation()), qy(n, e)), n; }, e.prototype.calculateCenterZoom = function (t, e) { let n; const i = this.getCenter(); const r = this.getResolution(); if (void 0 !== i && void 0 !== r) { const o = e[0] - t * (e[0] - i[0]) / r; const s = e[1] - t * (e[1] - i[1]) / r; n = [o, s]; } return n; }, e.prototype.getSizeFromViewport_ = function () { const t = [100, 100]; const e = `.ol-viewport[data-view="${H(this)}"]`; const n = document.querySelector(e); if (n) { const i = getComputedStyle(n); t[0] = parseInt(i.width, 10), t[1] = parseInt(i.height, 10); } return t; }, e.prototype.constrainCenter = function (t) { return this.constraints_.center(t); }, e.prototype.constrainResolution = function (t, e, n) { const i = e || 0; const r = n || 0; return this.constraints_.resolution(t, i, r); }, e.prototype.constrainRotation = function (t, e) { const n = e || 0; return this.constraints_.rotation(t, n); }, e.prototype.getCenter = function () { return this.get(xS.CENTER); }, e.prototype.getConstraints = function () { return this.constraints_; }, e.prototype.getHints = function (t) { return void 0 !== t ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice(); }, e.prototype.calculateExtent = function (t) { const e = t || this.getSizeFromViewport_(); const n = this.getCenter(); Q(n, 1); const i = this.getResolution(); Q(void 0 !== i, 2); const r = this.getRotation(); return Q(void 0 !== r, 3), It(n, i, r, e); }, e.prototype.getMaxResolution = function () { return this.maxResolution_; }, e.prototype.getMinResolution = function () { return this.minResolution_; }, e.prototype.getMaxZoom = function () { return this.getZoomForResolution(this.minResolution_); }, e.prototype.setMaxZoom = function (t) { this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t })); }, e.prototype.getMinZoom = function () { return this.getZoomForResolution(this.maxResolution_); }, e.prototype.setMinZoom = function (t) { this.applyOptions_(this.getUpdatedOptions_({ minZoom: t })); }, e.prototype.getProjection = function () { return this.projection_; }, e.prototype.getResolution = function () { return this.get(xS.RESOLUTION); }, e.prototype.getResolutions = function () { return this.resolutions_; }, e.prototype.getResolutionForExtent = function (t, e) { const n = e || this.getSizeFromViewport_(); const i = jt(t) / n[0]; const r = Pt(t) / n[1]; return Math.max(i, r); }, e.prototype.getResolutionForValueFunction = function (t) { const e = t || 2; const n = this.maxResolution_; const i = this.minResolution_; const r = Math.log(n / i) / Math.log(e); return function (t) { const i = n / Math.pow(e, t * r); return i; }; }, e.prototype.getRotation = function () { return this.get(xS.ROTATION); }, e.prototype.getValueForResolutionFunction = function (t) { const e = t || 2; const n = this.maxResolution_; const i = this.minResolution_; const r = Math.log(n / i) / Math.log(e); return function (t) { const i = Math.log(n / t) / Math.log(e) / r; return i; }; }, e.prototype.getState = function (t) {
        const e = this.getCenter(); const n = this.getProjection(); const i = this.getResolution(); const r = i / t; const o = this.getRotation(); return {
          center: [Math.round(e[0] / r) * r, Math.round(e[1] / r) * r], projection: void 0 !== n ? n : null, resolution: i, rotation: o, zoom: this.getZoom(),
        };
      }, e.prototype.getZoom = function () { let t; const e = this.getResolution(); return void 0 !== e && (t = this.getZoomForResolution(e)), t; }, e.prototype.getZoomForResolution = function (t) { let e; let n; let i = this.minZoom_ || 0; if (this.resolutions_) { const r = Ci(this.resolutions_, t, 1); i = r, e = this.resolutions_[r], n = r == this.resolutions_.length - 1 ? 2 : e / this.resolutions_[r + 1]; } else e = this.maxResolution_, n = this.zoomFactor_; return i + Math.log(e / t) / Math.log(n); }, e.prototype.getResolutionForZoom = function (t) { return this.constrainResolution(this.maxResolution_, t - this.minZoom_, 0); }, e.prototype.fit = function (t, e) {
        let n; const i = e || {}; let r = i.size; r || (r = this.getSizeFromViewport_()), Q(Array.isArray(t) || typeof t.getSimplifiedGeometry === 'function', 24), Array.isArray(t) ? (Q(!Mt(t), 25), n = Ta(t)) : t.getType() === en.CIRCLE ? (t = t.getExtent(), n = Ta(t), n.rotate(this.getRotation(), Ct(t))) : n = t; let o; const s = void 0 !== i.padding ? i.padding : [0, 0, 0, 0]; const a = void 0 === i.constrainResolution || i.constrainResolution; const u = void 0 !== i.nearest && i.nearest; o = void 0 !== i.minResolution ? i.minResolution : void 0 !== i.maxZoom ? this.constrainResolution(this.maxResolution_, i.maxZoom - this.minZoom_, 0) : 0; for (var c = n.getFlatCoordinates(), h = this.getRotation(), l = Math.cos(-h), f = Math.sin(-h), p = 1 / 0, d = 1 / 0, v = -1 / 0, g = -1 / 0, y = n.getStride(), m = 0, _ = c.length; m < _; m += y) { const b = c[m] * l - c[m + 1] * f; const w = c[m] * f + c[m + 1] * l; p = Math.min(p, b), d = Math.min(d, w), v = Math.max(v, b), g = Math.max(g, w); } let x = this.getResolutionForExtent([p, d, v, g], [r[0] - s[1] - s[3], r[1] - s[0] - s[2]]); if (x = isNaN(x) ? o : Math.max(x, o), a) { let E = this.constrainResolution(x, 0, 0); !u && E < x && (E = this.constrainResolution(E, -1, 0)), x = E; }f = -f; let S = (p + v) / 2; let T = (d + g) / 2; S += (s[1] - s[3]) / 2 * x, T += (s[0] - s[2]) / 2 * x; const O = S * l - T * f; const C = T * l + S * f; const R = [O, C]; const I = i.callback ? i.callback : Oe; void 0 !== i.duration ? this.animate({
          resolution: x, center: R, duration: i.duration, easing: i.easing,
        }, I) : (this.setResolution(x), this.setCenter(R), TS(I, !0));
      }, e.prototype.centerOn = function (t, e, n) { const i = this.getRotation(); const r = Math.cos(-i); let o = Math.sin(-i); let s = t[0] * r - t[1] * o; let a = t[1] * r + t[0] * o; const u = this.getResolution(); s += (e[0] / 2 - n[0]) * u, a += (n[1] - e[1] / 2) * u, o = -o; const c = s * r - a * o; const h = a * r + s * o; this.setCenter([c, h]); }, e.prototype.isDef = function () { return !!this.getCenter() && void 0 !== this.getResolution(); }, e.prototype.rotate = function (t, e) { if (void 0 !== e) { const n = this.calculateCenterRotate(t, e); this.setCenter(n); } this.setRotation(t); }, e.prototype.setCenter = function (t) { this.set(xS.CENTER, t), this.getAnimating() && this.cancelAnimations(); }, e.prototype.setHint = function (t, e) { return this.hints_[t] += e, this.changed(), this.hints_[t]; }, e.prototype.setResolution = function (t) { this.set(xS.RESOLUTION, t), this.getAnimating() && this.cancelAnimations(); }, e.prototype.setRotation = function (t) { this.set(xS.ROTATION, t), this.getAnimating() && this.cancelAnimations(); }, e.prototype.setZoom = function (t) { this.setResolution(this.getResolutionForZoom(t)); }, e;
    }(di)); function TS(t, e) { setTimeout(() => { t(e); }, 0); } function OS(t) { return void 0 !== t.extent ? pS(t.extent) : dS; } function CS(t) {
      let e; let n; let i; const r = 28; const o = 2; let s = void 0 !== t.minZoom ? t.minZoom : ES; let a = void 0 !== t.maxZoom ? t.maxZoom : r; const u = void 0 !== t.zoomFactor ? t.zoomFactor : o; if (void 0 !== t.resolutions) { const c = t.resolutions; n = c[s], i = void 0 !== c[a] ? c[a] : c[c.length - 1], e = vS(c); } else { const h = Dn(t.projection, 'EPSG:3857'); const l = h.getExtent(); const f = l ? Math.max(jt(l), Pt(l)) : 360 * an[un.DEGREES] / h.getMetersPerUnit(); const p = f / bi / Math.pow(o, ES); const d = p / Math.pow(o, r - ES); n = t.maxResolution, void 0 !== n ? s = 0 : n = p / Math.pow(u, s), i = t.minResolution, void 0 === i && (i = void 0 !== t.maxZoom ? void 0 !== t.maxResolution ? n / Math.pow(u, a) : p / Math.pow(u, a) : d), a = s + Math.floor(Math.log(n / i) / Math.log(u)), i = n / Math.pow(u, a - s), e = gS(u, n, a - s); } return {
        constraint: e, maxResolution: n, minResolution: i, minZoom: s, zoomFactor: u,
      };
    } function RS(t) { const e = void 0 === t.enableRotation || t.enableRotation; if (e) { const n = t.constrainRotation; return void 0 === n || !0 === n ? bS() : !1 === n ? mS : typeof n === 'number' ? _S(n) : mS; } return yS; } function IS(t) { return !(t.sourceCenter && t.targetCenter && !tm(t.sourceCenter, t.targetCenter)) && (t.sourceResolution === t.targetResolution && t.sourceRotation === t.targetRotation); } const PS = SS; const LS = (function (t) {
      function e(e) { t.call(this); const n = AS(e); this.maxTilesLoading_ = void 0 !== e.maxTilesLoading ? e.maxTilesLoading : 16, this.loadTilesWhileAnimating_ = void 0 !== e.loadTilesWhileAnimating && e.loadTilesWhileAnimating, this.loadTilesWhileInteracting_ = void 0 !== e.loadTilesWhileInteracting && e.loadTilesWhileInteracting, this.pixelRatio_ = void 0 !== e.pixelRatio ? e.pixelRatio : pv, this.animationDelayKey_, this.animationDelay_ = function () { this.animationDelayKey_ = void 0, this.renderFrame_.call(this, Date.now()); }.bind(this), this.coordinateToPixelTransform_ = Jo(), this.pixelToCoordinateTransform_ = Jo(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement('div'), this.viewport_.className = `ol-viewport${gv ? ' ol-touch' : ''}`, this.viewport_.style.position = 'relative', this.viewport_.style.overflow = 'hidden', this.viewport_.style.width = '100%', this.viewport_.style.height = '100%', this.viewport_.style.msTouchAction = 'none', this.viewport_.style.touchAction = 'none', this.overlayContainer_ = document.createElement('div'), this.overlayContainer_.className = 'ol-overlaycontainer', this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement('div'), this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent'; for (let i = [Ae.CLICK, Ae.DBLCLICK, Ae.MOUSEDOWN, Ae.TOUCHSTART, Ae.MSPOINTERDOWN, Vm.POINTERDOWN, Ae.MOUSEWHEEL, Ae.WHEEL], r = 0, o = i.length; r < o; ++r)_e(this.overlayContainerStopEvent_, i[r], Re); for (const s in this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = new sS(this, e.moveTolerance), Vm)_e(this.mapBrowserEventHandler_, Vm[s], this.handleMapBrowserEvent, this); this.keyboardEventTarget_ = n.keyboardEventTarget, this.keyHandlerKeys_ = null, _e(this.viewport_, Ae.CONTEXTMENU, this.handleBrowserEvent, this), _e(this.viewport_, Ae.WHEEL, this.handleBrowserEvent, this), _e(this.viewport_, Ae.MOUSEWHEEL, this.handleBrowserEvent, this), this.controls = n.controls || new hm(), this.interactions = n.interactions || new hm(), this.overlays_ = n.overlays, this.overlayIdIndex_ = {}, this.renderer_ = this.createRenderer(), this.handleResize_, this.focus_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new fS(this.getTilePriority.bind(this), this.handleTileChange_.bind(this)), this.skippedFeatureUids_ = {}, _e(this, pi(aS.LAYERGROUP), this.handleLayerGroupChanged_, this), _e(this, pi(aS.VIEW), this.handleViewChanged_, this), _e(this, pi(aS.SIZE), this.handleSizeChanged_, this), _e(this, pi(aS.TARGET), this.handleTargetChanged_, this), this.setProperties(n.values), this.controls.forEach((t) => { t.setMap(this); }), _e(this.controls, sm.ADD, function (t) { t.element.setMap(this); }, this), _e(this.controls, sm.REMOVE, (t) => { t.element.setMap(null); }, this), this.interactions.forEach((t) => { t.setMap(this); }), _e(this.interactions, sm.ADD, function (t) { t.element.setMap(this); }, this), _e(this.interactions, sm.REMOVE, (t) => { t.element.setMap(null); }, this), this.overlays_.forEach(this.addOverlayInternal_.bind(this)), _e(this.overlays_, sm.ADD, function (t) { this.addOverlayInternal_(t.element); }, this), _e(this.overlays_, sm.REMOVE, function (t) { const e = t.element; const n = e.getId(); void 0 !== n && delete this.overlayIdIndex_[n.toString()], t.element.setMap(null); }, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createRenderer = function () { throw new Error('Use a map type that has a createRenderer method'); }, e.prototype.addControl = function (t) { this.getControls().push(t); }, e.prototype.addInteraction = function (t) { this.getInteractions().push(t); }, e.prototype.addLayer = function (t) { const e = this.getLayerGroup().getLayers(); e.push(t); }, e.prototype.addOverlay = function (t) { this.getOverlays().push(t); }, e.prototype.addOverlayInternal_ = function (t) { const e = t.getId(); void 0 !== e && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this); }, e.prototype.disposeInternal = function () { this.mapBrowserEventHandler_.dispose(), we(this.viewport_, Ae.CONTEXTMENU, this.handleBrowserEvent, this), we(this.viewport_, Ae.WHEEL, this.handleBrowserEvent, this), we(this.viewport_, Ae.MOUSEWHEEL, this.handleBrowserEvent, this), void 0 !== this.handleResize_ && (removeEventListener(Ae.RESIZE, this.handleResize_, !1), this.handleResize_ = void 0), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0), this.setTarget(null), t.prototype.disposeInternal.call(this); }, e.prototype.forEachFeatureAtPixel = function (t, e, n) { if (this.frameState_) { const i = this.getCoordinateFromPixel(t); n = void 0 !== n ? n : {}; const r = void 0 !== n.hitTolerance ? n.hitTolerance * this.frameState_.pixelRatio : 0; const o = void 0 !== n.layerFilter ? n.layerFilter : Se; return this.renderer_.forEachFeatureAtCoordinate(i, this.frameState_, r, e, null, o, null); } }, e.prototype.getFeaturesAtPixel = function (t, e) { let n = null; return this.forEachFeatureAtPixel(t, (t) => { n || (n = []), n.push(t); }, e), n; }, e.prototype.forEachLayerAtPixel = function (t, e, n) { if (this.frameState_) { const i = n || {}; const r = void 0 !== i.hitTolerance ? n.hitTolerance * this.frameState_.pixelRatio : 0; const o = i.layerFilter || Se; return this.renderer_.forEachLayerAtPixel(t, this.frameState_, r, e, null, o, null); } }, e.prototype.hasFeatureAtPixel = function (t, e) { if (!this.frameState_) return !1; const n = this.getCoordinateFromPixel(t); e = void 0 !== e ? e : {}; const i = void 0 !== e.layerFilter ? e.layerFilter : Se; const r = void 0 !== e.hitTolerance ? e.hitTolerance * this.frameState_.pixelRatio : 0; return this.renderer_.hasFeatureAtCoordinate(n, this.frameState_, r, i, null); }, e.prototype.getEventCoordinate = function (t) { return this.getCoordinateFromPixel(this.getEventPixel(t)); }, e.prototype.getEventPixel = function (t) { const e = this.viewport_.getBoundingClientRect(); const n = 'changedTouches' in t ? t.changedTouches[0] : t; return [n.clientX - e.left, n.clientY - e.top]; }, e.prototype.getTarget = function () { return this.get(aS.TARGET); }, e.prototype.getTargetElement = function () { const t = this.getTarget(); return void 0 !== t ? typeof t === 'string' ? document.getElementById(t) : t : null; }, e.prototype.getCoordinateFromPixel = function (t) { const e = this.frameState_; return e ? is(e.pixelToCoordinateTransform, t.slice()) : null; }, e.prototype.getControls = function () { return this.controls; }, e.prototype.getOverlays = function () { return this.overlays_; }, e.prototype.getOverlayById = function (t) { const e = this.overlayIdIndex_[t.toString()]; return void 0 !== e ? e : null; }, e.prototype.getInteractions = function () { return this.interactions; }, e.prototype.getLayerGroup = function () { return this.get(aS.LAYERGROUP); }, e.prototype.getLayers = function () { const t = this.getLayerGroup().getLayers(); return t; }, e.prototype.getPixelFromCoordinate = function (t) { const e = this.frameState_; return e ? is(e.coordinateToPixelTransform, t.slice(0, 2)) : null; }, e.prototype.getRenderer = function () { return this.renderer_; }, e.prototype.getSize = function () { return this.get(aS.SIZE); }, e.prototype.getView = function () { return this.get(aS.VIEW); }, e.prototype.getViewport = function () { return this.viewport_; }, e.prototype.getOverlayContainer = function () { return this.overlayContainer_; }, e.prototype.getOverlayContainerStopEvent = function () { return this.overlayContainerStopEvent_; }, e.prototype.getTilePriority = function (t, e, n, i) { const r = this.frameState_; if (!r || !(e in r.wantedTiles)) return uS; if (!r.wantedTiles[e][t.getKey()]) return uS; const o = n[0] - r.focus[0]; const s = n[1] - r.focus[1]; return 65536 * Math.log(i) + Math.sqrt(o * o + s * s) / i; }, e.prototype.handleBrowserEvent = function (t, e) { const n = e || t.type; const i = new r_(n, this, t); this.handleMapBrowserEvent(i); }, e.prototype.handleMapBrowserEvent = function (t) { if (this.frameState_) { this.focus_ = t.coordinate, t.frameState = this.frameState_; const e = this.getInteractions().getArray(); if (!1 !== this.dispatchEvent(t)) for (let n = e.length - 1; n >= 0; n--) { const i = e[n]; if (i.getActive()) { const r = i.handleEvent(t); if (!r) break; } } } }, e.prototype.handlePostRender = function () { const t = this.frameState_; const e = this.tileQueue_; if (!e.isEmpty()) { let n = this.maxTilesLoading_; let i = n; if (t) { const r = t.viewHints; r[wS.ANIMATING] && (n = this.loadTilesWhileAnimating_ ? 8 : 0, i = 2), r[wS.INTERACTING] && (n = this.loadTilesWhileInteracting_ ? 8 : 0, i = 2); }e.getTilesLoading() < n && (e.reprioritize(), e.loadMoreTiles(n, i)); }!t || !this.hasListener(T_.RENDERCOMPLETE) || t.animate || this.tileQueue_.getTilesLoading() || jS(this.getLayers().getArray()) || this.renderer_.dispatchRenderEvent(T_.RENDERCOMPLETE, t); for (var o = this.postRenderFunctions_, s = 0, a = o.length; s < a; ++s)o[s](this, t); o.length = 0; }, e.prototype.handleSizeChanged_ = function () { this.render(); }, e.prototype.handleTargetChanged_ = function () { let t; if (this.getTarget() && (t = this.getTargetElement()), this.keyHandlerKeys_) { for (let e = 0, n = this.keyHandlerKeys_.length; e < n; ++e)xe(this.keyHandlerKeys_[e]); this.keyHandlerKeys_ = null; } if (t) { t.appendChild(this.viewport_); const i = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t; this.keyHandlerKeys_ = [_e(i, Ae.KEYDOWN, this.handleBrowserEvent, this), _e(i, Ae.KEYPRESS, this.handleBrowserEvent, this)], this.handleResize_ || (this.handleResize_ = this.updateSize.bind(this), addEventListener(Ae.RESIZE, this.handleResize_, !1)); } else this.renderer_.removeLayerRenderers(), $e(this.viewport_), void 0 !== this.handleResize_ && (removeEventListener(Ae.RESIZE, this.handleResize_, !1), this.handleResize_ = void 0); this.updateSize(); }, e.prototype.handleTileChange_ = function () { this.render(); }, e.prototype.handleViewPropertyChanged_ = function () { this.render(); }, e.prototype.handleViewChanged_ = function () { this.viewPropertyListenerKey_ && (xe(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (xe(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null); const t = this.getView(); t && (this.viewport_.setAttribute('data-view', H(t)), this.viewPropertyListenerKey_ = _e(t, ai.PROPERTYCHANGE, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = _e(t, Ae.CHANGE, this.handleViewPropertyChanged_, this)), this.render(); }, e.prototype.handleLayerGroupChanged_ = function () { this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(xe), this.layerGroupPropertyListenerKeys_ = null); const t = this.getLayerGroup(); t && (this.layerGroupPropertyListenerKeys_ = [_e(t, ai.PROPERTYCHANGE, this.render, this), _e(t, Ae.CHANGE, this.render, this)]), this.render(); }, e.prototype.isRendered = function () { return !!this.frameState_; }, e.prototype.renderSync = function () { this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_(); }, e.prototype.render = function () { void 0 === this.animationDelayKey_ && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_)); }, e.prototype.removeControl = function (t) { return this.getControls().remove(t); }, e.prototype.removeInteraction = function (t) { return this.getInteractions().remove(t); }, e.prototype.removeLayer = function (t) { const e = this.getLayerGroup().getLayers(); return e.remove(t); }, e.prototype.removeOverlay = function (t) { return this.getOverlays().remove(t); }, e.prototype.renderFrame_ = function (t) {
        let e; const n = this.getSize(); const i = this.getView(); const r = lt(); const o = this.frameState_; let s = null; if (void 0 !== n && ee(n) && i && i.isDef()) {
          for (var a = i.getHints(this.frameState_ ? this.frameState_.viewHints : void 0), u = this.getLayerGroup().getLayerStatesArray(), c = {}, h = 0, l = u.length; h < l; ++h)c[H(u[h].layer)] = u[h]; e = i.getState(this.pixelRatio_), s = {
            animate: !1, coordinateToPixelTransform: this.coordinateToPixelTransform_, extent: r, focus: this.focus_ ? this.focus_ : e.center, index: this.frameIndex_++, layerStates: c, layerStatesArray: u, pixelRatio: this.pixelRatio_, pixelToCoordinateTransform: this.pixelToCoordinateTransform_, postRenderFunctions: [], size: n, skippedFeatureUids: this.skippedFeatureUids_, tileQueue: this.tileQueue_, time: t, usedTiles: {}, viewState: e, viewHints: a, wantedTiles: {},
          };
        } if (s && (s.extent = It(e.center, e.resolution, e.rotation, s.size, r)), this.frameState_ = s, this.renderer_.renderFrame(s), s) { if (s.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, s.postRenderFunctions), o) { const f = !this.previousExtent_ || !Mt(this.previousExtent_) && !yt(s.extent, this.previousExtent_); f && (this.dispatchEvent(new n_($p.MOVESTART, this, o)), this.previousExtent_ = pt(this.previousExtent_)); } const p = this.previousExtent_ && !s.viewHints[wS.ANIMATING] && !s.viewHints[wS.INTERACTING] && !yt(s.extent, this.previousExtent_); p && (this.dispatchEvent(new n_($p.MOVEEND, this, s)), ot(s.extent, this.previousExtent_)); } this.dispatchEvent(new n_($p.POSTRENDER, this, s)), setTimeout(this.handlePostRender.bind(this), 0);
      }, e.prototype.setLayerGroup = function (t) { this.set(aS.LAYERGROUP, t); }, e.prototype.setSize = function (t) { this.set(aS.SIZE, t); }, e.prototype.setTarget = function (t) { this.set(aS.TARGET, t); }, e.prototype.setView = function (t) { this.set(aS.VIEW, t); }, e.prototype.skipFeature = function (t) { this.skippedFeatureUids_[H(t)] = !0, this.render(); }, e.prototype.updateSize = function () { const t = this.getTargetElement(); if (t) { const e = getComputedStyle(t); this.setSize([t.offsetWidth - parseFloat(e.borderLeftWidth) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderRightWidth), t.offsetHeight - parseFloat(e.borderTopWidth) - parseFloat(e.paddingTop) - parseFloat(e.paddingBottom) - parseFloat(e.borderBottomWidth)]); } else this.setSize(void 0); }, e.prototype.unskipFeature = function (t) { delete this.skippedFeatureUids_[H(t)], this.render(); }, e;
    }(di)); function AS(t) {
      let e = null; void 0 !== t.keyboardEventTarget && (e = typeof t.keyboardEventTarget === 'string' ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget); let n; let i; let r; const o = {}; const s = t.layers && typeof t.layers.getLayers === 'function' ? t.layers : new Ew({ layers: t.layers }); return o[aS.LAYERGROUP] = s, o[aS.TARGET] = t.target, o[aS.VIEW] = void 0 !== t.view ? t.view : new PS(), void 0 !== t.controls && (Array.isArray(t.controls) ? n = new hm(t.controls.slice()) : (Q(typeof t.controls.getArray === 'function', 47), n = t.controls)), void 0 !== t.interactions && (Array.isArray(t.interactions) ? i = new hm(t.interactions.slice()) : (Q(typeof t.interactions.getArray === 'function', 48), i = t.interactions)), void 0 !== t.overlays ? Array.isArray(t.overlays) ? r = new hm(t.overlays.slice()) : (Q(typeof t.overlays.getArray === 'function', 49), r = t.overlays) : r = new hm(), {
        controls: n, interactions: i, keyboardEventTarget: e, overlays: r, values: o,
      };
    } const FS = LS; function jS(t) { for (let e = 0, n = t.length; e < n; ++e) { const i = t[e]; if (typeof i.getLayers === 'function') return jS(i.getLayers().getArray()); const r = i.getSource(); if (r && r.loading) return !0; } return !1; } const kS = function (t, e, n) { this.decay_ = t, this.minVelocity_ = e, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0; }; kS.prototype.begin = function () { this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0; }, kS.prototype.update = function (t, e) { this.points_.push(t, e, Date.now()); }, kS.prototype.end = function () { if (this.points_.length < 6) return !1; const t = Date.now() - this.delay_; const e = this.points_.length - 3; if (this.points_[e + 2] < t) return !1; let n = e - 3; while (n > 0 && this.points_[n + 2] > t)n -= 3; const i = this.points_[e + 2] - this.points_[n + 2]; if (i < 1e3 / 60) return !1; const r = this.points_[e] - this.points_[n]; const o = this.points_[e + 1] - this.points_[n + 1]; return this.angle_ = Math.atan2(o, r), this.initialVelocity_ = Math.sqrt(r * r + o * o) / i, this.initialVelocity_ > this.minVelocity_; }, kS.prototype.getDistance = function () { return (this.minVelocity_ - this.initialVelocity_) / this.decay_; }, kS.prototype.getAngle = function () { return this.angle_; }; const MS = kS; const NS = (function (t) { function e(e) { t.call(this, { handleEvent: DS }); const n = e || {}; this.delta_ = n.delta ? n.delta : 1, this.duration_ = void 0 !== n.duration ? n.duration : 250; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(wp)); function DS(t) { let e = !1; if (t.type == Vm.DBLCLICK) { const n = t.originalEvent; const i = t.map; const r = t.coordinate; const o = n.shiftKey ? -this.delta_ : this.delta_; const s = i.getView(); _p(s, o, r, this.duration_), t.preventDefault(), e = !0; } return !e; } const $S = NS; const GS = (function (t) { function e(e) { t.call(this, { stopDown: Te }); const n = e || {}; this.kinetic_ = n.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1, this.condition_ = n.condition ? n.condition : qm, this.noKinetic_ = !1; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleDragEvent = function (t) { this.panning_ || (this.panning_ = !0, this.getMap().getView().setHint(wS.INTERACTING, 1)); const e = this.targetPointers; const n = w_(e); if (e.length == this.lastPointersCount_) { if (this.kinetic_ && this.kinetic_.update(n[0], n[1]), this.lastCentroid) { const i = this.lastCentroid[0] - n[0]; const r = n[1] - this.lastCentroid[1]; const o = t.map; const s = o.getView(); let a = [i, r]; nm(a, s.getResolution()), em(a, s.getRotation()), qy(a, s.getCenter()), a = s.constrainCenter(a), s.setCenter(a); } } else this.kinetic_ && this.kinetic_.begin(); this.lastCentroid = n, this.lastPointersCount_ = e.length; }, e.prototype.handleUpEvent = function (t) { const e = t.map; const n = e.getView(); if (this.targetPointers.length === 0) { if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) { const i = this.kinetic_.getDistance(); const r = this.kinetic_.getAngle(); const o = n.getCenter(); const s = e.getPixelFromCoordinate(o); const a = e.getCoordinateFromPixel([s[0] - i * Math.cos(r), s[1] - i * Math.sin(r)]); n.animate({ center: n.constrainCenter(a), duration: 500, easing: ue }); } return this.panning_ && (this.panning_ = !1, n.setHint(wS.INTERACTING, -1)), !1; } return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0; }, e.prototype.handleDownEvent = function (t) { if (this.targetPointers.length > 0 && this.condition_(t)) { const e = t.map; const n = e.getView(); return this.lastCentroid = null, n.getAnimating() && n.setCenter(t.frameState.viewState.center), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0; } return !1; }, e; }(E_)); const VS = GS; const BS = (function (t) { function e(e) { const n = e || {}; t.call(this, { stopDown: Te }), this.condition_ = n.condition ? n.condition : Um, this.lastAngle_ = void 0, this.duration_ = void 0 !== n.duration ? n.duration : 250; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleDragEvent = function (t) { if (Qm(t)) { const e = t.map; const n = e.getView(); if (n.getConstraints().rotation !== yS) { const i = e.getSize(); const r = t.pixel; const o = Math.atan2(i[1] / 2 - r[1], r[0] - i[0] / 2); if (void 0 !== this.lastAngle_) { const s = o - this.lastAngle_; const a = n.getRotation(); yp(n, a - s); } this.lastAngle_ = o; } } }, e.prototype.handleUpEvent = function (t) { if (!Qm(t)) return !0; const e = t.map; const n = e.getView(); n.setHint(wS.INTERACTING, -1); const i = n.getRotation(); return gp(n, i, void 0, this.duration_), !1; }, e.prototype.handleDownEvent = function (t) { if (!Qm(t)) return !1; if (Xm(t) && this.condition_(t)) { const e = t.map; return e.getView().setHint(wS.INTERACTING, 1), this.lastAngle_ = void 0, !0; } return !1; }, e; }(E_)); const US = BS; const zS = (function (t) { function e(e) { t.call(this), this.geometry_ = null, this.element_ = document.createElement('div'), this.element_.style.position = 'absolute', this.element_.className = `ol-box ${e}`, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.setMap(null); }, e.prototype.render_ = function () { const t = this.startPixel_; const e = this.endPixel_; const n = 'px'; const i = this.element_.style; i.left = Math.min(t[0], e[0]) + n, i.top = Math.min(t[1], e[1]) + n, i.width = Math.abs(e[0] - t[0]) + n, i.height = Math.abs(e[1] - t[1]) + n; }, e.prototype.setMap = function (t) { if (this.map_) { this.map_.getOverlayContainer().removeChild(this.element_); const e = this.element_.style; e.left = e.top = e.width = e.height = 'inherit'; } this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_); }, e.prototype.setPixels = function (t, e) { this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_(); }, e.prototype.createOrUpdateGeometry = function () { const t = this.startPixel_; const e = this.endPixel_; const n = [t, [t[0], e[1]], e, [e[0], t[1]]]; const i = n.map(this.map_.getCoordinateFromPixel, this.map_); i[4] = i[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([i]) : this.geometry_ = new Ea([i]); }, e.prototype.getGeometry = function () { return this.geometry_; }, e; }(fe)); const YS = zS; const XS = { BOXSTART: 'boxstart', BOXDRAG: 'boxdrag', BOXEND: 'boxend' }; const WS = (function (t) { function e(e, n, i) { t.call(this, e), this.coordinate = n, this.mapBrowserEvent = i; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const KS = (function (t) { function e(e) { t.call(this); const n = e || {}; this.box_ = new YS(n.className || 'ol-dragbox'), this.minArea_ = void 0 !== n.minArea ? n.minArea : 64, this.onBoxEnd_ = n.onBoxEnd ? n.onBoxEnd : Oe, this.startPixel_ = null, this.condition_ = n.condition ? n.condition : Ym, this.boxEndCondition_ = n.boxEndCondition ? n.boxEndCondition : this.defaultBoxEndCondition; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.defaultBoxEndCondition = function (t, e, n) { const i = n[0] - e[0]; const r = n[1] - e[1]; return i * i + r * r >= this.minArea_; }, e.prototype.getGeometry = function () { return this.box_.getGeometry(); }, e.prototype.handleDragEvent = function (t) { Qm(t) && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(new WS(XS.BOXDRAG, t.coordinate, t))); }, e.prototype.handleUpEvent = function (t) { return !Qm(t) || (this.box_.setMap(null), this.boxEndCondition_(t, this.startPixel_, t.pixel) && (this.onBoxEnd_(t), this.dispatchEvent(new WS(XS.BOXEND, t.coordinate, t))), !1); }, e.prototype.handleDownEvent = function (t) { return !!Qm(t) && (!(!Xm(t) || !this.condition_(t)) && (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new WS(XS.BOXSTART, t.coordinate, t)), !0)); }, e; }(E_)); const HS = KS; const qS = (function (t) { function e(e) { const n = e || {}; const i = n.condition ? n.condition : Zm; t.call(this, { condition: i, className: n.className || 'ol-dragzoom', onBoxEnd: ZS }), this.duration_ = void 0 !== n.duration ? n.duration : 200, this.out_ = void 0 !== n.out && n.out; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(HS)); function ZS() {
      const t = this.getMap(); const e = t.getView(); const n = t.getSize(); let i = this.getGeometry().getExtent(); if (this.out_) { const r = e.calculateExtent(n); const o = vt([t.getPixelFromCoordinate(Tt(i)), t.getPixelFromCoordinate(Ft(i))]); const s = e.getResolutionForExtent(o, n); Dt(r, 1 / s), i = r; } const a = e.constrainResolution(e.getResolutionForExtent(i, n)); let u = Ct(i); u = e.constrainCenter(u), e.animate({
        resolution: a, center: u, duration: this.duration_, easing: ue,
      });
    } const JS = qS; const QS = {
      LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40,
    }; const tT = (function (t) { function e(e) { t.call(this, { handleEvent: eT }); const n = e || {}; this.defaultCondition_ = function (t) { return qm(t) && Jm(t); }, this.condition_ = void 0 !== n.condition ? n.condition : this.defaultCondition_, this.duration_ = void 0 !== n.duration ? n.duration : 100, this.pixelDelta_ = void 0 !== n.pixelDelta ? n.pixelDelta : 128; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(wp)); function eT(t) { let e = !1; if (t.type == Ae.KEYDOWN) { const n = t.originalEvent; const i = n.keyCode; if (this.condition_(t) && (i == QS.DOWN || i == QS.LEFT || i == QS.RIGHT || i == QS.UP)) { const r = t.map; const o = r.getView(); const s = o.getResolution() * this.pixelDelta_; let a = 0; let u = 0; i == QS.DOWN ? u = -s : i == QS.LEFT ? a = -s : i == QS.RIGHT ? a = s : u = s; const c = [a, u]; em(c, o.getRotation()), vp(o, c, this.duration_), t.preventDefault(), e = !0; } } return !e; } const nT = tT; const iT = (function (t) { function e(e) { t.call(this, { handleEvent: rT }); const n = e || {}; this.condition_ = n.condition ? n.condition : Jm, this.delta_ = n.delta ? n.delta : 1, this.duration_ = void 0 !== n.duration ? n.duration : 100; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(wp)); function rT(t) { let e = !1; if (t.type == Ae.KEYDOWN || t.type == Ae.KEYPRESS) { const n = t.originalEvent; const i = n.charCode; if (this.condition_(t) && (i == '+'.charCodeAt(0) || i == '-'.charCodeAt(0))) { const r = t.map; const o = i == '+'.charCodeAt(0) ? this.delta_ : -this.delta_; const s = r.getView(); _p(s, o, void 0, this.duration_), t.preventDefault(), e = !0; } } return !e; } const oT = iT; const sT = 1; const aT = { TRACKPAD: 'trackpad', WHEEL: 'wheel' }; const uT = (function (t) {
      function e(e) { const n = e || {}; t.call(this, n), this.delta_ = 0, this.duration_ = void 0 !== n.duration ? n.duration : 250, this.timeout_ = void 0 !== n.timeout ? n.timeout : 80, this.useAnchor_ = void 0 === n.useAnchor || n.useAnchor, this.constrainResolution_ = n.constrainResolution || !1, this.condition_ = n.condition ? n.condition : Ym, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.trackpadDeltaPerZoom_ = 300, this.trackpadZoomBuffer_ = 1.5; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.decrementInteractingHint_ = function () { this.trackpadTimeoutId_ = void 0; const t = this.getMap().getView(); t.setHint(wS.INTERACTING, -1); }, e.prototype.handleEvent = function (t) {
        if (!this.condition_(t)) return !0; const e = t.type; if (e !== Ae.WHEEL && e !== Ae.MOUSEWHEEL) return !0; t.preventDefault(); let n; const i = t.map; const r = t.originalEvent; if (this.useAnchor_ && (this.lastAnchor_ = t.coordinate), t.type == Ae.WHEEL ? (n = r.deltaY, cv && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (n /= pv), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (n *= 40)) : t.type == Ae.MOUSEWHEEL && (n = -r.wheelDeltaY, hv && (n /= 3)), n === 0) return !1; const o = Date.now(); if (void 0 === this.startTime_ && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(n) < 4 ? aT.TRACKPAD : aT.WHEEL), this.mode_ === aT.TRACKPAD) {
          const s = i.getView(); this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : s.setHint(wS.INTERACTING, 1), this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_); let a = s.getResolution() * Math.pow(2, n / this.trackpadDeltaPerZoom_); const u = s.getMinResolution(); const c = s.getMaxResolution(); let h = 0; if (a < u ? (a = Math.max(a, u / this.trackpadZoomBuffer_), h = 1) : a > c && (a = Math.min(a, c * this.trackpadZoomBuffer_), h = -1), this.lastAnchor_) { const l = s.calculateCenterZoom(a, this.lastAnchor_); s.setCenter(s.constrainCenter(l)); } return s.setResolution(a), h === 0 && this.constrainResolution_ && s.animate({
            resolution: s.constrainResolution(a, n > 0 ? -1 : 1), easing: ue, anchor: this.lastAnchor_, duration: this.duration_,
          }), h > 0 ? s.animate({
            resolution: u, easing: ue, anchor: this.lastAnchor_, duration: 500,
          }) : h < 0 && s.animate({
            resolution: c, easing: ue, anchor: this.lastAnchor_, duration: 500,
          }), this.startTime_ = o, !1;
        } this.delta_ += n; const f = Math.max(this.timeout_ - (o - this.startTime_), 0); return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, i), f), !1;
      }, e.prototype.handleWheelZoom_ = function (t) { const e = t.getView(); e.getAnimating() && e.cancelAnimations(); const n = sT; const i = Vt(this.delta_, -n, n); _p(e, -i, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.delta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0; }, e.prototype.setMouseAnchor = function (t) { this.useAnchor_ = t, t || (this.lastAnchor_ = null); }, e;
    }(wp)); const cT = uT; const hT = (function (t) { function e(e) { const n = e || {}; const i = n; i.stopDown || (i.stopDown = Te), t.call(this, i), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = void 0 !== n.threshold ? n.threshold : 0.3, this.duration_ = void 0 !== n.duration ? n.duration : 250; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleDragEvent = function (t) { let e = 0; const n = this.targetPointers[0]; const i = this.targetPointers[1]; const r = Math.atan2(i.clientY - n.clientY, i.clientX - n.clientX); if (void 0 !== this.lastAngle_) { const o = r - this.lastAngle_; this.rotationDelta_ += o, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), e = o; } this.lastAngle_ = r; const s = t.map; const a = s.getView(); if (a.getConstraints().rotation !== yS) { const u = s.getViewport().getBoundingClientRect(); const c = w_(this.targetPointers); if (c[0] -= u.left, c[1] -= u.top, this.anchor_ = s.getCoordinateFromPixel(c), this.rotating_) { const h = a.getRotation(); s.render(), yp(a, h + e, this.anchor_); } } }, e.prototype.handleUpEvent = function (t) { if (this.targetPointers.length < 2) { const e = t.map; const n = e.getView(); if (n.setHint(wS.INTERACTING, -1), this.rotating_) { const i = n.getRotation(); gp(n, i, this.anchor_, this.duration_); } return !1; } return !0; }, e.prototype.handleDownEvent = function (t) { if (this.targetPointers.length >= 2) { const e = t.map; return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().setHint(wS.INTERACTING, 1), !0; } return !1; }, e; }(E_)); const lT = hT; const fT = (function (t) { function e(e) { const n = e || {}; const i = n; i.stopDown || (i.stopDown = Te), t.call(this, i), this.constrainResolution_ = n.constrainResolution || !1, this.anchor_ = null, this.duration_ = void 0 !== n.duration ? n.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.handleDragEvent = function (t) { let e = 1; const n = this.targetPointers[0]; const i = this.targetPointers[1]; const r = n.clientX - i.clientX; const o = n.clientY - i.clientY; const s = Math.sqrt(r * r + o * o); void 0 !== this.lastDistance_ && (e = this.lastDistance_ / s), this.lastDistance_ = s; const a = t.map; const u = a.getView(); const c = u.getResolution(); const h = u.getMaxResolution(); const l = u.getMinResolution(); let f = c * e; f > h ? (e = h / c, f = h) : f < l && (e = l / c, f = l), e != 1 && (this.lastScaleDelta_ = e); const p = a.getViewport().getBoundingClientRect(); const d = w_(this.targetPointers); d[0] -= p.left, d[1] -= p.top, this.anchor_ = a.getCoordinateFromPixel(d), a.render(), bp(u, f, this.anchor_); }, e.prototype.handleUpEvent = function (t) { if (this.targetPointers.length < 2) { const e = t.map; const n = e.getView(); n.setHint(wS.INTERACTING, -1); const i = n.getResolution(); if (this.constrainResolution_ || i < n.getMinResolution() || i > n.getMaxResolution()) { const r = this.lastScaleDelta_ - 1; mp(n, i, this.anchor_, this.duration_, r); } return !1; } return !0; }, e.prototype.handleDownEvent = function (t) { if (this.targetPointers.length >= 2) { const e = t.map; return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().setHint(wS.INTERACTING, 1), !0; } return !1; }, e; }(E_)); const pT = fT; function dT(t) { const e = t || {}; const n = new hm(); const i = new MS(-0.005, 0.05, 100); const r = void 0 === e.altShiftDragRotate || e.altShiftDragRotate; r && n.push(new US()); const o = void 0 === e.doubleClickZoom || e.doubleClickZoom; o && n.push(new $S({ delta: e.zoomDelta, duration: e.zoomDuration })); const s = void 0 === e.dragPan || e.dragPan; s && n.push(new VS({ condition: e.onFocusOnly ? zm : void 0, kinetic: i })); const a = void 0 === e.pinchRotate || e.pinchRotate; a && n.push(new lT()); const u = void 0 === e.pinchZoom || e.pinchZoom; u && n.push(new pT({ constrainResolution: e.constrainResolution, duration: e.zoomDuration })); const c = void 0 === e.keyboard || e.keyboard; c && (n.push(new nT()), n.push(new oT({ delta: e.zoomDelta, duration: e.zoomDuration }))); const h = void 0 === e.mouseWheelZoom || e.mouseWheelZoom; h && n.push(new cT({ condition: e.onFocusOnly ? zm : void 0, constrainResolution: e.constrainResolution, duration: e.zoomDuration })); const l = void 0 === e.shiftDragZoom || e.shiftDragZoom; return l && n.push(new JS({ duration: e.zoomDuration })), n; } const vT = (function (t) { function e(e, n, i, r, o) { const s = void 0 !== o ? _v.IDLE : _v.LOADED; t.call(this, e, n, i, s), this.loader_ = void 0 !== o ? o : null, this.canvas_ = r, this.error_ = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getError = function () { return this.error_; }, e.prototype.handleLoad_ = function (t) { t ? (this.error_ = t, this.state = _v.ERROR) : this.state = _v.LOADED, this.changed(); }, e.prototype.load = function () { this.state == _v.IDLE && (this.state = _v.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this))); }, e.prototype.getImage = function () { return this.canvas_; }, e; }(cx)); const gT = vT; const yT = (function (t) { function e(e, n, i, r, o) { t.call(this, e), this.vectorContext = n, this.frameState = i, this.context = r, this.glContext = o; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const mT = yT; const _T = function () {}; _T.prototype.drawCustom = function (t, e, n) {}, _T.prototype.drawGeometry = function (t) {}, _T.prototype.setStyle = function (t) {}, _T.prototype.drawCircle = function (t, e) {}, _T.prototype.drawFeature = function (t, e) {}, _T.prototype.drawGeometryCollection = function (t, e) {}, _T.prototype.drawLineString = function (t, e) {}, _T.prototype.drawMultiLineString = function (t, e) {}, _T.prototype.drawMultiPoint = function (t, e) {}, _T.prototype.drawMultiPolygon = function (t, e) {}, _T.prototype.drawPoint = function (t, e) {}, _T.prototype.drawPolygon = function (t, e) {}, _T.prototype.drawText = function (t, e) {}, _T.prototype.setFillStrokeStyle = function (t, e) {}, _T.prototype.setImageStyle = function (t, e) {}, _T.prototype.setTextStyle = function (t, e) {}; const bT = _T; const wT = (function (t) {
      function e(e, n, i, r, o) { t.call(this), this.context_ = e, this.pixelRatio_ = n, this.extent_ = i, this.transform_ = r, this.viewRotation_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = 0, this.imageWidth_ = 0, this.text_ = '', this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = 0, this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = Jo(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.drawImages_ = function (t, e, n, i) { if (this.image_) { const r = Wo(t, e, n, 2, this.transform_, this.pixelCoordinates_); const o = this.context_; const s = this.tmpLocalTransform_; const a = o.globalAlpha; this.imageOpacity_ != 1 && (o.globalAlpha = a * this.imageOpacity_); let u = this.imageRotation_; this.imageRotateWithView_ && (u += this.viewRotation_); for (let c = 0, h = r.length; c < h; c += 2) { const l = r[c] - this.imageAnchorX_; const f = r[c + 1] - this.imageAnchorY_; if (u !== 0 || this.imageScale_ != 1) { const p = l + this.imageAnchorX_; const d = f + this.imageAnchorY_; ss(s, p, d, this.imageScale_, this.imageScale_, u, -p, -d), o.setTransform(...s); }o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, l, f, this.imageWidth_, this.imageHeight_); }u === 0 && this.imageScale_ == 1 || o.setTransform(1, 0, 0, 1, 0, 0), this.imageOpacity_ != 1 && (o.globalAlpha = a); } }, e.prototype.drawText_ = function (t, e, n, i) { if (this.textState_ && this.text_ !== '') { this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_); const r = Wo(t, e, n, i, this.transform_, this.pixelCoordinates_); const o = this.context_; let s = this.textRotation_; for (this.textRotateWithView_ && (s += this.viewRotation_); e < n; e += i) { const a = r[e] + this.textOffsetX_; const u = r[e + 1] + this.textOffsetY_; if (s !== 0 || this.textScale_ != 1) { const c = ss(this.tmpLocalTransform_, a, u, this.textScale_, this.textScale_, s, -a, -u); o.setTransform(...c); } this.textStrokeState_ && o.strokeText(this.text_, a, u), this.textFillState_ && o.fillText(this.text_, a, u); }s === 0 && this.textScale_ == 1 || o.setTransform(1, 0, 0, 1, 0, 0); } }, e.prototype.moveToLineTo_ = function (t, e, n, i, r) { const o = this.context_; const s = Wo(t, e, n, i, this.transform_, this.pixelCoordinates_); o.moveTo(s[0], s[1]); let a = s.length; r && (a -= 2); for (let u = 2; u < a; u += 2)o.lineTo(s[u], s[u + 1]); return r && o.closePath(), n; }, e.prototype.drawRings_ = function (t, e, n, i) { for (let r = 0, o = n.length; r < o; ++r)e = this.moveToLineTo_(t, e, n[r], i, !0); return e; }, e.prototype.drawCircle = function (t) { if (kt(this.extent_, t.getExtent())) { if (this.fillState_ || this.strokeState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); const e = _s(t, this.transform_, this.pixelCoordinates_); const n = e[2] - e[0]; const i = e[3] - e[1]; const r = Math.sqrt(n * n + i * i); const o = this.context_; o.beginPath(), o.arc(e[0], e[1], r, 0, 2 * Math.PI), this.fillState_ && o.fill(), this.strokeState_ && o.stroke(); } this.text_ !== '' && this.drawText_(t.getCenter(), 0, 2, 2); } }, e.prototype.setStyle = function (t) { this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText()); }, e.prototype.drawGeometry = function (t) { const e = t.getType(); switch (e) { case en.POINT: this.drawPoint(t); break; case en.LINE_STRING: this.drawLineString(t); break; case en.POLYGON: this.drawPolygon(t); break; case en.MULTI_POINT: this.drawMultiPoint(t); break; case en.MULTI_LINE_STRING: this.drawMultiLineString(t); break; case en.MULTI_POLYGON: this.drawMultiPolygon(t); break; case en.GEOMETRY_COLLECTION: this.drawGeometryCollection(t); break; case en.CIRCLE: this.drawCircle(t); break; default: } }, e.prototype.drawFeature = function (t, e) { const n = e.getGeometryFunction()(t); n && kt(this.extent_, n.getExtent()) && (this.setStyle(e), this.drawGeometry(n)); }, e.prototype.drawGeometryCollection = function (t) { for (let e = t.getGeometriesArray(), n = 0, i = e.length; n < i; ++n) this.drawGeometry(e[n]); }, e.prototype.drawPoint = function (t) { const e = t.getFlatCoordinates(); const n = t.getStride(); this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== '' && this.drawText_(e, 0, e.length, n); }, e.prototype.drawMultiPoint = function (t) { const e = t.getFlatCoordinates(); const n = t.getStride(); this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== '' && this.drawText_(e, 0, e.length, n); }, e.prototype.drawLineString = function (t) { if (kt(this.extent_, t.getExtent())) { if (this.strokeState_) { this.setContextStrokeState_(this.strokeState_); const e = this.context_; const n = t.getFlatCoordinates(); e.beginPath(), this.moveToLineTo_(n, 0, n.length, t.getStride(), !1), e.stroke(); } if (this.text_ !== '') { const i = t.getFlatMidpoint(); this.drawText_(i, 0, 2, 2); } } }, e.prototype.drawMultiLineString = function (t) { const e = t.getExtent(); if (kt(this.extent_, e)) { if (this.strokeState_) { this.setContextStrokeState_(this.strokeState_); const n = this.context_; const i = t.getFlatCoordinates(); let r = 0; const o = t.getEnds(); const s = t.getStride(); n.beginPath(); for (let a = 0, u = o.length; a < u; ++a)r = this.moveToLineTo_(i, r, o[a], s, !1); n.stroke(); } if (this.text_ !== '') { const c = t.getFlatMidpoints(); this.drawText_(c, 0, c.length, 2); } } }, e.prototype.drawPolygon = function (t) { if (kt(this.extent_, t.getExtent())) { if (this.strokeState_ || this.fillState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); const e = this.context_; e.beginPath(), this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()), this.fillState_ && e.fill(), this.strokeState_ && e.stroke(); } if (this.text_ !== '') { const n = t.getFlatInteriorPoint(); this.drawText_(n, 0, 2, 2); } } }, e.prototype.drawMultiPolygon = function (t) { if (kt(this.extent_, t.getExtent())) { if (this.strokeState_ || this.fillState_) { this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_); const e = this.context_; const n = t.getOrientedFlatCoordinates(); let i = 0; const r = t.getEndss(); const o = t.getStride(); e.beginPath(); for (let s = 0, a = r.length; s < a; ++s) { const u = r[s]; i = this.drawRings_(n, i, u, o); } this.fillState_ && e.fill(), this.strokeState_ && e.stroke(); } if (this.text_ !== '') { const c = t.getFlatInteriorPoints(); this.drawText_(c, 0, c.length, 2); } } }, e.prototype.setContextFillState_ = function (t) { const e = this.context_; const n = this.contextFillState_; n ? n.fillStyle != t.fillStyle && (n.fillStyle = e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = { fillStyle: t.fillStyle }); }, e.prototype.setContextStrokeState_ = function (t) {
        const e = this.context_; const n = this.contextStrokeState_; n ? (n.lineCap != t.lineCap && (n.lineCap = e.lineCap = t.lineCap), dv && (Li(n.lineDash, t.lineDash) || e.setLineDash(n.lineDash = t.lineDash), n.lineDashOffset != t.lineDashOffset && (n.lineDashOffset = e.lineDashOffset = t.lineDashOffset)), n.lineJoin != t.lineJoin && (n.lineJoin = e.lineJoin = t.lineJoin), n.lineWidth != t.lineWidth && (n.lineWidth = e.lineWidth = t.lineWidth), n.miterLimit != t.miterLimit && (n.miterLimit = e.miterLimit = t.miterLimit), n.strokeStyle != t.strokeStyle && (n.strokeStyle = e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, dv && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
          lineCap: t.lineCap, lineDash: t.lineDash, lineDashOffset: t.lineDashOffset, lineJoin: t.lineJoin, lineWidth: t.lineWidth, miterLimit: t.miterLimit, strokeStyle: t.strokeStyle,
        });
      }, e.prototype.setContextTextState_ = function (t) { const e = this.context_; const n = this.contextTextState_; const i = t.textAlign ? t.textAlign : Rv; n ? (n.font != t.font && (n.font = e.font = t.font), n.textAlign != i && (n.textAlign = e.textAlign = i), n.textBaseline != t.textBaseline && (n.textBaseline = e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = i, e.textBaseline = t.textBaseline, this.contextTextState_ = { font: t.font, textAlign: i, textBaseline: t.textBaseline }); }, e.prototype.setFillStrokeStyle = function (t, e) {
        if (t) { const n = t.getColor(); this.fillState_ = { fillStyle: av(n || wv) }; } else this.fillState_ = null; if (e) {
          const i = e.getColor(); const r = e.getLineCap(); const o = e.getLineDash(); const s = e.getLineDashOffset(); const a = e.getLineJoin(); const u = e.getWidth(); const c = e.getMiterLimit(); this.strokeState_ = {
            lineCap: void 0 !== r ? r : xv, lineDash: o || Ev, lineDashOffset: s || Sv, lineJoin: void 0 !== a ? a : Tv, lineWidth: this.pixelRatio_ * (void 0 !== u ? u : Lv), miterLimit: void 0 !== c ? c : Ov, strokeStyle: av(i || Cv),
          };
        } else this.strokeState_ = null;
      }, e.prototype.setImageStyle = function (t) { if (t) { const e = t.getAnchor(); const n = t.getImage(1); const i = t.getOrigin(); const r = t.getSize(); this.imageAnchorX_ = e[0], this.imageAnchorY_ = e[1], this.imageHeight_ = r[1], this.image_ = n, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = i[0], this.imageOriginY_ = i[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation(), this.imageScale_ = t.getScale() * this.pixelRatio_, this.imageWidth_ = r[0]; } else this.image_ = null; }, e.prototype.setTextStyle = function (t) {
        if (t) {
          const e = t.getFill(); if (e) { const n = e.getColor(); this.textFillState_ = { fillStyle: av(n || wv) }; } else this.textFillState_ = null; const i = t.getStroke(); if (i) {
            const r = i.getColor(); const o = i.getLineCap(); const s = i.getLineDash(); const a = i.getLineDashOffset(); const u = i.getLineJoin(); const c = i.getWidth(); const h = i.getMiterLimit(); this.textStrokeState_ = {
              lineCap: void 0 !== o ? o : xv, lineDash: s || Ev, lineDashOffset: a || Sv, lineJoin: void 0 !== u ? u : Tv, lineWidth: void 0 !== c ? c : Lv, miterLimit: void 0 !== h ? h : Ov, strokeStyle: av(r || Cv),
            };
          } else this.textStrokeState_ = null; const l = t.getFont(); const f = t.getOffsetX(); const p = t.getOffsetY(); const d = t.getRotateWithView(); const v = t.getRotation(); const g = t.getScale(); const y = t.getText(); const m = t.getTextAlign(); const _ = t.getTextBaseline(); this.textState_ = { font: void 0 !== l ? l : bv, textAlign: void 0 !== m ? m : Rv, textBaseline: void 0 !== _ ? _ : Iv }, this.text_ = void 0 !== y ? y : '', this.textOffsetX_ = void 0 !== f ? this.pixelRatio_ * f : 0, this.textOffsetY_ = void 0 !== p ? this.pixelRatio_ * p : 0, this.textRotateWithView_ = void 0 !== d && d, this.textRotation_ = void 0 !== v ? v : 0, this.textScale_ = this.pixelRatio_ * (void 0 !== g ? g : 1);
        } else this.text_ = '';
      }, e;
    }(bT)); const xT = wT; const ET = (function (t) { function e(e) { t.call(this), this.map_ = e, this.layerRenderers_ = {}, this.layerRendererListeners_ = {}, this.layerRendererConstructors_ = []; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.dispatchRenderEvent = function (t, e) { W(); }, e.prototype.registerLayerRenderers = function (t) { this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, t); }, e.prototype.calculateMatrices2D = function (t) { const e = t.viewState; const n = t.coordinateToPixelTransform; const i = t.pixelToCoordinateTransform; ss(n, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]), as(ns(i, n)); }, e.prototype.removeLayerRenderers = function () { for (const t in this.layerRenderers_) this.removeLayerRendererByKey_(t).dispose(); }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r, o, s) { let a; const u = e.viewState; const c = u.resolution; function h(t, n) { const o = e.layerStates[H(n)].managed; if (!(H(t) in e.skippedFeatureUids) || o) return i.call(r, t, o ? n : null); } const l = u.projection; let f = t; if (l.canWrapX()) { const p = l.getExtent(); const d = jt(p); const v = t[0]; if (v < p[0] || v > p[2]) { const g = Math.ceil((p[0] - v) / d); f = [v + d * g, t[1]]; } } let y; const m = e.layerStatesArray; const _ = m.length; for (y = _ - 1; y >= 0; --y) { const b = m[y]; const w = b.layer; if (C_(b, c) && o.call(s, w)) { const x = this.getLayerRenderer(w); const E = w.getSource(); if (E && (a = x.forEachFeatureAtCoordinate(E.getWrapX() ? f : t, e, n, h)), a) return a; } } }, e.prototype.forEachLayerAtPixel = function (t, e, n, i, r, o, s) { return W(); }, e.prototype.hasFeatureAtCoordinate = function (t, e, n, i, r) { const o = this.forEachFeatureAtCoordinate(t, e, n, Se, this, i, r); return void 0 !== o; }, e.prototype.getLayerRenderer = function (t) { const e = H(t); if (e in this.layerRenderers_) return this.layerRenderers_[e]; for (var n, i = 0, r = this.layerRendererConstructors_.length; i < r; ++i) { const o = this.layerRendererConstructors_[i]; if (o.handles(t)) { n = o.create(this, t); break; } } if (!n) throw new Error(`Unable to create renderer for layer: ${t.getType()}`); return this.layerRenderers_[e] = n, this.layerRendererListeners_[e] = _e(n, Ae.CHANGE, this.handleLayerRendererChange_, this), n; }, e.prototype.getLayerRendererByKey = function (t) { return this.layerRenderers_[t]; }, e.prototype.getLayerRenderers = function () { return this.layerRenderers_; }, e.prototype.getMap = function () { return this.map_; }, e.prototype.handleLayerRendererChange_ = function () { this.map_.render(); }, e.prototype.removeLayerRendererByKey_ = function (t) { const e = this.layerRenderers_[t]; return delete this.layerRenderers_[t], xe(this.layerRendererListeners_[t]), delete this.layerRendererListeners_[t], e; }, e.prototype.removeUnusedLayerRenderers_ = function (t, e) { for (const n in this.layerRenderers_)e && n in e.layerStates || this.removeLayerRendererByKey_(n).dispose(); }, e.prototype.renderFrame = function (t) { W(); }, e.prototype.scheduleExpireIconCache = function (t) { t.postRenderFunctions.push(ST); }, e.prototype.scheduleRemoveUnusedLayerRenderers = function (t) { for (const e in this.layerRenderers_) if (!(e in t.layerStates)) return void t.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this)); }, e; }(fe)); function ST(t, e) { tg.expire(); } function TT(t, e) { return t.zIndex - e.zIndex; } const OT = ET; const CT = []; const RT = (function (t) { function e(e) { t.call(this, e); const n = e.getViewport(); this.context_ = ke(), this.canvas_ = this.context_.canvas, this.canvas_.style.width = '100%', this.canvas_.style.height = '100%', this.canvas_.style.display = 'block', this.canvas_.className = Up, n.insertBefore(this.canvas_, n.childNodes[0] || null), this.renderedVisible_ = !0, this.transform_ = Jo(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.dispatchRenderEvent = function (t, e) { const n = this.getMap(); const i = this.context_; if (n.hasListener(t)) { const r = e.extent; const o = e.pixelRatio; const s = e.viewState; const a = s.rotation; const u = this.getTransform(e); const c = new xT(i, o, r, u, a); const h = new mT(t, c, e, i, null); n.dispatchEvent(h); } }, e.prototype.getTransform = function (t) { const e = t.viewState; const n = this.canvas_.width / 2; const i = this.canvas_.height / 2; const r = t.pixelRatio / e.resolution; const o = -r; const s = -e.rotation; const a = -e.center[0]; const u = -e.center[1]; return ss(this.transform_, n, i, r, o, s, a, u); }, e.prototype.renderFrame = function (t) { if (t) { const e = this.context_; const n = t.pixelRatio; const i = Math.round(t.size[0] * n); const r = Math.round(t.size[1] * n); this.canvas_.width != i || this.canvas_.height != r ? (this.canvas_.width = i, this.canvas_.height = r) : e.clearRect(0, 0, i, r); const o = t.viewState.rotation; this.calculateMatrices2D(t), this.dispatchRenderEvent(T_.PRECOMPOSE, t); const s = t.layerStatesArray; Ai(s, TT), o && (e.save(), Gv(e, o, i / 2, r / 2)); let a; let u; const c = t.viewState.resolution; for (a = 0, u = s.length; a < u; ++a) { const h = s[a]; const l = h.layer; const f = this.getLayerRenderer(l); C_(h, c) && h.sourceState == vi.READY && (f.prepareFrame(t, h) && f.composeFrame(t, h, e)); }o && e.restore(), this.dispatchRenderEvent(T_.POSTCOMPOSE, t), this.renderedVisible_ || (this.canvas_.style.display = '', this.renderedVisible_ = !0), this.scheduleRemoveUnusedLayerRenderers(t), this.scheduleExpireIconCache(t); } else this.renderedVisible_ && (this.canvas_.style.display = 'none', this.renderedVisible_ = !1); }, e.prototype.forEachLayerAtPixel = function (t, e, n, i, r, o, s) { let a; let u; const c = e.viewState; const h = c.resolution; const l = e.layerStatesArray; const f = l.length; const p = is(e.pixelToCoordinateTransform, t.slice()); for (u = f - 1; u >= 0; --u) { const d = l[u]; const v = d.layer; if (C_(d, h) && o.call(s, v)) { const g = this.getLayerRenderer(v); if (a = g.forEachLayerAtCoordinate(p, e, n, i, r), a) return a; } } }, e.prototype.registerLayerRenderers = function (e) { t.prototype.registerLayerRenderers.call(this, e); for (let n = 0, i = e.length; n < i; ++n) { const r = e[n]; Oi(CT, r) || CT.push(r); } }, e; }(OT)); const IT = RT; const PT = (function (t) { function e(e) { t.call(this), this.layer_ = e; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createLoadedTileFinder = function (t, e, n) { return function (i, r) { function o(t) { n[i] || (n[i] = {}), n[i][t.tileCoord.toString()] = t; } return t.forEachLoadedTile(e, i, r, o); }; }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i) {}, e.prototype.getLayer = function () { return this.layer_; }, e.prototype.handleImageChange_ = function (t) { const e = t.target; e.getState() === _v.LOADED && this.renderIfReadyAndVisible(); }, e.prototype.hasFeatureAtCoordinate = function (t, e) { return !1; }, e.prototype.loadImage = function (t) { let e = t.getState(); return e != _v.LOADED && e != _v.ERROR && _e(t, Ae.CHANGE, this.handleImageChange_, this), e == _v.IDLE && (t.load(), e = t.getState()), e == _v.LOADED; }, e.prototype.renderIfReadyAndVisible = function () { const t = this.getLayer(); t.getVisible() && t.getSourceState() == vi.READY && this.changed(); }, e.prototype.scheduleExpireCache = function (t, e) { if (e.canExpireCache()) { const n = function (t, e, n) { const i = H(t); i in n.usedTiles && t.expireCache(n.viewState.projection, n.usedTiles[i]); }.bind(null, e); t.postRenderFunctions.push(n); } }, e.prototype.updateUsedTiles = function (t, e, n, i) { const r = H(e); const o = n.toString(); r in t ? o in t[r] ? t[r][o].extend(i) : t[r][o] = i : (t[r] = {}, t[r][o] = i); }, e.prototype.manageTilePyramid = function (t, e, n, i, r, o, s, a, u, c) { const h = H(e); h in t.wantedTiles || (t.wantedTiles[h] = {}); let l; let f; let p; let d; let v; let g; const y = t.wantedTiles[h]; const m = t.tileQueue; const _ = n.getMinZoom(); for (g = _; g <= s; ++g) for (f = n.getTileRangeForExtentAndZ(o, g, f), p = n.getResolution(g), d = f.minX; d <= f.maxX; ++d) for (v = f.minY; v <= f.maxY; ++v)s - g <= a ? (l = e.getTile(g, d, v, i, r), l.getState() == se.IDLE && (y[l.getKey()] = !0, m.isKeyQueued(l.getKey()) || m.enqueue([l, h, n.getTileCoordCenter(l.tileCoord), p])), void 0 !== u && u.call(c, l)) : e.useTile(g, d, v, r); }, e; }(ci)); const LT = PT; const AT = (function (t) { function e(e) { t.call(this, e), this.renderedResolution, this.transform_ = Jo(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.clip = function (t, e, n) { const i = e.pixelRatio; const r = e.size[0] * i; const o = e.size[1] * i; const s = e.viewState.rotation; const a = At(n); const u = Ft(n); const c = Ot(n); const h = Tt(n); is(e.coordinateToPixelTransform, a), is(e.coordinateToPixelTransform, u), is(e.coordinateToPixelTransform, c), is(e.coordinateToPixelTransform, h), t.save(), Gv(t, -s, r / 2, o / 2), t.beginPath(), t.moveTo(a[0] * i, a[1] * i), t.lineTo(u[0] * i, u[1] * i), t.lineTo(c[0] * i, c[1] * i), t.lineTo(h[0] * i, h[1] * i), t.clip(), Gv(t, s, r / 2, o / 2); }, e.prototype.dispatchComposeEvent_ = function (t, e, n, i) { const r = this.getLayer(); if (r.hasListener(t)) { const o = n.size[0] * n.pixelRatio; const s = n.size[1] * n.pixelRatio; const a = n.viewState.rotation; Gv(e, -a, o / 2, s / 2); const u = void 0 !== i ? i : this.getTransform(n, 0); const c = new xT(e, n.pixelRatio, n.extent, u, n.viewState.rotation); const h = new mT(t, c, n, e, null); r.dispatchEvent(h), Gv(e, a, o / 2, s / 2); } }, e.prototype.forEachLayerAtCoordinate = function (t, e, n, i, r) { const o = this.forEachFeatureAtCoordinate(t, e, n, Se); return o ? i.call(r, this.getLayer(), null) : void 0; }, e.prototype.postCompose = function (t, e, n, i) { this.dispatchComposeEvent_(T_.POSTCOMPOSE, t, e, i); }, e.prototype.preCompose = function (t, e, n) { this.dispatchComposeEvent_(T_.PRECOMPOSE, t, e, n); }, e.prototype.dispatchRenderEvent = function (t, e, n) { this.dispatchComposeEvent_(T_.RENDER, t, e, n); }, e.prototype.getTransform = function (t, e) { const n = t.viewState; const i = t.pixelRatio; const r = i * t.size[0] / 2; const o = i * t.size[1] / 2; const s = i / n.resolution; const a = -s; const u = -n.rotation; const c = -n.center[0] + e; const h = -n.center[1]; return ss(this.transform_, r, o, s, a, u, c, h); }, e.prototype.composeFrame = function (t, e, n) { W(); }, e.prototype.prepareFrame = function (t, e) { return W(); }, e; }(LT)); const FT = AT; const jT = (function (t) { function e(e) { t.call(this, e), this.coordinateToCanvasPixelTransform = Jo(), this.hitCanvasContext_ = null; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.composeFrame = function (t, e, n) { this.preCompose(n, t); const i = this.getImage(); if (i) { const r = e.extent; const o = void 0 !== r && !ut(r, t.extent) && kt(r, t.extent); o && this.clip(n, t, r); const s = this.getImageTransform(); const a = n.globalAlpha; n.globalAlpha = e.opacity; const u = s[4]; const c = s[5]; const h = i.width * s[0]; const l = i.height * s[3]; h >= 0.5 && l >= 0.5 && n.drawImage(i, 0, 0, +i.width, +i.height, Math.round(u), Math.round(c), Math.round(h), Math.round(l)), n.globalAlpha = a, o && n.restore(); } this.postCompose(n, t, e); }, e.prototype.getImage = function () { return W(); }, e.prototype.getImageTransform = function () { return W(); }, e.prototype.forEachLayerAtCoordinate = function (t, e, n, i, r) { if (this.getImage()) { const o = is(this.coordinateToCanvasPixelTransform, t.slice()); nm(o, e.viewState.resolution / this.renderedResolution), this.hitCanvasContext_ || (this.hitCanvasContext_ = ke(1, 1)), this.hitCanvasContext_.clearRect(0, 0, 1, 1), this.hitCanvasContext_.drawImage(this.getImage(), o[0], o[1], 1, 1, 0, 0, 1, 1); const s = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data; return s[3] > 0 ? i.call(r, this.getLayer(), s) : void 0; } }, e; }(FT)); const kT = jT; const MT = (function (t) { function e(n) { if (t.call(this, n), this.image_ = null, this.imageTransform_ = Jo(), this.skippedFeatures_ = [], this.vectorRenderer_ = null, n.getType() === S_.VECTOR) for (let i = 0, r = CT.length; i < r; ++i) { const o = CT[i]; if (o !== e && o.handles(n)) { this.vectorRenderer_ = new o(n); break; } } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.vectorRenderer_ && this.vectorRenderer_.dispose(), t.prototype.disposeInternal.call(this); }, e.prototype.getImage = function () { return this.image_ ? this.image_.getImage() : null; }, e.prototype.getImageTransform = function () { return this.imageTransform_; }, e.prototype.prepareFrame = function (t, e) { let n; const i = t.pixelRatio; const r = t.size; const o = t.viewState; const s = o.center; const a = o.resolution; const u = this.getLayer(); const c = u.getSource(); const h = t.viewHints; const l = this.vectorRenderer_; let f = t.extent; if (l || void 0 === e.extent || (f = Lt(f, e.extent)), !h[wS.ANIMATING] && !h[wS.INTERACTING] && !Mt(f)) { let p = o.projection; if (!oe) { const d = c.getProjection(); d && (p = d); } let v = this.skippedFeatures_; if (l) { const g = l.context; const y = qt({}, t, { size: [jt(f) / a, Pt(f) / a], viewState: qt({}, t.viewState, { rotation: 0 }) }); const m = Object.keys(y.skippedFeatureUids).sort(); n = new gT(f, a, i, g.canvas, ((t) => { !l.prepareFrame(y, e) || !l.replayGroupChanged && Li(v, m) || (g.canvas.width = y.size[0] * i, g.canvas.height = y.size[1] * i, l.compose(g, y, e), v = m, t()); })); } else n = c.getImage(f, a, i, p); n && this.loadImage(n) && (this.image_ = n, this.skippedFeatures_ = v); } if (this.image_) { n = this.image_; const _ = n.getExtent(); const b = n.getResolution(); const w = n.getPixelRatio(); const x = i * b / (a * w); const E = ss(this.imageTransform_, i * r[0] / 2, i * r[1] / 2, x, x, 0, w * (_[0] - s[0]) / b, w * (s[1] - _[3]) / b); ss(this.coordinateToCanvasPixelTransform, i * r[0] / 2 - E[4], i * r[1] / 2 - E[5], i / a, -i / a, 0, -s[0], -s[1]), this.renderedResolution = b * i / w; } return !!this.image_; }, e.prototype.forEachFeatureAtCoordinate = function (e, n, i, r) { return this.vectorRenderer_ ? this.vectorRenderer_.forEachFeatureAtCoordinate(e, n, i, r) : t.prototype.forEachFeatureAtCoordinate.call(this, e, n, i, r); }, e; }(kT)); MT.handles = function (t) { return t.getType() === S_.IMAGE || t.getType() === S_.VECTOR && t.getRenderMode() === I_.IMAGE; }, MT.create = function (t, e) { return new MT(e); }; const NT = MT; const DT = (function (t) { function e(e, n) { t.call(this, e), this.context = n ? null : ke(), this.oversampling_, this.renderedExtent_ = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = lt(), this.tmpTileRange_ = new Ei(0, 0, 0, 0), this.imageTransform_ = Jo(), this.zDirection = 0; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isDrawableTile_ = function (t) { const e = this.getLayer(); const n = t.getState(); const i = e.getUseInterimTilesOnError(); return n == se.LOADED || n == se.EMPTY || n == se.ERROR && !i; }, e.prototype.getTile = function (t, e, n, i, r) { const o = this.getLayer(); const s = o.getSource(); let a = s.getTile(t, e, n, i, r); return a.getState() == se.ERROR && (o.getUseInterimTilesOnError() ? o.getPreload() > 0 && (this.newTiles_ = !0) : a.setState(se.LOADED)), this.isDrawableTile_(a) || (a = a.getInterimTile()), a; }, e.prototype.prepareFrame = function (t, e) { const n = t.pixelRatio; const i = t.size; const r = t.viewState; const o = r.projection; const s = r.resolution; const a = r.center; const u = this.getLayer(); const c = u.getSource(); const h = c.getRevision(); const l = c.getTileGridForProjection(o); const f = l.getZForResolution(s, this.zDirection); const p = l.getResolution(f); let d = Math.round(s / p) || 1; let v = t.extent; if (void 0 !== e.extent && (v = Lt(v, e.extent)), Mt(v)) return !1; const g = l.getTileRangeForExtentAndZ(v, f); const y = l.getTileRangeExtent(f, g); const m = c.getTilePixelRatio(n); const _ = {}; _[f] = {}; let b; let w; let x; const E = this.createLoadedTileFinder(c, o, _); const S = t.viewHints; const T = S[wS.ANIMATING] || S[wS.INTERACTING]; const O = this.tmpExtent; const C = this.tmpTileRange_; for (this.newTiles_ = !1, w = g.minX; w <= g.maxX; ++w) for (x = g.minY; x <= g.maxY; ++x) if (!(Date.now() - t.time > 16 && T)) { if (b = this.getTile(f, w, x, n, o), this.isDrawableTile_(b)) { const R = H(this); if (b.getState() == se.LOADED) { _[f][b.tileCoord.toString()] = b; const I = b.inTransition(R); this.newTiles_ || !I && this.renderedTiles.indexOf(b) !== -1 || (this.newTiles_ = !0); } if (b.getAlpha(R, t.time) === 1) continue; } const P = l.getTileCoordChildTileRange(b.tileCoord, C, O); let L = !1; P && (L = E(f + 1, P)), L || l.forEachTileCoordParentTileRange(b.tileCoord, E, null, C, O); } const A = p * n / m * d; if (!(this.renderedResolution && Date.now() - t.time > 16 && T) && (this.newTiles_ || !this.renderedExtent_ || !ut(this.renderedExtent_, v) || this.renderedRevision != h || d != this.oversampling_ || !T && A != this.renderedResolution)) { const F = this.context; if (F) { const j = c.getTilePixelSize(f, n, o); const k = Math.round(g.getWidth() * j[0] / d); const M = Math.round(g.getHeight() * j[1] / d); const N = F.canvas; N.width != k || N.height != M ? (this.oversampling_ = d, N.width = k, N.height = M) : (this.renderedExtent_ && !yt(y, this.renderedExtent_) && F.clearRect(0, 0, k, M), d = this.oversampling_); } this.renderedTiles.length = 0; let D; let $; let G; let V; let B; let U; let z; let Y; let X; let W; let K; const q = Object.keys(_).map(Number); for (q.sort((t, e) => (t === f ? 1 : e === f ? -1 : t > e ? 1 : t < e ? -1 : 0)), B = 0, U = q.length; B < U; ++B) for (const Z in V = q[B], G = c.getTilePixelSize(V, n, o), D = l.getResolution(V), $ = D / p, Y = m * c.getGutterForProjection(o), X = _[V], X)b = X[Z], z = l.getTileCoordExtent(b.getTileCoord(), O), w = (z[0] - y[0]) / p * m / d, x = (y[3] - z[3]) / p * m / d, W = G[0] * $ / d, K = G[1] * $ / d, this.drawTileImage(b, t, e, w, x, W, K, Y, f === V), this.renderedTiles.push(b); this.renderedRevision = h, this.renderedResolution = p * n / m * d, this.renderedExtent_ = y; } const J = this.renderedResolution / s; const Q = ss(this.imageTransform_, n * i[0] / 2, n * i[1] / 2, J, J, 0, (this.renderedExtent_[0] - a[0]) / this.renderedResolution * n, (a[1] - this.renderedExtent_[3]) / this.renderedResolution * n); return ss(this.coordinateToCanvasPixelTransform, n * i[0] / 2 - Q[4], n * i[1] / 2 - Q[5], n / s, -n / s, 0, -a[0], -a[1]), this.updateUsedTiles(t.usedTiles, c, f, g), this.manageTilePyramid(t, c, l, n, o, v, f, u.getPreload()), this.scheduleExpireCache(t, c), this.renderedTiles.length > 0; }, e.prototype.drawTileImage = function (t, e, n, i, r, o, s, a, u) { const c = this.getTileImage(t); if (c) { const h = H(this); const l = u ? t.getAlpha(h, e.time) : 1; const f = this.getLayer(); const p = f.getSource(); l !== 1 || p.getOpaque(e.viewState.projection) || this.context.clearRect(i, r, o, s); const d = l !== this.context.globalAlpha; d && (this.context.save(), this.context.globalAlpha = l), this.context.drawImage(c, a, a, c.width - 2 * a, c.height - 2 * a, i, r, o, s), d && this.context.restore(), l !== 1 ? e.animate = !0 : u && t.endTransition(h); } }, e.prototype.getImage = function () { const t = this.context; return t ? t.canvas : null; }, e.prototype.getImageTransform = function () { return this.imageTransform_; }, e.prototype.getTileImage = function (t) { return t.getImage(); }, e; }(kT)); DT.handles = function (t) { return t.getType() === S_.TILE; }, DT.create = function (t, e) { return new DT(e); }, DT.prototype.getLayer; const $T = DT; const GT = function () {}; GT.prototype.getReplay = function (t, e) { return W(); }, GT.prototype.isEmpty = function () { return W(); }, GT.prototype.addDeclutter = function (t) { return W(); }; const VT = GT; const BT = {
      CIRCLE: 'Circle', DEFAULT: 'Default', IMAGE: 'Image', LINE_STRING: 'LineString', POLYGON: 'Polygon', TEXT: 'Text',
    }; function UT(t, e, n, i, r, o, s, a) { const u = []; const c = t[e] > t[n - i]; const h = r.length; let l = t[e]; let f = t[e + 1]; e += i; for (var p, d, v, g = t[e], y = t[e + 1], m = 0, _ = Math.sqrt(Math.pow(g - l, 2) + Math.pow(y - f, 2)), b = '', w = 0, x = 0; x < h; ++x) { d = c ? h - x - 1 : x; const E = r.charAt(d); b = c ? E + b : b + E; const S = o(b) - w; w += S; const T = s + S / 2; while (e < n - i && m + _ < T)l = g, f = y, e += i, g = t[e], y = t[e + 1], m += _, _ = Math.sqrt(Math.pow(g - l, 2) + Math.pow(y - f, 2)); const O = T - m; let C = Math.atan2(y - f, g - l); if (c && (C += C > 0 ? -Math.PI : Math.PI), void 0 !== v) { let R = C - v; if (R += R > Math.PI ? -2 * Math.PI : R < -Math.PI ? 2 * Math.PI : 0, Math.abs(R) > a) return null; } const I = O / _; const P = Ht(l, g, I); const L = Ht(f, y, I); v == C ? (c && (p[0] = P, p[1] = L, p[2] = S / 2), p[4] = b) : (b = E, w = S, p = [P, L, S / 2, C, b], c ? u.unshift(p) : u.push(p), v = C), s += S; } return u; } const zT = {
      BEGIN_GEOMETRY: 0, BEGIN_PATH: 1, CIRCLE: 2, CLOSE_PATH: 3, CUSTOM: 4, DRAW_CHARS: 5, DRAW_IMAGE: 6, END_GEOMETRY: 7, FILL: 8, MOVE_TO_LINE_TO: 9, SET_FILL_STYLE: 10, SET_STROKE_STYLE: 11, STROKE: 12,
    }; const YT = [zT.FILL]; const XT = [zT.STROKE]; const WT = [zT.BEGIN_PATH]; const KT = [zT.CLOSE_PATH]; const HT = zT; const qT = [BT.POLYGON, BT.CIRCLE, BT.LINE_STRING, BT.IMAGE, BT.TEXT, BT.DEFAULT]; const ZT = {
      left: 0, end: 0, center: 0.5, right: 1, start: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1,
    }; const JT = lt(); const QT = Jo(); const tO = (function (t) {
      function e(e, n, i, r, o, s) { t.call(this), this.declutterTree = s, this.tolerance = e, this.maxExtent = n, this.overlaps = o, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = i, this.alignFill_, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.coordinateCache_ = {}, this.renderedTransform_ = Jo(), this.hitDetectionInstructions = [], this.pixelCoordinates_ = null, this.state = {}, this.viewRotation_ = 0; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.replayTextBackground_ = function (t, e, n, i, r, o, s) { t.beginPath(), t.moveTo(...e), t.lineTo(...n), t.lineTo(...i), t.lineTo(...r), t.lineTo(...e), o && (this.alignFill_ = o[2], this.fill_(t)), s && (this.setStrokeStyle_(t, s), t.stroke()); }, e.prototype.replayImage_ = function (t, e, n, i, r, o, s, a, u, c, h, l, f, p, d, v, g, y) { const m = g || y; r *= f, o *= f, e -= r, n -= o; let _; let b; let w; let x; const E = d + c > i.width ? i.width - c : d; const S = a + h > i.height ? i.height - h : a; const T = v[3] + E * f + v[1]; const O = v[0] + S * f + v[2]; const C = e - v[3]; const R = n - v[0]; (m || l !== 0) && (_ = [C, R], b = [C + T, R], w = [C + T, R + O], x = [C, R + O]); let I = null; if (l !== 0) { const P = e + r; const L = n + o; I = ss(QT, P, L, 1, 1, l, -P, -L), pt(JT), _t(JT, is(QT, _)), _t(JT, is(QT, b)), _t(JT, is(QT, w)), _t(JT, is(QT, x)); } else ft(C, R, C + T, R + O, JT); const A = t.canvas; const F = y ? y[2] * f / 2 : 0; const j = JT[0] - F <= A.width && JT[2] + F >= 0 && JT[1] - F <= A.height && JT[3] + F >= 0; if (p && (e = Math.round(e), n = Math.round(n)), s) { if (!j && s[4] == 1) return; mt(s, JT); const k = j ? [t, I ? I.slice(0) : null, u, i, c, h, E, S, e, n, f] : null; k && m && k.push(g, y, _, b, w, x), s.push(k); } else j && (m && this.replayTextBackground_(t, _, b, w, x, g, y), Bv(t, I, u, i, c, h, E, S, e, n, f)); }, e.prototype.applyPixelRatio = function (t) { const e = this.pixelRatio; return e == 1 ? t : t.map(t => t * e); }, e.prototype.appendFlatCoordinates = function (t, e, n, i, r, o) { let s = this.coordinates.length; const a = this.getBufferedMaxExtent(); o && (e += i); let u; let c; let h; const l = [t[e], t[e + 1]]; const f = [NaN, NaN]; let p = !0; for (u = e + i; u < n; u += i)f[0] = t[u], f[1] = t[u + 1], h = ht(a, f), h !== c ? (p && (this.coordinates[s++] = l[0], this.coordinates[s++] = l[1]), this.coordinates[s++] = f[0], this.coordinates[s++] = f[1], p = !1) : h === et.INTERSECTING ? (this.coordinates[s++] = f[0], this.coordinates[s++] = f[1], p = !1) : p = !0, l[0] = f[0], l[1] = f[1], c = h; return (r && p || u === e + i) && (this.coordinates[s++] = l[0], this.coordinates[s++] = l[1]), s; }, e.prototype.drawCustomCoordinates_ = function (t, e, n, i, r) { for (let o = 0, s = n.length; o < s; ++o) { const a = n[o]; const u = this.appendFlatCoordinates(t, e, a, i, !1, !1); r.push(u), e = a; } return e; }, e.prototype.drawCustom = function (t, e, n) { this.beginGeometry(t, e); let i; let r; let o; let s; let a; const u = t.getType(); const c = t.getStride(); const h = this.coordinates.length; if (u == en.MULTI_POLYGON) { t = t, i = t.getOrientedFlatCoordinates(), s = []; const l = t.getEndss(); a = 0; for (let f = 0, p = l.length; f < p; ++f) { const d = []; a = this.drawCustomCoordinates_(i, a, l[f], c, d), s.push(d); } this.instructions.push([HT.CUSTOM, h, s, t, n, js]); } else u == en.POLYGON || u == en.MULTI_LINE_STRING ? (o = [], i = u == en.POLYGON ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(), a = this.drawCustomCoordinates_(i, 0, t.getEnds(), c, o), this.instructions.push([HT.CUSTOM, h, o, t, n, Fs])) : u == en.LINE_STRING || u == en.MULTI_POINT ? (i = t.getFlatCoordinates(), r = this.appendFlatCoordinates(i, 0, i.length, c, !1, !1), this.instructions.push([HT.CUSTOM, h, r, t, n, As])) : u == en.POINT && (i = t.getFlatCoordinates(), this.coordinates.push(i[0], i[1]), r = this.coordinates.length, this.instructions.push([HT.CUSTOM, h, r, t, n])); this.endGeometry(t, e); }, e.prototype.beginGeometry = function (t, e) { this.beginGeometryInstruction1_ = [HT.BEGIN_GEOMETRY, e, 0], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [HT.BEGIN_GEOMETRY, e, 0], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_); }, e.prototype.finish = function () {}, e.prototype.fill_ = function (t) { if (this.alignFill_) { const e = is(this.renderedTransform_, [0, 0]); const n = 512 * this.pixelRatio; t.translate(e[0] % n, e[1] % n), t.rotate(this.viewRotation_); }t.fill(), this.alignFill_ && t.setTransform(...Vv); }, e.prototype.setStrokeStyle_ = function (t, e) { t.strokeStyle = e[1], t.lineWidth = e[2], t.lineCap = e[3], t.lineJoin = e[4], t.miterLimit = e[5], dv && (t.lineDashOffset = e[7], t.setLineDash(e[6])); }, e.prototype.renderDeclutter_ = function (t, e) {
        if (t && t.length > 5) {
          const n = t[4]; if (n == 1 || n == t.length - 5) {
            const i = {
              minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e,
            }; if (!this.declutterTree.collides(i)) { this.declutterTree.insert(i); for (let r = 5, o = t.length; r < o; ++r) { const s = t[r]; s && (s.length > 11 && this.replayTextBackground_(s[0], s[13], s[14], s[15], s[16], s[11], s[12]), Bv(...s)); } }t.length = 5, pt(t);
          }
        }
      }, e.prototype.replay_ = function (t, e, n, i, r, o, s) {
        let a; this.pixelCoordinates_ && Li(e, this.renderedTransform_) ? a = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), a = Wo(this.coordinates, 0, this.coordinates.length, 2, e, this.pixelCoordinates_), ns(this.renderedTransform_, e)); let u; let c; let h; let l; let f; let p; let d; let v; let g; let y; let m; let _; const b = !Qt(n); let w = 0; const x = i.length; let E = 0; let S = 0; let T = 0; let O = null; let C = null; const R = this.coordinateCache_; const I = this.viewRotation_; const P = {
          context: t, pixelRatio: this.pixelRatio, resolution: this.resolution, rotation: I,
        }; const L = this.instructions != i || this.overlaps ? 0 : 200; while (w < x) { const A = i[w]; const F = A[0]; switch (F) { case HT.BEGIN_GEOMETRY: y = A[1], b && n[H(y)] || !y.getGeometry() ? w = A[2] : void 0 === s || kt(s, y.getGeometry().getExtent()) ? ++w : w = A[2] + 1; break; case HT.BEGIN_PATH: S > L && (this.fill_(t), S = 0), T > L && (t.stroke(), T = 0), S || T || (t.beginPath(), l = f = NaN), ++w; break; case HT.CIRCLE: E = A[1]; var j = a[E]; var k = a[E + 1]; var M = a[E + 2]; var N = a[E + 3]; var D = M - j; var $ = N - k; var G = Math.sqrt(D * D + $ * $); t.moveTo(j + G, k), t.arc(j, k, G, 0, 2 * Math.PI, !0), ++w; break; case HT.CLOSE_PATH: t.closePath(), ++w; break; case HT.CUSTOM: E = A[1], u = A[2]; var V = A[3]; var B = A[4]; var U = A.length == 6 ? A[5] : void 0; P.geometry = V, P.feature = y, w in R || (R[w] = []); var z = R[w]; U ? U(a, E, u, 2, z) : (z[0] = a[E], z[1] = a[E + 1], z.length = 2), B(z, P), ++w; break; case HT.DRAW_IMAGE: E = A[1], u = A[2], g = A[3], c = A[4], h = A[5], v = o ? null : A[6]; var Y = A[7]; var X = A[8]; var W = A[9]; var K = A[10]; var q = A[11]; var Z = A[12]; var J = A[13]; var Q = A[14]; var tt = void 0; var et = void 0; var nt = void 0; for (A.length > 16 ? (tt = A[15], et = A[16], nt = A[17]) : (tt = Pv, et = nt = !1), q && (Z += I); E < u; E += 2) this.replayImage_(t, a[E], a[E + 1], g, c, h, v, Y, X, W, K, Z, J, r, Q, tt, et ? O : null, nt ? C : null); this.renderDeclutter_(v, y), ++w; break; case HT.DRAW_CHARS: var it = A[1]; var rt = A[2]; var ot = A[3]; v = o ? null : A[4]; var st = A[5]; var at = A[6]; var ut = A[7]; var ct = A[8]; var ht = A[9]; var lt = A[10]; var ft = A[11]; var pt = A[12]; var dt = A[13]; var vt = A[14]; var gt = Ks(a, it, rt, 2); var yt = ct(pt); if (st || yt <= gt) { const mt = this; const _t = mt.textStates[dt].textAlign; const bt = (gt - yt) * ZT[_t]; const wt = UT(a, it, rt, 2, pt, ct, bt, ut); if (wt) { let xt = void 0; let Et = void 0; let St = void 0; let Tt = void 0; let Ot = void 0; if (lt) for (xt = 0, Et = wt.length; xt < Et; ++xt)Ot = wt[xt], St = Ot[4], Tt = mt.getImage(St, dt, '', lt), c = Ot[2] + ft, h = ot * Tt.height + 2 * (0.5 - ot) * ft - ht, this.replayImage_(t, Ot[0], Ot[1], Tt, c, h, v, Tt.height, 1, 0, 0, Ot[3], vt, !1, Tt.width, Pv, null, null); if (at) for (xt = 0, Et = wt.length; xt < Et; ++xt)Ot = wt[xt], St = Ot[4], Tt = mt.getImage(St, dt, at, ''), c = Ot[2], h = ot * Tt.height - ht, this.replayImage_(t, Ot[0], Ot[1], Tt, c, h, v, Tt.height, 1, 0, 0, Ot[3], vt, !1, Tt.width, Pv, null, null); } } this.renderDeclutter_(v, y), ++w; break; case HT.END_GEOMETRY: if (void 0 !== o) { y = A[1]; const Ct = o(y); if (Ct) return Ct; }++w; break; case HT.FILL: L ? S++ : this.fill_(t), ++w; break; case HT.MOVE_TO_LINE_TO: for (E = A[1], u = A[2], m = a[E], _ = a[E + 1], p = m + 0.5 | 0, d = _ + 0.5 | 0, p === l && d === f || (t.moveTo(m, _), l = p, f = d), E += 2; E < u; E += 2)m = a[E], _ = a[E + 1], p = m + 0.5 | 0, d = _ + 0.5 | 0, E != u - 2 && p === l && d === f || (t.lineTo(m, _), l = p, f = d); ++w; break; case HT.SET_FILL_STYLE: O = A, this.alignFill_ = A[2], S && (this.fill_(t), S = 0, T && (t.stroke(), T = 0)), t.fillStyle = A[1], ++w; break; case HT.SET_STROKE_STYLE: C = A, T && (t.stroke(), T = 0), this.setStrokeStyle_(t, A), ++w; break; case HT.STROKE: L ? T++ : t.stroke(), ++w; break; default: ++w; break; } }S && this.fill_(t), T && t.stroke();
      }, e.prototype.replay = function (t, e, n, i, r) { this.viewRotation_ = n, this.replay_(t, e, i, this.instructions, r, void 0, void 0); }, e.prototype.replayHitDetection = function (t, e, n, i, r, o) { return this.viewRotation_ = n, this.replay_(t, e, i, this.hitDetectionInstructions, !0, r, o); }, e.prototype.reverseHitDetectionInstructions = function () { let t; const e = this.hitDetectionInstructions; e.reverse(); let n; let i; const r = e.length; let o = -1; for (t = 0; t < r; ++t)n = e[t], i = n[0], i == HT.END_GEOMETRY ? o = t : i == HT.BEGIN_GEOMETRY && (n[2] = t, Ri(this.hitDetectionInstructions, o, t), o = -1); }, e.prototype.setFillStrokeStyle = function (t, e) { const n = this.state; if (t) { const i = t.getColor(); n.fillStyle = av(i || wv); } else n.fillStyle = void 0; if (e) { const r = e.getColor(); n.strokeStyle = av(r || Cv); const o = e.getLineCap(); n.lineCap = void 0 !== o ? o : xv; const s = e.getLineDash(); n.lineDash = s ? s.slice() : Ev; const a = e.getLineDashOffset(); n.lineDashOffset = a || Sv; const u = e.getLineJoin(); n.lineJoin = void 0 !== u ? u : Tv; const c = e.getWidth(); n.lineWidth = void 0 !== c ? c : Lv; const h = e.getMiterLimit(); n.miterLimit = void 0 !== h ? h : Ov, n.lineWidth > this.maxLineWidth && (this.maxLineWidth = n.lineWidth, this.bufferedMaxExtent_ = null); } else n.strokeStyle = void 0, n.lineCap = void 0, n.lineDash = null, n.lineDashOffset = void 0, n.lineJoin = void 0, n.lineWidth = void 0, n.miterLimit = void 0; }, e.prototype.createFill = function (t, e) { const n = t.fillStyle; const i = [HT.SET_FILL_STYLE, n]; return typeof n !== 'string' && i.push(!0), i; }, e.prototype.applyStroke = function (t) { this.instructions.push(this.createStroke(t)); }, e.prototype.createStroke = function (t) { return [HT.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio]; }, e.prototype.updateFillStyle = function (t, e, n) { const i = t.fillStyle; typeof i === 'string' && t.currentFillStyle == i || (void 0 !== i && this.instructions.push(e.call(this, t, n)), t.currentFillStyle = i); }, e.prototype.updateStrokeStyle = function (t, e) { const n = t.strokeStyle; const i = t.lineCap; const r = t.lineDash; const o = t.lineDashOffset; const s = t.lineJoin; const a = t.lineWidth; const u = t.miterLimit; (t.currentStrokeStyle != n || t.currentLineCap != i || r != t.currentLineDash && !Li(t.currentLineDash, r) || t.currentLineDashOffset != o || t.currentLineJoin != s || t.currentLineWidth != a || t.currentMiterLimit != u) && (void 0 !== n && e.call(this, t), t.currentStrokeStyle = n, t.currentLineCap = i, t.currentLineDash = r, t.currentLineDashOffset = o, t.currentLineJoin = s, t.currentLineWidth = a, t.currentMiterLimit = u); }, e.prototype.endGeometry = function (t, e) { this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null; const n = [HT.END_GEOMETRY, e]; this.instructions.push(n), this.hitDetectionInstructions.push(n); }, e.prototype.getBufferedMaxExtent = function () { if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = ot(this.maxExtent), this.maxLineWidth > 0)) { const t = this.resolution * (this.maxLineWidth + 1) / 2; rt(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_); } return this.bufferedMaxExtent_; }, e;
    }(bT)); const eO = tO; const nO = (function (t) { function e(e, n, i, r, o, s) { t.call(this, e, n, i, r, o, s), this.declutterGroup_ = null, this.hitDetectionImage_ = null, this.image_ = null, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.drawCoordinates_ = function (t, e, n, i) { return this.appendFlatCoordinates(t, e, n, i, !1, !1); }, e.prototype.drawPoint = function (t, e) { if (this.image_) { this.beginGeometry(t, e); const n = t.getFlatCoordinates(); const i = t.getStride(); const r = this.coordinates.length; const o = this.drawCoordinates_(n, 0, n.length, i); this.instructions.push([HT.DRAW_IMAGE, r, o, this.image_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]), this.hitDetectionInstructions.push([HT.DRAW_IMAGE, r, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]), this.endGeometry(t, e); } }, e.prototype.drawMultiPoint = function (t, e) { if (this.image_) { this.beginGeometry(t, e); const n = t.getFlatCoordinates(); const i = t.getStride(); const r = this.coordinates.length; const o = this.drawCoordinates_(n, 0, n.length, i); this.instructions.push([HT.DRAW_IMAGE, r, o, this.image_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]), this.hitDetectionInstructions.push([HT.DRAW_IMAGE, r, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]), this.endGeometry(t, e); } }, e.prototype.finish = function () { this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0; }, e.prototype.setImageStyle = function (t, e) { const n = t.getAnchor(); const i = t.getSize(); const r = t.getHitDetectionImage(1); const o = t.getImage(1); const s = t.getOrigin(); this.anchorX_ = n[0], this.anchorY_ = n[1], this.declutterGroup_ = e, this.hitDetectionImage_ = r, this.image_ = o, this.height_ = i[1], this.opacity_ = t.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScale(), this.width_ = i[0]; }, e; }(eO)); const iO = nO; const rO = (function (t) { function e(e, n, i, r, o, s) { t.call(this, e, n, i, r, o, s); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.drawFlatCoordinates_ = function (t, e, n, i) { const r = this.coordinates.length; const o = this.appendFlatCoordinates(t, e, n, i, !1, !1); const s = [HT.MOVE_TO_LINE_TO, r, o]; return this.instructions.push(s), this.hitDetectionInstructions.push(s), n; }, e.prototype.drawLineString = function (t, e) { const n = this.state; const i = n.strokeStyle; const r = n.lineWidth; if (void 0 !== i && void 0 !== r) { this.updateStrokeStyle(n, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([HT.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset], WT); const o = t.getFlatCoordinates(); const s = t.getStride(); this.drawFlatCoordinates_(o, 0, o.length, s), this.hitDetectionInstructions.push(XT), this.endGeometry(t, e); } }, e.prototype.drawMultiLineString = function (t, e) { const n = this.state; const i = n.strokeStyle; const r = n.lineWidth; if (void 0 !== i && void 0 !== r) { this.updateStrokeStyle(n, this.applyStroke), this.beginGeometry(t, e), this.hitDetectionInstructions.push([HT.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset], WT); for (let o = t.getEnds(), s = t.getFlatCoordinates(), a = t.getStride(), u = 0, c = 0, h = o.length; c < h; ++c)u = this.drawFlatCoordinates_(s, u, o[c], a); this.hitDetectionInstructions.push(XT), this.endGeometry(t, e); } }, e.prototype.finish = function () { const t = this.state; void 0 != t.lastStroke && t.lastStroke != this.coordinates.length && this.instructions.push(XT), this.reverseHitDetectionInstructions(), this.state = null; }, e.prototype.applyStroke = function (e) { void 0 != e.lastStroke && e.lastStroke != this.coordinates.length && (this.instructions.push(XT), e.lastStroke = this.coordinates.length), e.lastStroke = 0, t.prototype.applyStroke.call(this, e), this.instructions.push(WT); }, e; }(eO)); const oO = rO; const sO = (function (t) { function e(e, n, i, r, o, s) { t.call(this, e, n, i, r, o, s); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.drawFlatCoordinatess_ = function (t, e, n, i) { const r = this.state; const o = void 0 !== r.fillStyle; const s = void 0 != r.strokeStyle; const a = n.length; this.instructions.push(WT), this.hitDetectionInstructions.push(WT); for (let u = 0; u < a; ++u) { const c = n[u]; const h = this.coordinates.length; const l = this.appendFlatCoordinates(t, e, c, i, !0, !s); const f = [HT.MOVE_TO_LINE_TO, h, l]; this.instructions.push(f), this.hitDetectionInstructions.push(f), s && (this.instructions.push(KT), this.hitDetectionInstructions.push(KT)), e = c; } return o && (this.instructions.push(YT), this.hitDetectionInstructions.push(YT)), s && (this.instructions.push(XT), this.hitDetectionInstructions.push(XT)), e; }, e.prototype.drawCircle = function (t, e) { const n = this.state; const i = n.fillStyle; const r = n.strokeStyle; if (void 0 !== i || void 0 !== r) { this.setFillStrokeStyles_(t), this.beginGeometry(t, e), void 0 !== n.fillStyle && this.hitDetectionInstructions.push([HT.SET_FILL_STYLE, tv(wv)]), void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([HT.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]); const o = t.getFlatCoordinates(); const s = t.getStride(); const a = this.coordinates.length; this.appendFlatCoordinates(o, 0, o.length, s, !1, !1); const u = [HT.CIRCLE, a]; this.instructions.push(WT, u), this.hitDetectionInstructions.push(WT, u), this.hitDetectionInstructions.push(YT), void 0 !== n.fillStyle && this.instructions.push(YT), void 0 !== n.strokeStyle && (this.instructions.push(XT), this.hitDetectionInstructions.push(XT)), this.endGeometry(t, e); } }, e.prototype.drawPolygon = function (t, e) { const n = this.state; const i = n.fillStyle; const r = n.strokeStyle; if (void 0 !== i || void 0 !== r) { this.setFillStrokeStyles_(t), this.beginGeometry(t, e), void 0 !== n.fillStyle && this.hitDetectionInstructions.push([HT.SET_FILL_STYLE, tv(wv)]), void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([HT.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]); const o = t.getEnds(); const s = t.getOrientedFlatCoordinates(); const a = t.getStride(); this.drawFlatCoordinatess_(s, 0, o, a), this.endGeometry(t, e); } }, e.prototype.drawMultiPolygon = function (t, e) { const n = this.state; const i = n.fillStyle; const r = n.strokeStyle; if (void 0 !== i || void 0 !== r) { this.setFillStrokeStyles_(t), this.beginGeometry(t, e), void 0 !== n.fillStyle && this.hitDetectionInstructions.push([HT.SET_FILL_STYLE, tv(wv)]), void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([HT.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]); for (let o = t.getEndss(), s = t.getOrientedFlatCoordinates(), a = t.getStride(), u = 0, c = 0, h = o.length; c < h; ++c)u = this.drawFlatCoordinatess_(s, u, o[c], a); this.endGeometry(t, e); } }, e.prototype.finish = function () { this.reverseHitDetectionInstructions(), this.state = null; const t = this.tolerance; if (t !== 0) for (let e = this.coordinates, n = 0, i = e.length; n < i; ++n)e[n] = Zs(e[n], t); }, e.prototype.setFillStrokeStyles_ = function (t) { const e = this.state; const n = e.fillStyle; void 0 !== n && this.updateFillStyle(e, this.createFill, t), void 0 !== e.strokeStyle && this.updateStrokeStyle(e, this.applyStroke); }, e; }(eO)); const aO = sO; function uO(t, e, n, i, r) { let o; let s; let a; let u; let c; let h; let l; let f; let p; let d; let v = n; let g = n; let y = 0; let m = 0; let _ = n; for (s = n; s < i; s += r) { const b = e[s]; const w = e[s + 1]; void 0 !== c && (p = b - c, d = w - h, u = Math.sqrt(p * p + d * d), void 0 !== l && (m += a, o = Math.acos((l * p + f * d) / (a * u)), o > t && (m > y && (y = m, v = _, g = s), m = 0, _ = s - r)), a = u, l = p, f = d), c = b, h = w; } return m += u, m > y ? [_, s] : [v, g]; } const cO = (function (t) {
      function e(e, n, i, r, o, s) { t.call(this, e, n, i, r, o, s), this.declutterGroup_, this.labels_ = null, this.text_ = '', this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = {}, this.textStates = {}, this.textKey_ = '', this.fillKey_ = '', this.strokeKey_ = '', this.widths_ = {}, Av.prune(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.drawText = function (t, e) { const n = this.textFillState_; const i = this.textStrokeState_; const r = this.textState_; if (this.text_ !== '' && r && (n || i)) { let o; let s; let a = this.coordinates.length; const u = t.getType(); let c = null; let h = 2; let l = 2; if (r.placement === vg.LINE) { if (!kt(this.getBufferedMaxExtent(), t.getExtent())) return; let f; if (c = t.getFlatCoordinates(), l = t.getStride(), u == en.LINE_STRING)f = [c.length]; else if (u == en.MULTI_LINE_STRING)f = t.getEnds(); else if (u == en.POLYGON)f = t.getEnds().slice(0, 1); else if (u == en.MULTI_POLYGON) { const p = t.getEndss(); for (f = [], o = 0, s = p.length; o < s; ++o)f.push(p[o][0]); } this.beginGeometry(t, e); for (var d, v = r.textAlign, g = 0, y = 0, m = f.length; y < m; ++y) { if (void 0 == v) { const _ = uO(r.maxAngle, c, g, f[y], l); g = _[0], d = _[1]; } else d = f[y]; for (o = g; o < d; o += l) this.coordinates.push(c[o], c[o + 1]); h = this.coordinates.length, g = f[y], this.drawChars_(a, h, this.declutterGroup_), a = h; } this.endGeometry(t, e); } else { const b = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_); const w = b.width / this.pixelRatio; switch (u) { case en.POINT: case en.MULTI_POINT: c = t.getFlatCoordinates(), h = c.length; break; case en.LINE_STRING: c = t.getFlatMidpoint(); break; case en.CIRCLE: c = t.getCenter(); break; case en.MULTI_LINE_STRING: c = t.getFlatMidpoints(), h = c.length; break; case en.POLYGON: if (c = t.getFlatInteriorPoint(), !r.overflow && c[2] / this.resolution < w) return; l = 3; break; case en.MULTI_POLYGON: var x = t.getFlatInteriorPoints(); for (c = [], o = 0, s = x.length; o < s; o += 3)(r.overflow || x[o + 2] / this.resolution >= w) && c.push(x[o], x[o + 1]); if (h = c.length, h == 0) return; break; default: }h = this.appendFlatCoordinates(c, 0, h, l, !1, !1), (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(r.backgroundFill, r.backgroundStroke), r.backgroundFill && (this.updateFillStyle(this.state, this.createFill, t), this.hitDetectionInstructions.push(this.createFill(this.state, t))), r.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, e), this.drawTextImage_(b, a, h), this.endGeometry(t, e); } } }, e.prototype.getImage = function (t, e, n, i) { let r; const o = i + e + t + n + this.pixelRatio; if (!Av.containsKey(o)) { const s = i ? this.strokeStates[i] || this.textStrokeState_ : null; const a = n ? this.fillStates[n] || this.textFillState_ : null; const u = this.textStates[e] || this.textState_; const c = this.pixelRatio; const h = u.scale * c; const l = ZT[u.textAlign || Rv]; const f = i && s.lineWidth ? s.lineWidth : 0; const p = t.split('\n'); const d = p.length; const v = []; const g = hO(u.font, p, v); const y = Dv(u.font); const m = y * d; const _ = g + f; const b = ke(Math.ceil(_ * h), Math.ceil((m + f) * h)); r = b.canvas, Av.set(o, r), h != 1 && b.scale(h, h), b.font = u.font, i && (b.strokeStyle = s.strokeStyle, b.lineWidth = f, b.lineCap = s.lineCap, b.lineJoin = s.lineJoin, b.miterLimit = s.miterLimit, dv && s.lineDash.length && (b.setLineDash(s.lineDash), b.lineDashOffset = s.lineDashOffset)), n && (b.fillStyle = a.fillStyle), b.textBaseline = 'middle', b.textAlign = 'center'; let w; const x = 0.5 - l; const E = l * r.width / h + x * f; if (i) for (w = 0; w < d; ++w)b.strokeText(p[w], E + x * v[w], 0.5 * (f + y) + w * y); if (n) for (w = 0; w < d; ++w)b.fillText(p[w], E + x * v[w], 0.5 * (f + y) + w * y); } return Av.get(o); }, e.prototype.drawTextImage_ = function (t, e, n) { const i = this.textState_; const r = this.textStrokeState_; const o = this.pixelRatio; const s = ZT[i.textAlign || Rv]; const a = ZT[i.textBaseline]; const u = r && r.lineWidth ? r.lineWidth : 0; const c = s * t.width / o + 2 * (0.5 - s) * u; const h = a * t.height / o + 2 * (0.5 - a) * u; this.instructions.push([HT.DRAW_IMAGE, e, n, t, (c - this.textOffsetX_) * o, (h - this.textOffsetY_) * o, this.declutterGroup_, t.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, t.width, i.padding == Pv ? Pv : i.padding.map(t => t * o), !!i.backgroundFill, !!i.backgroundStroke]), this.hitDetectionInstructions.push([HT.DRAW_IMAGE, e, n, t, (c - this.textOffsetX_) * o, (h - this.textOffsetY_) * o, this.declutterGroup_, t.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / o, t.width, i.padding, !!i.backgroundFill, !!i.backgroundStroke]); }, e.prototype.drawChars_ = function (t, e, n) {
        const i = this.textStrokeState_; const r = this.textState_; const o = this.textFillState_; const s = this.strokeKey_; i && (s in this.strokeStates || (this.strokeStates[s] = {
          strokeStyle: i.strokeStyle, lineCap: i.lineCap, lineDashOffset: i.lineDashOffset, lineWidth: i.lineWidth, lineJoin: i.lineJoin, miterLimit: i.miterLimit, lineDash: i.lineDash,
        })); const a = this.textKey_; this.textKey_ in this.textStates || (this.textStates[this.textKey_] = { font: r.font, textAlign: r.textAlign || Rv, scale: r.scale }); const u = this.fillKey_; o && (u in this.fillStates || (this.fillStates[u] = { fillStyle: o.fillStyle })); const c = this.pixelRatio; const h = ZT[r.textBaseline]; const l = this.textOffsetY_ * c; const f = this.text_; const p = r.font; const d = r.scale; const v = i ? i.lineWidth * d / 2 : 0; let g = this.widths_[p]; g || (this.widths_[p] = g = {}), this.instructions.push([HT.DRAW_CHARS, t, e, h, n, r.overflow, u, r.maxAngle, function (t) { let e = g[t]; return e || (e = g[t] = $v(p, t)), e * d * c; }, l, s, v * c, f, a, 1]), this.hitDetectionInstructions.push([HT.DRAW_CHARS, t, e, h, n, r.overflow, u, r.maxAngle, function (t) { let e = g[t]; return e || (e = g[t] = $v(p, t)), e * d; }, l, s, v, f, a, 1 / c]);
      }, e.prototype.setTextStyle = function (t, e) { let n; let i; let r; if (t) { this.declutterGroup_ = e; const o = t.getFill(); o ? (i = this.textFillState_, i || (i = this.textFillState_ = {}), i.fillStyle = av(o.getColor() || wv)) : i = this.textFillState_ = null; const s = t.getStroke(); if (s) { r = this.textStrokeState_, r || (r = this.textStrokeState_ = {}); const a = s.getLineDash(); const u = s.getLineDashOffset(); const c = s.getWidth(); const h = s.getMiterLimit(); r.lineCap = s.getLineCap() || xv, r.lineDash = a ? a.slice() : Ev, r.lineDashOffset = void 0 === u ? Sv : u, r.lineJoin = s.getLineJoin() || Tv, r.lineWidth = void 0 === c ? Lv : c, r.miterLimit = void 0 === h ? Ov : h, r.strokeStyle = av(s.getColor() || Cv); } else r = this.textStrokeState_ = null; n = this.textState_; const l = t.getFont() || bv; Mv(l); const f = t.getScale(); n.overflow = t.getOverflow(), n.font = l, n.maxAngle = t.getMaxAngle(), n.placement = t.getPlacement(), n.textAlign = t.getTextAlign(), n.textBaseline = t.getTextBaseline() || Iv, n.backgroundFill = t.getBackgroundFill(), n.backgroundStroke = t.getBackgroundStroke(), n.padding = t.getPadding() || Pv, n.scale = void 0 === f ? 1 : f; const p = t.getOffsetX(); const d = t.getOffsetY(); const v = t.getRotateWithView(); const g = t.getRotation(); this.text_ = t.getText() || '', this.textOffsetX_ = void 0 === p ? 0 : p, this.textOffsetY_ = void 0 === d ? 0 : d, this.textRotateWithView_ = void 0 !== v && v, this.textRotation_ = void 0 === g ? 0 : g, this.strokeKey_ = r ? `${(typeof r.strokeStyle === 'string' ? r.strokeStyle : H(r.strokeStyle)) + r.lineCap + r.lineDashOffset}|${r.lineWidth}${r.lineJoin}${r.miterLimit}[${r.lineDash.join()}]` : '', this.textKey_ = n.font + n.scale + (n.textAlign || '?'), this.fillKey_ = i ? typeof i.fillStyle === 'string' ? i.fillStyle : `|${H(i.fillStyle)}` : ''; } else this.text_ = ''; }, e;
    }(eO)); function hO(t, e, n) { for (var i = e.length, r = 0, o = 0; o < i; ++o) { const s = $v(t, e[o]); r = Math.max(r, s), n.push(s); } return r; } const lO = cO; const fO = {
      Circle: aO, Default: eO, Image: iO, LineString: oO, Polygon: aO, Text: lO,
    }; const pO = (function (t) {
      function e(e, n, i, r, o, s, a) { t.call(this), this.declutterTree_ = s, this.declutterGroup_ = null, this.tolerance_ = e, this.maxExtent_ = n, this.overlaps_ = o, this.pixelRatio_ = r, this.resolution_ = i, this.renderBuffer_ = a, this.replaysByZIndex_ = {}, this.hitDetectionContext_ = ke(1, 1), this.hitDetectionTransform_ = Jo(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.addDeclutter = function (t) { let e = null; return this.declutterTree_ && (t ? (e = this.declutterGroup_, e[4]++) : (e = this.declutterGroup_ = lt(), e.push(1))), e; }, e.prototype.clip = function (t, e) { const n = this.getClipCoords(e); t.beginPath(), t.moveTo(n[0], n[1]), t.lineTo(n[2], n[3]), t.lineTo(n[4], n[5]), t.lineTo(n[6], n[7]), t.clip(); }, e.prototype.hasReplays = function (t) { for (const e in this.replaysByZIndex_) for (let n = this.replaysByZIndex_[e], i = 0, r = t.length; i < r; ++i) if (t[i] in n) return !0; return !1; }, e.prototype.finish = function () { for (const t in this.replaysByZIndex_) { const e = this.replaysByZIndex_[t]; for (const n in e)e[n].finish(); } }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r, o, s) { i = Math.round(i); let a; const u = 2 * i + 1; const c = ss(this.hitDetectionTransform_, i + 0.5, i + 0.5, 1 / e, -1 / e, -n, -t[0], -t[1]); const h = this.hitDetectionContext_; h.canvas.width !== u || h.canvas.height !== u ? (h.canvas.width = u, h.canvas.height = u) : h.clearRect(0, 0, u, u), void 0 !== this.renderBuffer_ && (a = lt(), _t(a, t), rt(a, e * (this.renderBuffer_ + i), a)); let l; let f; const p = gO(i); function d(t) { for (let e = h.getImageData(0, 0, u, u).data, n = 0; n < u; n++) for (let i = 0; i < u; i++) if (p[n][i] && e[4 * (i * u + n) + 3] > 0) { let r = void 0; return (!l || f != BT.IMAGE && f != BT.TEXT || l.indexOf(t) !== -1) && (r = o(t)), r || void h.clearRect(0, 0, u, u); } } this.declutterTree_ && (l = this.declutterTree_.all().map(t => t.value)); let v; let g; let y; let m; let _; const b = Object.keys(this.replaysByZIndex_).map(Number); for (b.sort(Ti), v = b.length - 1; v >= 0; --v) { const w = b[v].toString(); for (y = this.replaysByZIndex_[w], g = qT.length - 1; g >= 0; --g) if (f = qT[g], m = y[f], void 0 !== m) if (!s || f != BT.IMAGE && f != BT.TEXT) { if (_ = m.replayHitDetection(h, c, n, r, d, a), _) return _; } else { const x = s[w]; x ? x.push(m, c.slice(0)) : s[w] = [m, c.slice(0)]; } } }, e.prototype.getClipCoords = function (t) { const e = this.maxExtent_; const n = e[0]; const i = e[1]; const r = e[2]; const o = e[3]; const s = [n, i, n, o, r, o, r, i]; return Wo(s, 0, 8, 2, t, s), s; }, e.prototype.getReplay = function (t, e) {
        const n = void 0 !== t ? t.toString() : '0'; let
          i = this.replaysByZIndex_[n]; void 0 === i && (i = {}, this.replaysByZIndex_[n] = i); let r = i[e]; if (void 0 === r) { const o = fO[e]; r = new o(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_), i[e] = r; } return r;
      }, e.prototype.getReplays = function () { return this.replaysByZIndex_; }, e.prototype.isEmpty = function () { return Qt(this.replaysByZIndex_); }, e.prototype.replay = function (t, e, n, i, r, o, s) { const a = Object.keys(this.replaysByZIndex_).map(Number); a.sort(Ti), t.save(), this.clip(t, e); let u; let c; let h; let l; let f; let p; const d = o || qT; for (u = 0, c = a.length; u < c; ++u) { const v = a[u].toString(); for (f = this.replaysByZIndex_[v], h = 0, l = d.length; h < l; ++h) { const g = d[h]; if (p = f[g], void 0 !== p) if (!s || g != BT.IMAGE && g != BT.TEXT)p.replay(t, e, n, i, r); else { const y = s[v]; y ? y.push(p, e.slice(0)) : s[v] = [p, e.slice(0)]; } } }t.restore(); }, e;
    }(VT)); const dO = { 0: [[!0]] }; function vO(t, e, n) { let i; const r = Math.floor(t.length / 2); if (e >= r) for (i = r; i < e; i++)t[i][n] = !0; else if (e < r) for (i = e + 1; i < r; i++)t[i][n] = !0; } function gO(t) { if (void 0 !== dO[t]) return dO[t]; for (var e = 2 * t + 1, n = new Array(e), i = 0; i < e; i++)n[i] = new Array(e); let r = t; let o = 0; let s = 0; while (r >= o)vO(n, t + r, t + o), vO(n, t + o, t + r), vO(n, t - o, t + r), vO(n, t - r, t + o), vO(n, t - r, t - o), vO(n, t - o, t - r), vO(n, t + o, t - r), vO(n, t + r, t - o), o++, s += 1 + 2 * o, 2 * (s - r) + 1 > 0 && (r -= 1, s += 1 - 2 * r); return dO[t] = n, n; } function yO(t, e, n, i) { for (let r = Object.keys(t).map(Number).sort(Ti), o = {}, s = 0, a = r.length; s < a; ++s) for (let u = t[r[s].toString()], c = 0, h = u.length; c < h;) { const l = u[c++]; const f = u[c++]; l.replay(e, f, n, o, i); } } const mO = pO; const _O = 0.5; const bO = {
      Point: AO, LineString: IO, Polygon: jO, MultiPoint: FO, MultiLineString: PO, MultiPolygon: LO, GeometryCollection: RO, Circle: SO,
    }; function wO(t, e) { return parseInt(H(t), 10) - parseInt(H(e), 10); } function xO(t, e) { const n = EO(t, e); return n * n; } function EO(t, e) { return _O * t / e; } function SO(t, e, n, i) { const r = n.getFill(); const o = n.getStroke(); if (r || o) { const s = t.getReplay(n.getZIndex(), BT.CIRCLE); s.setFillStrokeStyle(r, o), s.drawCircle(e, i); } const a = n.getText(); if (a) { const u = t.getReplay(n.getZIndex(), BT.TEXT); u.setTextStyle(a, t.addDeclutter(!1)), u.drawText(e, i); } } function TO(t, e, n, i, r, o) { let s = !1; const a = n.getImage(); if (a) { let u = a.getImageState(); u == _v.LOADED || u == _v.ERROR ? a.unlistenImageChange(r, o) : (u == _v.IDLE && a.load(), u = a.getImageState(), a.listenImageChange(r, o), s = !0); } return OO(t, e, n, i), s; } function OO(t, e, n, i) { const r = n.getGeometryFunction()(e); if (r) { const o = r.getSimplifiedGeometry(i); const s = n.getRenderer(); if (s)CO(t, o, n, e); else { const a = bO[o.getType()]; a(t, o, n, e); } } } function CO(t, e, n, i) { if (e.getType() != en.GEOMETRY_COLLECTION) { const r = t.getReplay(n.getZIndex(), BT.DEFAULT); r.drawCustom(e, i, n.getRenderer()); } else for (let o = e.getGeometries(), s = 0, a = o.length; s < a; ++s)CO(t, o[s], n, i); } function RO(t, e, n, i) { let r; let o; const s = e.getGeometriesArray(); for (r = 0, o = s.length; r < o; ++r) { const a = bO[s[r].getType()]; a(t, s[r], n, i); } } function IO(t, e, n, i) { const r = n.getStroke(); if (r) { const o = t.getReplay(n.getZIndex(), BT.LINE_STRING); o.setFillStrokeStyle(null, r), o.drawLineString(e, i); } const s = n.getText(); if (s) { const a = t.getReplay(n.getZIndex(), BT.TEXT); a.setTextStyle(s, t.addDeclutter(!1)), a.drawText(e, i); } } function PO(t, e, n, i) { const r = n.getStroke(); if (r) { const o = t.getReplay(n.getZIndex(), BT.LINE_STRING); o.setFillStrokeStyle(null, r), o.drawMultiLineString(e, i); } const s = n.getText(); if (s) { const a = t.getReplay(n.getZIndex(), BT.TEXT); a.setTextStyle(s, t.addDeclutter(!1)), a.drawText(e, i); } } function LO(t, e, n, i) { const r = n.getFill(); const o = n.getStroke(); if (o || r) { const s = t.getReplay(n.getZIndex(), BT.POLYGON); s.setFillStrokeStyle(r, o), s.drawMultiPolygon(e, i); } const a = n.getText(); if (a) { const u = t.getReplay(n.getZIndex(), BT.TEXT); u.setTextStyle(a, t.addDeclutter(!1)), u.drawText(e, i); } } function AO(t, e, n, i) { const r = n.getImage(); if (r) { if (r.getImageState() != _v.LOADED) return; const o = t.getReplay(n.getZIndex(), BT.IMAGE); o.setImageStyle(r, t.addDeclutter(!1)), o.drawPoint(e, i); } const s = n.getText(); if (s) { const a = t.getReplay(n.getZIndex(), BT.TEXT); a.setTextStyle(s, t.addDeclutter(!!r)), a.drawText(e, i); } } function FO(t, e, n, i) { const r = n.getImage(); if (r) { if (r.getImageState() != _v.LOADED) return; const o = t.getReplay(n.getZIndex(), BT.IMAGE); o.setImageStyle(r, t.addDeclutter(!1)), o.drawMultiPoint(e, i); } const s = n.getText(); if (s) { const a = t.getReplay(n.getZIndex(), BT.TEXT); a.setTextStyle(s, t.addDeclutter(!!r)), a.drawText(e, i); } } function jO(t, e, n, i) { const r = n.getFill(); const o = n.getStroke(); if (r || o) { const s = t.getReplay(n.getZIndex(), BT.POLYGON); s.setFillStrokeStyle(r, o), s.drawPolygon(e, i); } const a = n.getText(); if (a) { const u = t.getReplay(n.getZIndex(), BT.TEXT); u.setTextStyle(a, t.addDeclutter(!1)), u.drawText(e, i); } } const kO = (function (t) { function e(e) { t.call(this, e), this.declutterTree_ = e.getDeclutter() ? vm()(9, void 0) : null, this.dirty_ = !1, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = lt(), this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.context = ke(), _e(Av, Ae.CLEAR, this.handleFontsChanged_, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { we(Av, Ae.CLEAR, this.handleFontsChanged_, this), t.prototype.disposeInternal.call(this); }, e.prototype.compose = function (t, e, n) { const i = e.extent; const r = e.pixelRatio; const o = n.managed ? e.skippedFeatureUids : {}; const s = e.viewState; const a = s.projection; const u = s.rotation; const c = a.getExtent(); const h = this.getLayer().getSource(); let l = this.getTransform(e, 0); const f = n.extent; const p = void 0 !== f; p && this.clip(t, e, f); const d = this.replayGroup_; if (d && !d.isEmpty()) { this.declutterTree_ && this.declutterTree_.clear(); let v; const g = this.getLayer(); let y = 0; let m = 0; const _ = n.opacity !== 1; const b = g.hasListener(T_.RENDER); if (_ || b) { let w = t.canvas.width; let x = t.canvas.height; if (u) { const E = Math.round(Math.sqrt(w * w + x * x)); y = (E - w) / 2, m = (E - x) / 2, w = x = E; } this.context.canvas.width = w, this.context.canvas.height = x, v = this.context; } else v = t; const S = v.globalAlpha; _ || (v.globalAlpha = n.opacity), v != t && v.translate(y, m); const T = e.viewHints; const O = !(T[wS.ANIMATING] || T[wS.INTERACTING]); const C = e.size[0] * r; const R = e.size[1] * r; if (Gv(v, -u, C / 2, R / 2), d.replay(v, l, u, o, O), h.getWrapX() && a.canWrapX() && !ut(c, i)) { let I; let P = i[0]; const L = jt(c); let A = 0; while (P < c[0])--A, I = L * A, l = this.getTransform(e, I), d.replay(v, l, u, o, O), P += L; A = 0, P = i[2]; while (P > c[2])++A, I = L * A, l = this.getTransform(e, I), d.replay(v, l, u, o, O), P -= L; } if (Gv(v, u, C / 2, R / 2), b && this.dispatchRenderEvent(v, e, l), v != t) { if (_) { const F = t.globalAlpha; t.globalAlpha = n.opacity, t.drawImage(v.canvas, -y, -m), t.globalAlpha = F; } else t.drawImage(v.canvas, -y, -m); v.translate(-y, -m); }_ || (v.globalAlpha = S); }p && t.restore(); }, e.prototype.composeFrame = function (t, e, n) { const i = this.getTransform(t, 0); this.preCompose(n, t, i), this.compose(n, t, e), this.postCompose(n, t, e, i); }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r) { if (this.replayGroup_) { const o = e.viewState.resolution; const s = e.viewState.rotation; const a = this.getLayer(); const u = {}; const c = this.replayGroup_.forEachFeatureAtCoordinate(t, o, s, n, {}, (t) => { const e = H(t); if (!(e in u)) return u[e] = !0, i.call(r, t, a); }, null); return c; } }, e.prototype.handleFontsChanged_ = function (t) { const e = this.getLayer(); e.getVisible() && this.replayGroup_ && e.changed(); }, e.prototype.handleStyleImageChange_ = function (t) { this.renderIfReadyAndVisible(); }, e.prototype.prepareFrame = function (t, e) { const n = this.getLayer(); const i = n.getSource(); const r = t.viewHints[wS.ANIMATING]; const o = t.viewHints[wS.INTERACTING]; const s = n.getUpdateWhileAnimating(); const a = n.getUpdateWhileInteracting(); if (!this.dirty_ && !s && r || !a && o) return !0; const u = t.extent; const c = t.viewState; const h = c.projection; const l = c.resolution; const f = t.pixelRatio; const p = n.getRevision(); const d = n.getRenderBuffer(); let v = n.getRenderOrder(); void 0 === v && (v = wO); const g = rt(u, d * l); const y = c.projection.getExtent(); if (i.getWrapX() && c.projection.canWrapX() && !ut(y, t.extent)) { const m = jt(y); const _ = Math.max(jt(g) / 2, m); g[0] = y[0] - _, g[2] = y[2] + _; } if (!this.dirty_ && this.renderedResolution_ == l && this.renderedRevision_ == p && this.renderedRenderOrder_ == v && ut(this.renderedExtent_, g)) return this.replayGroupChanged = !1, !0; this.replayGroup_ = null, this.dirty_ = !1; const b = new mO(EO(l, f), g, l, f, i.getOverlaps(), this.declutterTree_, n.getRenderBuffer()); i.loadFeatures(g, l, h); const w = function (t) { let e; const i = t.getStyleFunction() || n.getStyleFunction(); if (i && (e = i(t, l)), e) { const r = this.renderFeature(t, l, f, e, b); this.dirty_ = this.dirty_ || r; } }.bind(this); if (v) { const x = []; i.forEachFeatureInExtent(g, (t) => { x.push(t); }), x.sort(v); for (let E = 0, S = x.length; E < S; ++E)w(x[E]); } else i.forEachFeatureInExtent(g, w); return b.finish(), this.renderedResolution_ = l, this.renderedRevision_ = p, this.renderedRenderOrder_ = v, this.renderedExtent_ = g, this.replayGroup_ = b, this.replayGroupChanged = !0, !0; }, e.prototype.renderFeature = function (t, e, n, i, r) { if (!i) return !1; let o = !1; if (Array.isArray(i)) for (let s = 0, a = i.length; s < a; ++s)o = TO(r, t, i[s], xO(e, n), this.handleStyleImageChange_, this) || o; else o = TO(r, t, i, xO(e, n), this.handleStyleImageChange_, this); return o; }, e; }(FT)); kO.handles = function (t) { return t.getType() === S_.VECTOR; }, kO.create = function (t, e) { return new kO(e); }; const MO = kO; const NO = { IMAGE: 'image', HYBRID: 'hybrid', VECTOR: 'vector' }; const DO = { image: [BT.POLYGON, BT.CIRCLE, BT.LINE_STRING, BT.IMAGE, BT.TEXT], hybrid: [BT.POLYGON, BT.LINE_STRING] }; const $O = { image: [BT.DEFAULT], hybrid: [BT.IMAGE, BT.TEXT, BT.DEFAULT], vector: qT }; const GO = (function (t) { function e(e) { t.call(this, e, !0), this.declutterTree_ = e.getDeclutter() ? vm()(9, void 0) : null, this.dirty_ = !1, this.renderedLayerRevision_, this.tmpTransform_ = Jo(); const n = e.getRenderMode(); this.zDirection = n === NO.VECTOR ? 1 : 0, n !== NO.VECTOR && (this.context = ke()), _e(Av, Ae.CLEAR, this.handleFontsChanged_, this); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { we(Av, Ae.CLEAR, this.handleFontsChanged_, this), t.prototype.disposeInternal.call(this); }, e.prototype.getTile = function (e, n, i, r, o) { const s = t.prototype.getTile.call(this, e, n, i, r, o); return s.getState() === se.LOADED && (this.createReplayGroup_(s, r, o), this.context && this.renderTileImage_(s, r, o)), s; }, e.prototype.getTileImage = function (t) { const e = this.getLayer(); return t.getImage(e); }, e.prototype.prepareFrame = function (e, n) { const i = this.getLayer(); const r = i.getRevision(); return this.renderedLayerRevision_ != r && (this.renderedTiles.length = 0), this.renderedLayerRevision_ = r, t.prototype.prepareFrame.call(this, e, n); }, e.prototype.createReplayGroup_ = function (t, e, n) { const i = this; const r = this.getLayer(); const o = r.getRevision(); const s = r.getRenderOrder() || null; const a = t.getReplayState(r); if (a.dirty || a.renderedRevision != o || a.renderedRenderOrder != s) { for (var u = r.getSource(), c = u.getTileGrid(), h = u.getTileGridForProjection(n), l = h.getResolution(t.tileCoord[0]), f = t.extent, p = function (o, h) { const p = t.getTile(t.tileKeys[o]); if (p.getState() == se.LOADED) { const d = p.tileCoord; const v = c.getTileCoordExtent(d); const g = Lt(f, v); const y = yt(v, g) ? null : rt(g, r.getRenderBuffer() * l, i.tmpExtent); const m = p.getProjection(); let _ = !1; Vn(n, m) || (_ = !0, p.setProjection(n)), a.dirty = !1; const b = new mO(0, g, l, e, u.getOverlaps(), i.declutterTree_, r.getRenderBuffer()); const w = xO(l, e); const x = function (t) { let e; const n = t.getStyleFunction() || r.getStyleFunction(); if (n && (e = n(t, l)), e) { const i = this.renderFeature(t, w, e, b); this.dirty_ = this.dirty_ || i, a.dirty = a.dirty || i; } }; const E = p.getFeatures(); s && s !== a.renderedRenderOrder && E.sort(s); for (let S = 0, T = E.length; S < T; ++S) { const O = E[S]; _ && (m.getUnits() == un.TILE_PIXELS && (m.setWorldExtent(v), m.setExtent(p.getExtent())), O.getGeometry().transform(m, n)), y && !kt(y, O.getGeometry().getExtent()) || x.call(i, O); }b.finish(), p.setReplayGroup(r, t.tileCoord.toString(), b); } }, d = 0, v = t.tileKeys.length; d < v; ++d)p(d, v); a.renderedRevision = o, a.renderedRenderOrder = s; } }, e.prototype.forEachFeatureAtCoordinate = function (t, e, n, i, r) { const o = e.viewState.resolution; const s = e.viewState.rotation; n = void 0 == n ? 0 : n; let a; let u; let c; let h; const l = this.getLayer(); const f = {}; const p = this.renderedTiles; for (c = 0, h = p.length; c < h; ++c) { const d = p[c]; if (a = rt(d.extent, n * o, a), at(a, t)) for (let v = 0, g = d.tileKeys.length; v < g; ++v) { const y = d.getTile(d.tileKeys[v]); if (y.getState() == se.LOADED) { const m = y.getReplayGroup(l, d.tileCoord.toString()); u = u || m.forEachFeatureAtCoordinate(t, o, s, n, {}, (t) => { const e = H(t); if (!(e in f)) return f[e] = !0, i.call(r, t, l); }, null); } } } return u; }, e.prototype.getReplayTransform_ = function (t, e) { const n = this.getLayer(); const i = n.getSource(); const r = i.getTileGrid(); const o = t.tileCoord; const s = r.getResolution(o[0]); const a = e.viewState; const u = e.pixelRatio; const c = a.resolution / u; const h = r.getTileCoordExtent(o, this.tmpExtent); const l = a.center; const f = At(h); const p = e.size; const d = Math.round(u * p[0] / 2); const v = Math.round(u * p[1] / 2); return ss(this.tmpTransform_, d, v, s / c, s / c, a.rotation, (f[0] - l[0]) / s, (l[1] - f[1]) / s); }, e.prototype.handleFontsChanged_ = function (t) { const e = this.getLayer(); e.getVisible() && void 0 !== this.renderedLayerRevision_ && e.changed(); }, e.prototype.handleStyleImageChange_ = function (t) { this.renderIfReadyAndVisible(); }, e.prototype.postCompose = function (e, n, i) { const r = this.getLayer(); const o = r.getRenderMode(); if (o != NO.IMAGE) { let s; let a; const u = r.getDeclutter() ? {} : null; const c = r.getSource(); const h = $O[o]; const l = n.pixelRatio; const f = n.viewState.rotation; const p = n.size; f && (s = Math.round(l * p[0] / 2), a = Math.round(l * p[1] / 2), Gv(e, -f, s, a)), u && this.declutterTree_.clear(); for (var d = n.viewHints, v = !(d[wS.ANIMATING] || d[wS.INTERACTING]), g = this.renderedTiles, y = c.getTileGridForProjection(n.viewState.projection), m = [], _ = [], b = g.length - 1; b >= 0; --b) { const w = g[b]; if (w.getState() != se.ABORT) for (let x = w.tileCoord, E = y.getTileCoordExtent(x, this.tmpExtent)[0] - w.extent[0], S = void 0, T = 0, O = w.tileKeys.length; T < O; ++T) { const C = w.getTile(w.tileKeys[T]); if (C.getState() == se.LOADED) { const R = C.getReplayGroup(r, x.toString()); if (R && R.hasReplays(h)) { S || (S = this.getTransform(n, E)); const I = C.tileCoord[0]; const P = R.getClipCoords(S); e.save(), e.globalAlpha = i.opacity; for (let L = 0, A = m.length; L < A; ++L) { const F = m[L]; I < _[L] && (e.beginPath(), e.moveTo(P[0], P[1]), e.lineTo(P[2], P[3]), e.lineTo(P[4], P[5]), e.lineTo(P[6], P[7]), e.moveTo(F[6], F[7]), e.lineTo(F[4], F[5]), e.lineTo(F[2], F[3]), e.lineTo(F[0], F[1]), e.clip()); }R.replay(e, S, f, {}, v, h, u), e.restore(), m.push(P), _.push(I); } } } }u && yO(u, e, f, v), f && Gv(e, f, s, a); }t.prototype.postCompose.call(this, e, n, i); }, e.prototype.renderFeature = function (t, e, n, i) { if (!n) return !1; let r = !1; if (Array.isArray(n)) for (let o = 0, s = n.length; o < s; ++o)r = TO(i, t, n[o], e, this.handleStyleImageChange_, this) || r; else r = TO(i, t, n, e, this.handleStyleImageChange_, this); return r; }, e.prototype.renderTileImage_ = function (t, e, n) { const i = this.getLayer(); const r = t.getReplayState(i); const o = i.getRevision(); const s = DO[i.getRenderMode()]; if (s && r.renderedTileRevision !== o) { r.renderedTileRevision = o; const a = t.wrappedTileCoord; const u = a[0]; const c = i.getSource(); const h = c.getTileGridForProjection(n); const l = h.getResolution(u); const f = t.getContext(i); const p = c.getTilePixelSize(u, e, n); f.canvas.width = p[0], f.canvas.height = p[1]; for (let d = h.getTileCoordExtent(a, this.tmpExtent), v = 0, g = t.tileKeys.length; v < g; ++v) { const y = t.getTile(t.tileKeys[v]); if (y.getState() == se.LOADED) { const m = e / l; const _ = Qo(this.tmpTransform_); rs(_, m, -m), os(_, -d[0], -d[3]); const b = y.getReplayGroup(i, t.tileCoord.toString()); b.replay(f, _, 0, {}, !0, s); } } } }, e; }($T)); GO.handles = function (t) { return t.getType() === S_.VECTOR_TILE; }, GO.create = function (t, e) { return new GO(e); }; const VO = GO; const BO = (function (t) { function e(e) { e = qt({}, e), e.controls || (e.controls = bE()), e.interactions || (e.interactions = dT()), t.call(this, e); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createRenderer = function () { const t = new IT(this); return t.registerLayerRenderers([NT, $T, MO, VO]), t; }, e; }(FS)); const UO = BO; function zO(t, e) { return lh((n, i) => (e ? e(n[t], i[t]) : n[t] === i[t])); }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const YO = {
      controls: { type: [Object, Boolean], default: !0 }, keyboardEventTarget: [String, Element, Document], loadTilesWhileAnimating: { type: Boolean, default: !1 }, loadTilesWhileInteracting: { type: Boolean, default: !1 }, logo: [String, Object, Element, Boolean], moveTolerance: { type: Number, default: 1 }, pixelRatio: { type: Number, default() { return window.devicePixelRatio || 1; } }, renderer: { type: [String, Array], default() { return [So.CANVAS, So.WEBGL]; } }, tabindex: [String, Number], dataProjection: String, wrapX: { type: Boolean, default: !0 },
    }; const XO = {}; const WO = {
      createOlObject() {
        const t = new UO({
          controls: [], loadTilesWhileAnimating: this.loadTilesWhileAnimating, loadTilesWhileInteracting: this.loadTilesWhileInteracting, pixelRatio: this.pixelRatio, renderer: this.renderer, logo: this.logo, keyboardEventTarget: this.keyboardEventTarget, view: this._view,
        }); if (this._view = t.getView(), this._defaultLayer.setMap(t), this.controls) { const e = Object(vr.a)(this.controls) === 'object' ? this.controls : void 0; t.getControls().extend(bE(e).getArray()); } return t.set('dataProjection', this.dataProjection), t;
      },
      getLayersTarget() { return io(this), this._layersTarget == null && (this._layersTarget = new Dd(this.$map.getLayers(), (t => t.get('id')))), this._layersTarget; },
      getInteractionsTarget() { return io(this), this._interactionsTarget == null && (this._interactionsTarget = new Dd(this.$map.getInteractions(), (t => t.get('id')))), this._interactionsTarget; },
      getDefaultInteractionsSorter() { return function (t, e) { const n = t.get('priority') || 0; const i = e.get('priority') || 0; return n === i ? 0 : n - i; }; },
      getFeaturesTarget() { return this._featuresTarget == null && (this._featuresTarget = new $d(this._defaultLayer.getSource())), this._featuresTarget; },
      getOverlaysTarget() { return io(this), this._overlaysTarget == null && (this._overlaysTarget = new Dd(this.$map.getOverlays(), (t => t.getId()))), this._overlaysTarget; },
      getCoordinateFromPixel(t) { io(this); const e = this.$map.getCoordinateFromPixel(t); return this.pointToDataProj(e); },
      getServices() { const t = this; return xl(Ef.methods.getServices.call(this), Dp.methods.getServices.call(this), Sp.methods.getServices.call(this), Jp.methods.getServices.call(this), Bc.methods.getServices.call(this), { get map() { return t.$map; }, get view() { return t.$view; }, get viewContainer() { return t; } }); },
      focus() { this.$el.focus(); },
      forEachFeatureAtPixel(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return io(this), this.$map.forEachFeatureAtPixel(t, e, n); },
      forEachLayerAtPixel(t, e, n) { return io(this), this.$map.forEachLayerAtPixel(t, e, void 0, n); },
      setView(t) { t = t instanceof Rr.a ? t.$view : t, t || (t = new PS()), t !== this._view && (this._view = t), this.$map && t !== this.$map.getView() && this.$map.setView(t); },
      mount() { io(this), this.$map.setTarget(this.$el), this.subscribeAll(), this.updateSize(); },
      unmount() { io(this), this.clearLayers(), this.clearInteractions(), this.clearOverlays(), this.unsubscribeAll(), this.$map.setTarget(void 0); },
      refresh() { const t = this; return this.updateSize(), this.render().then(() => Ef.methods.refresh.call(t)); },
      render() { const t = this; return new Ol.a(((e) => { io(t), t.$map.once('postrender', () => e()), t.$map.render(); })); },
      subscribeAll() { qO.call(this); },
      updateSize() { io(this), this.$map.updateSize(); },
    }; const KO = { dataProjection(t) { this.$map && (this.$map.set('dataProjection', t), this.scheduleRefresh()); } }; const HO = {
      name: 'vl-map', mixins: [Ef, Dp, Sp, Jp, Bc, $c], props: YO, computed: XO, methods: WO, watch: KO, created() { const t = this; this._view = void 0, this._defaultLayer = new A_({ source: new bm({ wrapX: this.wrapX }) }), zc()(this, { $map: { enumerable: !0, get() { return t.$olObject; } }, $view: { enumerable: !0, get() { return t._view; } } }); },
    }; function qO() { const t = this; io(this), ro(this); const e = 100; const n = gl(ml(this.$map, ['click', 'dblclick', 'singleclick']), ml(this.$map, ['pointerdrag', 'pointermove']).pipe(Bh(e), lh((t, e) => Object(gr.j)(t.coordinate, e.coordinate)))).pipe(dh(e => fr({}, e, { coordinate: t.pointToDataProj(e.coordinate) }))); const i = ml(this.$map, ['movestart', 'moveend', 'postrender', 'precompose', 'postcompose']); const r = gl(n, i); this.subscribeTo(r, e => t.$emit(e.type, e)); } const ZO = HO; const JO = function () { const t = this; const e = t.$createElement; const n = t._self._c || e; return n('div', { class: [t.$options.name], attrs: { tabindex: t.tabindex } }, [t._t('default')], 2); }; const QO = []; const tC = void 0; const eC = void 0; const nC = void 0; const iC = !1; function rC(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'map.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var oC = rC({ render: JO, staticRenderFns: QO }, tC, ZO, eC, iC, nC, void 0, void 0); const sC = {
      center: { type: Array, default() { return [0, 0]; }, validator(t) { return t.length === 2; } }, constrainRotation: { type: [Boolean, Number], default: !0 }, enableRotation: { type: Boolean, default: !0 }, extent: { type: Array, validator(t) { return t.length === 4; } }, maxResolution: Number, minResolution: Number, maxZoom: { type: Number, default: go }, minZoom: { type: Number, default: yo }, projection: { type: String, default: vo }, resolution: Number, resolutions: Array, rotation: { type: Number, default: 0 }, zoom: { type: Number, default: yo }, zoomFactor: { type: Number, default: bo },
    }; const aC = {
      viewZoom() { return this.rev && this.$view ? Math.round(this.$view.getZoom()) : this.zoom; }, viewRotation() { return this.rev && this.$view ? this.$view.getRotation() : this.rotation; }, viewResolution() { return this.rev && this.$view ? this.$view.getResolution() : this.resolution; }, viewCenter() { if (this.rev && this.$view) return this.pointToDataProj(this.$view.getCenter()); }, viewCenterViewProj() { if (this.rev && this.$view) return this.$view.getCenter(); }, resolvedDataProjection() { return Object(gr.b)(this.$viewContainer && this.$viewContainer.resolvedDataProjection, this.$options.dataProjection, this.viewProjection); },
    }; const uC = {
      animate() { for (var t = this, e = arguments.length, n = new Array(e), i = 0; i < e; i++)n[i] = arguments[i]; ro(this); let r = gr.t; return Object(gr.l)(n[n.length - 1]) && (r = n[n.length - 1], n = n.slice(0, n.length - 1)), n.forEach((e) => { Fo()(e.center) && (e.center = t.pointToViewProj(e.center)); }), new Ol.a(((e) => { let i; return (i = t.$view).animate.apply(i, el(n).concat([function (t) { r(t), e(t); }])); })); },
      createOlObject() {
        return new PS({
          center: this.pointToViewProj(this.center), constrainRotation: this.constrainRotation, enableRotation: this.enableRotation, extent: this.extent ? this.extentToViewProj(this.extent) : void 0, maxResolution: this.maxResolution, minResolution: this.minResolution, maxZoom: this.maxZoom, minZoom: this.minZoom, projection: this.projection, resolution: this.resolution, resolutions: this.resolutions, rotation: this.rotation, zoom: this.zoom, zoomFactor: this.zoomFactor,
        });
      },
      fit(t) { const e = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; ro(this), Object(gr.o)(t) ? t = this.readGeometryInDataProj(t) : t instanceof Rr.a && (t = t.$geometry); const i = n.callback || gr.t; return new Ol.a(((r) => { e.$view.fit(t, fr({}, n, { callback(t) { i(t), r(t); } })); })); },
      mount() { this.$viewContainer && this.$viewContainer.setView(this), this.subscribeAll(); },
      unmount() { this.unsubscribeAll(), this.$viewContainer && this.$viewContainer.setView(void 0); },
      subscribeAll() { lC.call(this); },
    }; const cC = {
      center(t) { t = this.pointToViewProj(t), !this.$view || this.$view.getAnimating() || Object(gr.j)(t, this.viewCenterViewProj) || this.$view.setCenter(t); }, resolution(t) { this.$view && !this.$view.getAnimating() && t !== this.viewResolution && this.$view.setResolution(t); }, zoom(t) { t = Math.round(t), this.$view && !this.$view.getAnimating() && t !== this.viewZoom && this.$view.setZoom(t); }, rotation(t) { this.$view && !this.$view.getAnimating() && t !== this.viewRotation && this.$view.setRotation(t); }, minZoom(t) { this.$view && t !== this.$view.getMinZoom() && this.$view.setMinZoom(t); }, maxZoom(t) { this.$view && t !== this.$view.getMaxZoom() && this.$view.setMaxZoom(t); }, resolvedDataProjection() { this.$view && this.$view.setCenter(this.pointToViewProj(this.center)); },
    }; const hC = {
      name: 'vl-view', mixins: [Ef, $c], props: sC, computed: aC, methods: uC, watch: cC, stubVNode: { empty() { return this.$options.name; } }, created() { const t = this; zc()(this, { $view: { enumerable: !0, get() { return t.$olObject; } }, $viewContainer: { enumerable: !0, get() { return t.$services && t.$services.viewContainer; } } }); },
    }; function lC() { const t = this; ro(this); const e = 1e3 / 60; const n = Qf(this.$view, 'resolution', !0, e); const i = n.pipe(dh(() => ({ prop: 'zoom', value: Math.round(t.$view.getZoom()) })), zO('value')); const r = gl(Qf(this.$view, 'center', !0, e, () => t.pointToDataProj(t.$view.getCenter())), Qf(this.$view, 'rotation', !0, e), n, i); this.subscribeTo(r, (e) => { const n = e.prop; const i = e.value; ++t.rev, t.$emit('update:'.concat(n), i); }); } const fC = hC; const pC = function () {
      const t = this; const e = t.$createElement; const n = t._self._c || e; return n('i', { class: [t.$options.name], staticStyle: { display: 'none !important' } }, [t._t('default', null, {
        center: t.viewCenter, zoom: t.viewZoom, resolution: t.viewResolution, rotation: t.viewRotation,
      })], 2);
    }; const dC = []; const vC = void 0; const gC = void 0; const yC = void 0; const mC = !1; function _C(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'view.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var bC = _C({ render: pC, staticRenderFns: dC }, vC, fC, gC, mC, yC, void 0, void 0); function wC(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; wC.installed || (wC.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(oC, e), Zd()(bC, e), t.component(oC.name, oC), t.component(bC.name, bC)); } var xC = wC; const EC = 'https://{a-c}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}{tileNameSuffix}.{tileFormat}?access_token={accessToken}'; const SC = `&copy; <a href="https://www.mapbox.com/" target="_blank">MapBox</a>, ${(new Date()).getFullYear()}`; const TC = {
      accessToken: { type: String, required: !0 }, attributions: { type: [String, Array], default: SC }, mapId: { type: String, required: !0 }, projection: { type: String, default: vo }, tileFormat: { type: String, default: _o }, url: { type: String, default: EC },
    }; const OC = { tileNameSuffix() { return IC(this.tilePixelRatio); }, urlTokens() { return ['mapId', 'accessToken', 'tileNameSuffix', 'tileFormat']; } }; const CC = {
      name: 'vl-source-mapbox', mixins: [Ug], props: TC, computed: OC,
    };
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function RC(t) { return t = Object(gr.b)(t, 1), t > 1 ? 2 : 1; } function IC(t) { return t = RC(t), t > 1 ? ['@', t, 'x'].join('') : ''; } const PC = CC; const LC = void 0; const AC = void 0; const FC = void 0; const jC = void 0; function kC(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var MC = kC({}, LC, PC, AC, jC, FC, void 0, void 0); function NC(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; NC.installed || (NC.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(MC, e), t.component(MC.name, MC)); } var DC = NC; const $C = 0; const GC = 1; const VC = { MODIFYSTART: 'modifystart', MODIFYEND: 'modifyend' }; const BC = (function (t) { function e(e, n, i) { t.call(this, e), this.features = n, this.mapBrowserEvent = i; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const UC = (function (t) {
      function e(e) {
        let n; if (t.call(this, e), this.condition_ = e.condition ? e.condition : t_, this.defaultDeleteCondition_ = function (t) { return Bm(t) && Hm(t); }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : Ym, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.modified_ = !1, this.rBush_ = new ym(), this.pixelTolerance_ = void 0 !== e.pixelTolerance ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new A_({
          source: new bm({ useSpatialIndex: !1, wrapX: !!e.wrapX }), style: e.style ? e.style : WC(), updateWhileAnimating: !0, updateWhileInteracting: !0,
        }), this.SEGMENT_WRITERS_ = {
          Point: this.writePointGeometry_, LineString: this.writeLineStringGeometry_, LinearRing: this.writeLineStringGeometry_, Polygon: this.writePolygonGeometry_, MultiPoint: this.writeMultiPointGeometry_, MultiLineString: this.writeMultiLineStringGeometry_, MultiPolygon: this.writeMultiPolygonGeometry_, Circle: this.writeCircleGeometry_, GeometryCollection: this.writeGeometryCollectionGeometry_,
        }, this.source_ = null, e.source ? (this.source_ = e.source, n = new hm(this.source_.getFeatures()), _e(this.source_, pm.ADDFEATURE, this.handleSourceAdd_, this), _e(this.source_, pm.REMOVEFEATURE, this.handleSourceRemove_, this)) : n = e.features, !n) throw new Error('The modify interaction requires features or a source'); this.features_ = n, this.features_.forEach(this.addFeature_.bind(this)), _e(this.features_, sm.ADD, this.handleFeatureAdd_, this), _e(this.features_, sm.REMOVE, this.handleFeatureRemove_, this), this.lastPointerEvent_ = null;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.addFeature_ = function (t) { const e = t.getGeometry(); e && e.getType() in this.SEGMENT_WRITERS_ && this.SEGMENT_WRITERS_[e.getType()].call(this, t, e); const n = this.getMap(); n && n.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, n), _e(t, Ae.CHANGE, this.handleFeatureChange_, this); }, e.prototype.willModifyFeatures_ = function (t) { this.modified_ || (this.modified_ = !0, this.dispatchEvent(new BC(VC.MODIFYSTART, this.features_, t))); }, e.prototype.removeFeature_ = function (t) { this.removeFeatureSegmentData_(t), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), we(t, Ae.CHANGE, this.handleFeatureChange_, this); }, e.prototype.removeFeatureSegmentData_ = function (t) { const e = this.rBush_; const n = []; e.forEach((e) => { t === e.feature && n.push(e); }); for (let i = n.length - 1; i >= 0; --i)e.remove(n[i]); }, e.prototype.setActive = function (e) { this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.prototype.setActive.call(this, e); }, e.prototype.setMap = function (e) { this.overlay_.setMap(e), t.prototype.setMap.call(this, e); }, e.prototype.getOverlay = function () { return this.overlay_; }, e.prototype.handleSourceAdd_ = function (t) { t.feature && this.features_.push(t.feature); }, e.prototype.handleSourceRemove_ = function (t) { t.feature && this.features_.remove(t.feature); }, e.prototype.handleFeatureAdd_ = function (t) { this.addFeature_(t.element); }, e.prototype.handleFeatureChange_ = function (t) { if (!this.changingFeature_) { const e = t.target; this.removeFeature_(e), this.addFeature_(e); } }, e.prototype.handleFeatureRemove_ = function (t) { const e = t.element; this.removeFeature_(e); }, e.prototype.writePointGeometry_ = function (t, e) { const n = e.getCoordinates(); const i = { feature: t, geometry: e, segment: [n, n] }; this.rBush_.insert(e.getExtent(), i); }, e.prototype.writeMultiPointGeometry_ = function (t, e) {
        for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) {
          const o = n[i]; const s = {
            feature: t, geometry: e, depth: [i], index: i, segment: [o, o],
          }; this.rBush_.insert(e.getExtent(), s);
        }
      }, e.prototype.writeLineStringGeometry_ = function (t, e) {
        for (let n = e.getCoordinates(), i = 0, r = n.length - 1; i < r; ++i) {
          const o = n.slice(i, i + 2); const s = {
            feature: t, geometry: e, index: i, segment: o,
          }; this.rBush_.insert(nt(o), s);
        }
      }, e.prototype.writeMultiLineStringGeometry_ = function (t, e) {
        for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) {
          for (let o = n[i], s = 0, a = o.length - 1; s < a; ++s) {
            const u = o.slice(s, s + 2); const c = {
              feature: t, geometry: e, depth: [i], index: s, segment: u,
            }; this.rBush_.insert(nt(u), c);
          }
        }
      }, e.prototype.writePolygonGeometry_ = function (t, e) {
        for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) {
          for (let o = n[i], s = 0, a = o.length - 1; s < a; ++s) {
            const u = o.slice(s, s + 2); const c = {
              feature: t, geometry: e, depth: [i], index: s, segment: u,
            }; this.rBush_.insert(nt(u), c);
          }
        }
      }, e.prototype.writeMultiPolygonGeometry_ = function (t, e) {
        for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) {
          for (let o = n[i], s = 0, a = o.length; s < a; ++s) {
            for (let u = o[s], c = 0, h = u.length - 1; c < h; ++c) {
              const l = u.slice(c, c + 2); const f = {
                feature: t, geometry: e, depth: [s, i], index: c, segment: l,
              }; this.rBush_.insert(nt(l), f);
            }
          }
        }
      }, e.prototype.writeCircleGeometry_ = function (t, e) {
        const n = e.getCenter(); const i = {
          feature: t, geometry: e, index: $C, segment: [n, n],
        }; const r = {
          feature: t, geometry: e, index: GC, segment: [n, n],
        }; const o = [i, r]; i.featureSegments = r.featureSegments = o, this.rBush_.insert(dt(n), i), this.rBush_.insert(e.getExtent(), r);
      }, e.prototype.writeGeometryCollectionGeometry_ = function (t, e) { for (let n = e.getGeometriesArray(), i = 0; i < n.length; ++i) this.SEGMENT_WRITERS_[n[i].getType()].call(this, t, n[i]); }, e.prototype.createOrUpdateVertexFeature_ = function (t) { let e = this.vertexFeature_; if (e) { const n = e.getGeometry(); n.setCoordinates(t); } else e = new Cr(new sa(t)), this.vertexFeature_ = e, this.overlay_.getSource().addFeature(e); return e; }, e.prototype.handleEvent = function (e) { return !e.pointerEvent || (this.lastPointerEvent_ = e, e.map.getView().getInteracting() || e.type != Vm.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (n = !(e.type != Vm.SINGLECLICK || !this.ignoreNextSingleClick_) || this.removePoint()), e.type == Vm.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), t.prototype.handleEvent.call(this, e) && !n); let n; }, e.prototype.handleDragEvent = function (t) { this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(t); for (var e = t.coordinate, n = 0, i = this.dragSegments_.length; n < i; ++n) { const r = this.dragSegments_[n]; const o = r[0]; const s = o.depth; const a = o.geometry; let u = void 0; const c = o.segment; const h = r[1]; while (e.length < a.getStride())e.push(c[h][e.length]); switch (a.getType()) { case en.POINT: u = e, c[0] = c[1] = e; break; case en.MULTI_POINT: u = a.getCoordinates(), u[o.index] = e, c[0] = c[1] = e; break; case en.LINE_STRING: u = a.getCoordinates(), u[o.index + h] = e, c[h] = e; break; case en.MULTI_LINE_STRING: u = a.getCoordinates(), u[s[0]][o.index + h] = e, c[h] = e; break; case en.POLYGON: u = a.getCoordinates(), u[s[0]][o.index + h] = e, c[h] = e; break; case en.MULTI_POLYGON: u = a.getCoordinates(), u[s[1]][s[0]][o.index + h] = e, c[h] = e; break; case en.CIRCLE: c[0] = c[1] = e, o.index === $C ? (this.changingFeature_ = !0, a.setCenter(e), this.changingFeature_ = !1) : (this.changingFeature_ = !0, a.setRadius(rm(a.getCenter(), e)), this.changingFeature_ = !1); break; default: }u && this.setGeometryCoordinates_(a, u); } this.createOrUpdateVertexFeature_(e); }, e.prototype.handleDownEvent = function (t) { if (!this.condition_(t)) return !1; this.handlePointerAtPixel_(t.pixel, t.map); const e = t.map.getCoordinateFromPixel(t.pixel); this.dragSegments_.length = 0, this.modified_ = !1; const n = this.vertexFeature_; if (n) { const i = []; const r = n.getGeometry(); const o = r.getCoordinates(); const s = nt([o]); const a = this.rBush_.getInExtent(s); const u = {}; a.sort(zC); for (let c = 0, h = a.length; c < h; ++c) { const l = a[c]; const f = l.segment; let p = H(l.feature); const d = l.depth; if (d && (p += `-${d.join('-')}`), u[p] || (u[p] = new Array(2)), l.geometry.getType() === en.CIRCLE && l.index === GC) { const v = XC(e, l); tm(v, o) && !u[p][0] && (this.dragSegments_.push([l, 0]), u[p][0] = l); } else if (tm(f[0], o) && !u[p][0]) this.dragSegments_.push([l, 0]), u[p][0] = l; else if (tm(f[1], o) && !u[p][1]) { if ((l.geometry.getType() === en.LINE_STRING || l.geometry.getType() === en.MULTI_LINE_STRING) && u[p][0] && u[p][0].index === 0) continue; this.dragSegments_.push([l, 1]), u[p][1] = l; } else this.insertVertexCondition_(t) && H(f) in this.vertexSegments_ && !u[p][0] && !u[p][1] && i.push([l, o]); }i.length && this.willModifyFeatures_(t); for (let g = i.length - 1; g >= 0; --g) this.insertVertex_.apply(this, i[g]); } return !!this.vertexFeature_; }, e.prototype.handleUpEvent = function (t) { for (let e = this.dragSegments_.length - 1; e >= 0; --e) { const n = this.dragSegments_[e][0]; const i = n.geometry; if (i.getType() === en.CIRCLE) { const r = i.getCenter(); const o = n.featureSegments[0]; const s = n.featureSegments[1]; o.segment[0] = o.segment[1] = r, s.segment[0] = s.segment[1] = r, this.rBush_.update(dt(r), o), this.rBush_.update(i.getExtent(), s); } else this.rBush_.update(nt(n.segment), n); } return this.modified_ && (this.dispatchEvent(new BC(VC.MODIFYEND, this.features_, t)), this.modified_ = !1), !1; }, e.prototype.handlePointerMove_ = function (t) { this.lastPixel_ = t.pixel, this.handlePointerAtPixel_(t.pixel, t.map); }, e.prototype.handlePointerAtPixel_ = function (t, e) { const n = e.getCoordinateFromPixel(t); const i = function (t, e) { return YC(n, t) - YC(n, e); }; const r = rt(dt(n), e.getView().getResolution() * this.pixelTolerance_); const o = this.rBush_; const s = o.getInExtent(r); if (s.length > 0) { s.sort(i); const a = s[0]; const u = a.segment; let c = XC(n, a); const h = e.getPixelFromCoordinate(c); let l = rm(t, h); if (l <= this.pixelTolerance_) { const f = {}; if (a.geometry.getType() === en.CIRCLE && a.index === GC) this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(c); else { const p = e.getPixelFromCoordinate(u[0]); const d = e.getPixelFromCoordinate(u[1]); const v = im(h, p); const g = im(h, d); l = Math.sqrt(Math.min(v, g)), this.snappedToVertex_ = l <= this.pixelTolerance_, this.snappedToVertex_ && (c = v > g ? u[1] : u[0]), this.createOrUpdateVertexFeature_(c); for (let y = 1, m = s.length; y < m; ++y) { const _ = s[y].segment; if (!(tm(u[0], _[0]) && tm(u[1], _[1]) || tm(u[0], _[1]) && tm(u[1], _[0]))) break; f[H(_)] = !0; } } return f[H(u)] = !0, void (this.vertexSegments_ = f); } } this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null); }, e.prototype.insertVertex_ = function (t, e) {
        let n; const i = t.segment; const r = t.feature; const o = t.geometry; const s = t.depth; const a = t.index; while (e.length < o.getStride())e.push(0); switch (o.getType()) { case en.MULTI_LINE_STRING: n = o.getCoordinates(), n[s[0]].splice(a + 1, 0, e); break; case en.POLYGON: n = o.getCoordinates(), n[s[0]].splice(a + 1, 0, e); break; case en.MULTI_POLYGON: n = o.getCoordinates(), n[s[1]][s[0]].splice(a + 1, 0, e); break; case en.LINE_STRING: n = o.getCoordinates(), n.splice(a + 1, 0, e); break; default: return; } this.setGeometryCoordinates_(o, n); const u = this.rBush_; u.remove(t), this.updateSegmentIndices_(o, a, s, 1); const c = {
          segment: [i[0], e], feature: r, geometry: o, depth: s, index: a,
        }; u.insert(nt(c.segment), c), this.dragSegments_.push([c, 1]); const h = {
          segment: [e, i[1]], feature: r, geometry: o, depth: s, index: a + 1,
        }; u.insert(nt(h.segment), h), this.dragSegments_.push([h, 0]), this.ignoreNextSingleClick_ = !0;
      }, e.prototype.removePoint = function () { if (this.lastPointerEvent_ && this.lastPointerEvent_.type != Vm.POINTERDRAG) { const t = this.lastPointerEvent_; return this.willModifyFeatures_(t), this.removeVertex_(), this.dispatchEvent(new BC(VC.MODIFYEND, this.features_, t)), this.modified_ = !1, !0; } return !1; }, e.prototype.removeVertex_ = function () {
        let t; let e; let n; let i; let r; let o; let s; let a; let u; let c; let h; const l = this.dragSegments_; const f = {}; let p = !1; for (r = l.length - 1; r >= 0; --r)n = l[r], c = n[0], h = H(c.feature), c.depth && (h += `-${c.depth.join('-')}`), h in f || (f[h] = {}), n[1] === 0 ? (f[h].right = c, f[h].index = c.index) : n[1] == 1 && (f[h].left = c, f[h].index = c.index + 1); for (h in f) {
          switch (u = f[h].right, s = f[h].left, o = f[h].index, a = o - 1, c = void 0 !== s ? s : u, a < 0 && (a = 0), i = c.geometry, e = i.getCoordinates(), t = e, p = !1, i.getType()) { case en.MULTI_LINE_STRING: e[c.depth[0]].length > 2 && (e[c.depth[0]].splice(o, 1), p = !0); break; case en.LINE_STRING: e.length > 2 && (e.splice(o, 1), p = !0); break; case en.MULTI_POLYGON: t = t[c.depth[1]]; case en.POLYGON: t = t[c.depth[0]], t.length > 4 && (o == t.length - 1 && (o = 0), t.splice(o, 1), p = !0, o === 0 && (t.pop(), t.push(t[0]), a = t.length - 1)); break; default: } if (p) {
            this.setGeometryCoordinates_(i, e); const d = []; if (void 0 !== s && (this.rBush_.remove(s), d.push(s.segment[0])), void 0 !== u && (this.rBush_.remove(u), d.push(u.segment[1])), void 0 !== s && void 0 !== u) {
              const v = {
                depth: c.depth, feature: c.feature, geometry: c.geometry, index: a, segment: d,
              }; this.rBush_.insert(nt(v.segment), v);
            } this.updateSegmentIndices_(i, o, c.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), l.length = 0;
          }
        } return p;
      }, e.prototype.setGeometryCoordinates_ = function (t, e) { this.changingFeature_ = !0, t.setCoordinates(e), this.changingFeature_ = !1; }, e.prototype.updateSegmentIndices_ = function (t, e, n, i) { this.rBush_.forEachInExtent(t.getExtent(), (r) => { r.geometry === t && (void 0 === n || void 0 === r.depth || Li(r.depth, n)) && r.index > e && (r.index += i); }); }, e;
    }(E_)); function zC(t, e) { return t.index - e.index; } function YC(t, e) { const n = e.geometry; if (n.getType() === en.CIRCLE) { const i = n; if (e.index === GC) { const r = im(i.getCenter(), t); const o = Math.sqrt(r) - i.getRadius(); return o * o; } } return om(t, e.segment); } function XC(t, e) { const n = e.geometry; return n.getType() === en.CIRCLE && e.index === GC ? n.getClosestPoint(t) : Jy(t, e.segment); } function WC() { const t = fg(); return function (e, n) { return t[en.POINT]; }; } const KC = UC; const HC = {
      source: { type: String, required: !0 }, condition: { type: Function, default: t_ }, deleteCondition: { type: Function, default: Bm }, insertVertexCondition: { type: Function, default: Ym }, pixelTolerance: { type: Number, default: 10 }, wrapX: { type: Boolean, default: !1 },
    }; const qC = {
      createInteraction: (function () {
        const t = Rl(Sl.a.mark(function t() {
          let e; let n; let i; return Sl.a.wrap(function (t) {
            while (1) {
              switch (t.prev = t.next) {
                case 0: return e = this.makeIdent(this.source), t.next = 3, this.$identityMap.get(e, this.$options.INSTANCE_PROMISE_POOL); case 3: return n = t.sent, Object(gr.l)(n.getFeatures) && (i = n.getFeatures(), Oc(i) && (n = i)), t.abrupt('return', new KC({
                  source: Cc(n) ? n : void 0, features: Oc(n) ? n : void 0, deleteCondition: this.deleteCondition, insertVertexCondition: this.insertVertexCondition, pixelTolerance: this.pixelTolerance, style: this.createStyleFunc(), wrapX: this.wrapX,
                })); case 6: case 'end': return t.stop();
              }
            }
          }, t, this);
        })); return function () { return t.apply(this, arguments); };
      }()),
      getDefaultStyles() { const t = Object(gr.s)(wg(), t => t.map(Eg)); return function (e) { if (e.getGeometry()) return t[e.getGeometry().getType()]; }; },
      getServices() { return xl(fp.methods.getServices.call(this), td.methods.getServices.call(this)); },
      getStyleTarget() { return this.$interaction; },
      mount() { fp.methods.mount.call(this); },
      unmount() { fp.methods.unmount.call(this); },
      setStyle(t) { t !== this._styles && (this._styles = t, this.scheduleRefresh()); },
      subscribeAll() { QC.call(this); },
    }; const ZC = Sf(['source'], () => function () { this.scheduleRecreate(); }); const JC = {
      name: 'vl-interaction-modify', mixins: [fp, td], props: HC, methods: qC, watch: ZC,
    };
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function QC() { const t = this; ho(this); const e = ml(this.$interaction, ['modifystart', 'modifyend']); this.subscribeTo(e, (e) => { ++t.rev, t.$emit(e.type, e); }); } const tR = JC; const eR = void 0; const nR = void 0; const iR = void 0; const rR = void 0; function oR(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'interaction.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var sR = oR({}, eR, tR, nR, rR, iR, void 0, void 0); function aR(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; aR.installed || (aR.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(sR, e), t.component(sR.name, sR)); } var uR = aR; const cR = {}; const hR = { type: Object(gr.c)(To.MULTI_LINE_STRING) }; const lR = { createGeometry() { return new ra(this.toViewProj(this.coordinates)); } }; const fR = {
      name: 'vl-geom-multi-line-string', mixins: [$f], props: cR, computed: hR, methods: lR,
    }; const pR = fR; const dR = void 0; const vR = void 0; const gR = void 0; const yR = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function mR(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var _R = mR({}, dR, pR, vR, yR, gR, void 0, void 0); function bR(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; bR.installed || (bR.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(_R, e), t.component(_R.name, _R)); } var wR = bR; const xR = {}; const ER = { type: Object(gr.c)(To.MULTI_POINT) }; const SR = { createGeometry() { return new ua(this.toViewProj(this.coordinates)); } }; const TR = {
      name: 'vl-geom-multi-point', mixins: [$f], props: xR, computed: ER, methods: SR,
    }; const OR = TR; const CR = void 0; const RR = void 0; const IR = void 0; const PR = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function LR(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var AR = LR({}, CR, OR, RR, PR, IR, void 0, void 0); function FR(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; FR.installed || (FR.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(AR, e), t.component(AR.name, AR)); } var jR = FR; const kR = {}; const MR = { type: Object(gr.c)(To.MULTI_POLYGON) }; const NR = { createGeometry() { return new Pa(this.toViewProj(this.coordinates)); } }; const DR = {
      name: 'vl-geom-multi-polygon', mixins: [$f], props: kR, computed: MR, methods: NR,
    }; const $R = DR; const GR = void 0; const VR = void 0; const BR = void 0; const UR = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function zR(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var YR = zR({}, GR, $R, VR, UR, BR, void 0, void 0); function XR(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; XR.installed || (XR.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(YR, e), t.component(YR.name, YR)); } var WR = XR; const KR = '&#169; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors.'; const HR = (function (t) {
      function e(e) {
        let n; const i = e || {}; n = void 0 !== i.attributions ? i.attributions : [KR]; const r = void 0 !== i.crossOrigin ? i.crossOrigin : 'anonymous'; const
          o = void 0 !== i.url ? i.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'; t.call(this, {
          attributions: n, cacheSize: i.cacheSize, crossOrigin: r, opaque: void 0 === i.opaque || i.opaque, maxZoom: void 0 !== i.maxZoom ? i.maxZoom : 19, reprojectionErrorThreshold: i.reprojectionErrorThreshold, tileLoadFunction: i.tileLoadFunction, url: o, wrapX: i.wrapX, attributionsCollapsible: !1,
        });
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
    }($g)); const qR = HR; const ZR = '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.'; const JR = 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'; const QR = 19; const tI = { attributions: { type: [String, Array], default: ZR }, maxZoom: { type: Number, default: QR }, url: { type: String, default: JR } }; const eI = {
      createSource() {
        return new qR({
          url: this.urlTmpl, attributions: this.attributions, crossOrigin: this.crossOrigin, maxZoom: this.maxZoom, cacheSize: this.cacheSize, opaque: this.opaque, reprojectionErrorThreshold: this.reprojectionErrorThreshold, wrapX: this.wrapX, transition: this.transition,
        });
      },
    }; const nI = {
      name: 'vl-source-osm', mixins: [Ug], props: tI, methods: eI,
    }; const iI = nI; const rI = void 0; const oI = void 0; const sI = void 0; const aI = void 0; function uI(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var cI = uI({}, rI, iI, oI, aI, sI, void 0, void 0); function hI(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; hI.installed || (hI.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(cI, e), t.component(cI.name, cI)); } var lI = hI; const fI = {
      id: { type: [String, Number], default() { return Pr()(); } }, offset: { type: Array, default() { return [0, 0]; }, validator(t) { return t.length === 2; } }, position: { type: Array, validator(t) { return t.length === 2; }, required: !0 }, positioning: { type: String, default: Co.TOP_LEFT, validator(t) { return Gm()(Co).includes(t); } }, stopEvent: { type: Boolean, default: !0 }, insertFirst: { type: Boolean, default: !0 }, autoPan: { type: Boolean, default: !1 }, autoPanMargin: { type: Number, default: 20 }, autoPanAnimation: Object,
    }; const pI = { positionViewProj() { if (this.rev && this.$overlay) return this.$overlay.getPosition(); }, positionDataProj() { if (this.rev && this.$overlay) return this.pointToDataProj(this.$overlay.getPosition()); }, classes() { return [this.$options.name, this.visible ? 'visible' : void 0].filter(gr.h); } }; const dI = {
      createOlObject() {
        return new Hp({
          id: this.id, offset: this.offset, position: this.pointToViewProj(this.position), positioning: this.positioning, stopEvent: this.stopEvent, insertFirst: this.insertFirst, autoPan: this.autoPan, autoPanMargin: this.autoPanMargin, autoPanAnimation: this.autoPanAnimation,
        });
      },
      mount() { const t = this; lo(this), this.$overlay.setElement(this.$el), this.$overlaysContainer && this.$overlaysContainer.addOverlay(this.$overlay), this.$nextTick(() => { t.$overlay.setPosition(t.positionViewProj.slice()), t.visible = !0; }), this.subscribeAll(); },
      unmount() { lo(this), this.unsubscribeAll(), this.$overlay.setElement(void 0), this.$overlaysContainer && this.$overlaysContainer.removeOverlay(this.$overlay), this.visible = !1; },
      subscribeAll() { yI.call(this); },
    }; const vI = {
      offset(t) { this.$overlay && !Object(gr.j)(t, this.$overlay.getOffset()) && this.$overlay.setOffset(t); }, position(t) { t = this.pointToViewProj(t), this.$overlay && !Object(gr.j)(t, this.positionViewProj) && this.$overlay.setPosition(t); }, positioning(t) { this.$overlay && t !== this.$overlay.getPositioning() && this.$overlay.setPositioning(t); }, resolvedDataProjection() { this.$overlay && this.$overlay.setPosition(this.pointToViewProj(this.position)); },
    }; const gI = {
      name: 'vl-overlay',
      mixins: [Ef, Lf, $c],
      props: fI,
      computed: pI,
      methods: dI,
      watch: vI,
      created() {
        const t = this; zc()(this, {
          $overlay: { enumerable: !0, get() { return t.$olObject; } }, $map: { enumerable: !0, get() { return t.$services && t.$services.map; } }, $view: { enumerable: !0, get() { return t.$services && t.$services.view; } }, $overlaysContainer: { enumerable: !0, get() { return t.$services && t.$services.overlaysContainer; } },
        });
      },
      data() { return { visible: !1 }; },
    };
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function yI() { const t = this; lo(this); const e = 1e3 / 60; const n = gl(Qf(this.$overlay, 'position', !0, e, () => t.pointToDataProj(t.$overlay.getPosition())), Qf(this.$overlay, ['offset', 'positioning'], !0, e)); this.subscribeTo(n, (e) => { const n = e.prop; const i = e.value; ++t.rev, t.$emit('update:'.concat(n), i); }); } const mI = gI; const _I = function () {
      const t = this; const e = t.$createElement; const n = t._self._c || e; return n('div', { class: t.classes, attrs: { id: [t.$options.name, t.id].join('-') } }, [t._t('default', null, {
        id: t.id, position: t.position, offset: t.offset, positioning: t.positioning,
      })], 2);
    }; const bI = []; const wI = void 0; const xI = void 0; const EI = void 0; const SI = !1; function TI(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'overlay.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var OI = TI({ render: _I, staticRenderFns: bI }, wI, mI, xI, SI, EI, void 0, void 0); function CI(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; CI.installed || (CI.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(OI, e), t.component(OI.name, OI)); } var RI = CI; const II = { coordinates: { type: Array, required: !0, validator(t) { return t.length === 2; } } }; const PI = { type: Object(gr.c)(To.POINT) }; const LI = { createGeometry() { return new sa(this.toViewProj(this.coordinates)); } }; const AI = {
      name: 'vl-geom-point', mixins: [$f], props: II, computed: PI, methods: LI,
    }; const FI = AI; const jI = void 0; const kI = void 0; const MI = void 0; const NI = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function DI(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var $I = DI({}, jI, FI, kI, NI, MI, void 0, void 0); function GI(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; GI.installed || (GI.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()($I, e), t.component($I.name, $I)); } var VI = GI; const BI = {}; const UI = { type: Object(gr.c)(To.POLYGON) }; const zI = { createGeometry() { return new Ea(this.toViewProj(this.coordinates)); } }; const YI = {
      name: 'vl-geom-polygon', mixins: [$f], props: BI, computed: UI, methods: zI,
    }; const XI = YI; const WI = void 0; const KI = void 0; const HI = void 0; const qI = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function ZI(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'geom.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var JI = ZI({}, WI, XI, KI, qI, HI, void 0, void 0); function QI(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; QI.installed || (QI.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(JI, e), t.component(JI.name, JI)); } var tP = QI; const eP = {
      points: { type: Number, required: !0 }, radius: Number, radius1: Number, radius2: Number, angle: { type: Number, default: 0 }, rotation: { type: Number, default: 0 }, rotateWithView: { type: Boolean, default: !1 },
    }; const nP = {
      createStyle() {
        return Xv({
          points: this.points, radius: this.radius, radius1: this.radius1, radius2: this.radius2, angle: this.angle, rotation: this.rotation, rotateWithView: this.rotateWithView, fill: this._fill, stroke: this._stroke,
        });
      },
      getServices() { const t = this; return xl(ap.methods.getServices.call(this), { get stylesContainer() { return t; } }); },
      setFill(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._fill && (this._fill = t, this.scheduleRefresh()); },
      setStroke(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._stroke && (this._stroke = t, this.scheduleRefresh()); },
    }; const iP = {
      points(t) { this.$style && !Object(gr.j)(t, this.$style.getPoints()) && this.scheduleRefresh(); }, radius(t) { this.$style && !Object(gr.j)(t, this.$style.getRadius()) && this.scheduleRefresh(); }, radius1(t) { this.$style && !Object(gr.j)(t, this.$style.getRadius()) && this.scheduleRefresh(); }, radius2(t) { this.$style && !Object(gr.j)(t, this.$style.getRadius2()) && this.scheduleRefresh(); }, angle(t) { this.$style && !Object(gr.j)(t, this.$style.getAngle()) && this.scheduleRefresh(); }, rotation(t) { this.$style && !Object(gr.j)(t, this.$style.getRotation()) && this.scheduleRefresh(); }, rotateWithView(t) { this.$style && !Object(gr.j)(t, this.$style.getRotateWithView()) && this.scheduleRefresh(); },
    }; const rP = {
      name: 'vl-style-reg-shape', mixins: [ap, Kd], props: eP, methods: nP, watch: iP,
    }; const oP = rP; const sP = void 0; const aP = void 0; const uP = void 0; const cP = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function hP(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var lP = hP({}, sP, oP, aP, cP, uP, void 0, void 0); function fP(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; fP.installed || (fP.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(lP, e), t.component(lP.name, lP)); } var pP = fP; const dP = { SELECT: 'select' }; const vP = (function (t) { function e(e, n, i, r) { t.call(this, e), this.selected = n, this.deselected = i, this.mapBrowserEvent = r; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e; }(Ie)); const gP = (function (t) {
      function e(e) {
        t.call(this, { handleEvent: yP }); const n = e || {}; this.condition_ = n.condition ? n.condition : Hm, this.addCondition_ = n.addCondition ? n.addCondition : Wm, this.removeCondition_ = n.removeCondition ? n.removeCondition : Wm, this.toggleCondition_ = n.toggleCondition ? n.toggleCondition : Zm, this.multi_ = !!n.multi && n.multi, this.filter_ = n.filter ? n.filter : Se, this.hitTolerance_ = n.hitTolerance ? n.hitTolerance : 0; let i; const r = new A_({
          source: new bm({ useSpatialIndex: !1, features: n.features, wrapX: n.wrapX }), style: n.style ? n.style : mP(), updateWhileAnimating: !0, updateWhileInteracting: !0,
        }); if (this.featureOverlay_ = r, n.layers) if (typeof n.layers === 'function')i = n.layers; else { const o = n.layers; i = function (t) { return Oi(o, t); }; } else i = Se; this.layerFilter_ = i, this.featureLayerAssociation_ = {}; const s = this.getFeatures(); _e(s, sm.ADD, this.addFeature_, this), _e(s, sm.REMOVE, this.removeFeature_, this);
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.addFeatureLayerAssociation_ = function (t, e) { this.featureLayerAssociation_[H(t)] = e; }, e.prototype.getFeatures = function () { return this.featureOverlay_.getSource().getFeaturesCollection(); }, e.prototype.getHitTolerance = function () { return this.hitTolerance_; }, e.prototype.getLayer = function (t) { return this.featureLayerAssociation_[H(t)]; }, e.prototype.getOverlay = function () { return this.featureOverlay_; }, e.prototype.setHitTolerance = function (t) { this.hitTolerance_ = t; }, e.prototype.setMap = function (e) { const n = this.getMap(); const i = this.getFeatures(); n && i.forEach(n.unskipFeature.bind(n)), t.prototype.setMap.call(this, e), this.featureOverlay_.setMap(e), e && i.forEach(e.skipFeature.bind(e)); }, e.prototype.addFeature_ = function (t) { const e = this.getMap(); e && e.skipFeature(t.element); }, e.prototype.removeFeature_ = function (t) { const e = this.getMap(); e && e.unskipFeature(t.element); }, e.prototype.removeFeatureLayerAssociation_ = function (t) { delete this.featureLayerAssociation_[H(t)]; }, e;
    }(wp)); function yP(t) { if (!this.condition_(t)) return !0; const e = this.addCondition_(t); const n = this.removeCondition_(t); const i = this.toggleCondition_(t); const r = !e && !n && !i; const o = t.map; const s = this.getFeatures(); const a = []; const u = []; if (r) { Zt(this.featureLayerAssociation_), o.forEachFeatureAtPixel(t.pixel, (t, e) => { if (this.filter_(t, e)) return u.push(t), this.addFeatureLayerAssociation_(t, e), !this.multi_; }, { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }); for (let c = s.getLength() - 1; c >= 0; --c) { const h = s.item(c); const l = u.indexOf(h); l > -1 ? u.splice(l, 1) : (s.remove(h), a.push(h)); }u.length !== 0 && s.extend(u); } else { o.forEachFeatureAtPixel(t.pixel, (t, r) => { if (this.filter_(t, r)) return !e && !i || Oi(s.getArray(), t) ? (n || i) && Oi(s.getArray(), t) && (a.push(t), this.removeFeatureLayerAssociation_(t)) : (u.push(t), this.addFeatureLayerAssociation_(t, r)), !this.multi_; }, { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }); for (let f = a.length - 1; f >= 0; --f)s.remove(a[f]); s.extend(u); } return (u.length > 0 || a.length > 0) && this.dispatchEvent(new vP(dP.SELECT, u, a, t)), Km(t); } function mP() { const t = fg(); return Ii(t[en.POLYGON], t[en.LINE_STRING]), Ii(t[en.GEOMETRY_COLLECTION], t[en.LINE_STRING]), function (e, n) { return e.getGeometry() ? t[e.getGeometry().getType()] : null; }; } const _P = gP; const bP = {
      filter: { type: Function, default: Object(gr.c)(!0) }, hitTolerance: { type: Number, default: 0 }, multi: { type: Boolean, default: !1 }, features: { type: Array, default: gr.z }, wrapX: { type: Boolean, default: !0 }, addCondition: { type: Function, default: Wm }, condition: { type: Function, default: Hm }, removeCondition: { type: Function, default: Wm }, toggleCondition: { type: Function, default: Zm },
    }; const wP = {}; const xP = {
      createInteraction() {
        return new _P({
          multi: this.multi, wrapX: this.wrapX, filter: this.filter, style: this.createStyleFunc(), addCondition: this.addCondition, condition: this.condition, removeCondition: this.removeCondition, toggleCondition: this.toggleCondition,
        });
      },
      getDefaultStyles() { const t = Object(gr.s)(wg(), t => t.map(Eg)); return function (e) { if (e.getGeometry()) return t[e.getGeometry().getType()]; }; },
      getFeatures() { return this.$interaction && this.$interaction.getFeatures().getArray() || []; },
      getServices() { return xl(fp.methods.getServices.call(this), td.methods.getServices.call(this)); },
      getStyleTarget() { return this.$interaction; },
      mount() { fp.methods.mount.call(this), this.features.forEach(this.select); },
      unmount() { this.unselectAll(), fp.methods.unmount.call(this); },
      select(t) { io(this), ho(this); const e = Ar(t); if (!e) throw new Error('Undefined feature id'); t instanceof Rr.a && (t = t.$feature); const n = this.$features.map(Ar); n.includes(e) || (t instanceof Cr || (t = void 0, Object(gr.f)(this.$map.getLayers().getArray(), (n) => { const i = n.getSource(); return i && Object(gr.l)(i.getFeatureById) && (t = i.getFeatureById(e)), !t; })), t && this.$interaction.getFeatures().push(t)); },
      unselect(t) { ho(this); const e = Ar(t); if (!e) throw new Error('Undefined feature id'); t instanceof Rr.a && (t = t.$feature); const n = this.$features.map(Ar); const i = n.findIndex(t => t === e); i !== -1 && this.$interaction.getFeatures().removeAt(i); },
      setStyle(t) { t !== this._styles && (this._styles = t, this.scheduleRefresh()); },
      refresh() { const t = this; return Ol.a.all([new Ol.a(((e) => { if (t.$interaction) { const n = t.$interaction.getFeatures(); n.once('change', () => e()), n.changed(); } else e(); })), fp.methods.refresh.call(this)]); },
      subscribeAll() { TP.call(this); },
      unselectAll() { ho(this), this.$interaction.getFeatures().clear(); },
    }; const EP = { features(t) { if (this.$interaction) { const e = function (t, e) { return Ar(t) === Ar(e); }; const n = Object(gr.d)(t, this.$features, e); const i = Object(gr.d)(this.$features, t, e); n.forEach(this.select), i.forEach(this.unselect); } } }; const SP = {
      name: 'vl-interaction-select', mixins: [fp, td, $c], props: bP, computed: wP, methods: xP, watch: EP, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } }, created() { zc()(this, { $features: { enumerable: !0, get: this.getFeatures } }); },
    };
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function TP() { const t = this; ho(this); const e = ml(this.$interaction, 'select'); this.subscribeTo(e, (e) => { const n = e.selected; const i = e.deselected; const r = e.mapBrowserEvent; ++t.rev, i.forEach(e => t.$emit('unselect', { feature: e, mapBrowserEvent: r })), n.forEach(e => t.$emit('select', { feature: e, mapBrowserEvent: r })), t.$emit('update:features', t.$features.map(t.writeFeatureInDataProj.bind(t))); }); } const OP = SP; const CP = function () { const t = this; const e = t.$createElement; const n = t._self._c || e; return n('i', { class: [t.$options.name], staticStyle: { display: 'none !important' } }, [t._t('default', null, { features: t.features })], 2); }; const RP = []; const IP = void 0; const PP = void 0; const LP = void 0; const AP = !1; function FP(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'interaction.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var jP = FP({ render: CP, staticRenderFns: RP }, IP, OP, PP, AP, LP, void 0, void 0); function kP(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; kP.installed || (kP.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(jP, e), t.component(jP.name, jP)); } var MP = kP; function NP(t) { return t.feature ? t.feature : t.element ? t.element : void 0; } const DP = (function (t) {
      function e(e) {
        const n = e || {}; const i = n; i.handleDownEvent || (i.handleDownEvent = Se), i.stopDown || (i.stopDown = Te), t.call(this, i), this.source_ = n.source ? n.source : null, this.vertex_ = void 0 === n.vertex || n.vertex, this.edge_ = void 0 === n.edge || n.edge, this.features_ = n.features ? n.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelCoordinate_ = null, this.pixelTolerance_ = void 0 !== n.pixelTolerance ? n.pixelTolerance : 10, this.sortByDistance_ = $P.bind(this), this.rBush_ = new ym(), this.SEGMENT_WRITERS_ = {
          Point: this.writePointGeometry_, LineString: this.writeLineStringGeometry_, LinearRing: this.writeLineStringGeometry_, Polygon: this.writePolygonGeometry_, MultiPoint: this.writeMultiPointGeometry_, MultiLineString: this.writeMultiLineStringGeometry_, MultiPolygon: this.writeMultiPolygonGeometry_, GeometryCollection: this.writeGeometryCollectionGeometry_, Circle: this.writeCircleGeometry_,
        };
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.addFeature = function (t, e) { const n = void 0 === e || e; const i = H(t); const r = t.getGeometry(); if (r) { const o = this.SEGMENT_WRITERS_[r.getType()]; o && (this.indexedFeaturesExtents_[i] = r.getExtent(lt()), o.call(this, t, r)); }n && (this.featureChangeListenerKeys_[i] = _e(t, Ae.CHANGE, this.handleFeatureChange_, this)); }, e.prototype.forEachFeatureAdd_ = function (t) { this.addFeature(t); }, e.prototype.forEachFeatureRemove_ = function (t) { this.removeFeature(t); }, e.prototype.getFeatures_ = function () { let t; return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t; }, e.prototype.handleEvent = function (e) { const n = this.snapTo(e.pixel, e.coordinate, e.map); return n.snapped && (e.coordinate = n.vertex.slice(0, 2), e.pixel = n.vertexPixel), t.prototype.handleEvent.call(this, e); }, e.prototype.handleFeatureAdd_ = function (t) { const e = NP(t); this.addFeature(e); }, e.prototype.handleFeatureRemove_ = function (t) { const e = NP(t); this.removeFeature(e); }, e.prototype.handleFeatureChange_ = function (t) { const e = t.target; if (this.handlingDownUpSequence) { const n = H(e); n in this.pendingFeatures_ || (this.pendingFeatures_[n] = e); } else this.updateFeature_(e); }, e.prototype.handleUpEvent = function (t) { const e = Jt(this.pendingFeatures_); return e.length && (e.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1; }, e.prototype.removeFeature = function (t, e) { const n = void 0 === e || e; const i = H(t); const r = this.indexedFeaturesExtents_[i]; if (r) { const o = this.rBush_; const s = []; o.forEachInExtent(r, (e) => { t === e.feature && s.push(e); }); for (let a = s.length - 1; a >= 0; --a)o.remove(s[a]); }n && (xe(this.featureChangeListenerKeys_[i]), delete this.featureChangeListenerKeys_[i]); }, e.prototype.setMap = function (e) { const n = this.getMap(); const i = this.featuresListenerKeys_; const r = this.getFeatures_(); n && (i.forEach(xe), i.length = 0, r.forEach(this.forEachFeatureRemove_.bind(this))), t.prototype.setMap.call(this, e), e && (this.features_ ? i.push(_e(this.features_, sm.ADD, this.handleFeatureAdd_, this), _e(this.features_, sm.REMOVE, this.handleFeatureRemove_, this)) : this.source_ && i.push(_e(this.source_, pm.ADDFEATURE, this.handleFeatureAdd_, this), _e(this.source_, pm.REMOVEFEATURE, this.handleFeatureRemove_, this)), r.forEach(this.forEachFeatureAdd_.bind(this))); }, e.prototype.snapTo = function (t, e, n) { const i = n.getCoordinateFromPixel([t[0] - this.pixelTolerance_, t[1] + this.pixelTolerance_]); const r = n.getCoordinateFromPixel([t[0] + this.pixelTolerance_, t[1] - this.pixelTolerance_]); const o = nt([i, r]); let s = this.rBush_.getInExtent(o); this.vertex_ && !this.edge_ && (s = s.filter(t => t.feature.getGeometry().getType() !== en.CIRCLE)); let a; let u; let c; let h; let l; let f = !1; let p = !1; let d = null; let v = null; if (s.length > 0) { this.pixelCoordinate_ = e, s.sort(this.sortByDistance_); const g = s[0].segment; const y = s[0].feature.getGeometry().getType() === en.CIRCLE; this.vertex_ && !this.edge_ ? (u = n.getPixelFromCoordinate(g[0]), c = n.getPixelFromCoordinate(g[1]), h = im(t, u), l = im(t, c), a = Math.sqrt(Math.min(h, l)), f = a <= this.pixelTolerance_, f && (p = !0, d = h > l ? g[1] : g[0], v = n.getPixelFromCoordinate(d))) : this.edge_ && (d = y ? Zy(e, s[0].feature.getGeometry()) : Jy(e, g), v = n.getPixelFromCoordinate(d), rm(t, v) <= this.pixelTolerance_ && (p = !0, this.vertex_ && !y && (u = n.getPixelFromCoordinate(g[0]), c = n.getPixelFromCoordinate(g[1]), h = im(v, u), l = im(v, c), a = Math.sqrt(Math.min(h, l)), f = a <= this.pixelTolerance_, f && (d = h > l ? g[1] : g[0], v = n.getPixelFromCoordinate(d))))), p && (v = [Math.round(v[0]), Math.round(v[1])]); } return { snapped: p, vertex: d, vertexPixel: v }; }, e.prototype.updateFeature_ = function (t) { this.removeFeature(t, !1), this.addFeature(t, !1); }, e.prototype.writeCircleGeometry_ = function (t, e) { for (let n = Oa(e), i = n.getCoordinates()[0], r = 0, o = i.length - 1; r < o; ++r) { const s = i.slice(r, r + 2); const a = { feature: t, segment: s }; this.rBush_.insert(nt(s), a); } }, e.prototype.writeGeometryCollectionGeometry_ = function (t, e) { for (let n = e.getGeometriesArray(), i = 0; i < n.length; ++i) { const r = this.SEGMENT_WRITERS_[n[i].getType()]; r && r.call(this, t, n[i]); } }, e.prototype.writeLineStringGeometry_ = function (t, e) { for (let n = e.getCoordinates(), i = 0, r = n.length - 1; i < r; ++i) { const o = n.slice(i, i + 2); const s = { feature: t, segment: o }; this.rBush_.insert(nt(o), s); } }, e.prototype.writeMultiLineStringGeometry_ = function (t, e) { for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) for (let o = n[i], s = 0, a = o.length - 1; s < a; ++s) { const u = o.slice(s, s + 2); const c = { feature: t, segment: u }; this.rBush_.insert(nt(u), c); } }, e.prototype.writeMultiPointGeometry_ = function (t, e) { for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) { const o = n[i]; const s = { feature: t, segment: [o, o] }; this.rBush_.insert(e.getExtent(), s); } }, e.prototype.writeMultiPolygonGeometry_ = function (t, e) { for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) for (let o = n[i], s = 0, a = o.length; s < a; ++s) for (let u = o[s], c = 0, h = u.length - 1; c < h; ++c) { const l = u.slice(c, c + 2); const f = { feature: t, segment: l }; this.rBush_.insert(nt(l), f); } }, e.prototype.writePointGeometry_ = function (t, e) { const n = e.getCoordinates(); const i = { feature: t, segment: [n, n] }; this.rBush_.insert(e.getExtent(), i); }, e.prototype.writePolygonGeometry_ = function (t, e) { for (let n = e.getCoordinates(), i = 0, r = n.length; i < r; ++i) for (let o = n[i], s = 0, a = o.length - 1; s < a; ++s) { const u = o.slice(s, s + 2); const c = { feature: t, segment: u }; this.rBush_.insert(nt(u), c); } }, e;
    }(E_)); function $P(t, e) { const n = om(this.pixelCoordinate_, t.segment); const i = om(this.pixelCoordinate_, e.segment); return n - i; } const GP = DP; const VP = {
      source: { type: String, required: !0 }, edge: { type: Boolean, default: !0 }, vertex: { type: Boolean, default: !0 }, pixelTolerance: { type: Number, default: 10 },
    }; const BP = {
      createInteraction: (function () { const t = Rl(Sl.a.mark(function t() { let e; let n; return Sl.a.wrap(function (t) { while (1) switch (t.prev = t.next) { case 0: return e = this.makeIdent(this.source), t.next = 3, this.$identityMap.get(e, this.$options.INSTANCE_PROMISE_POOL); case 3: return n = t.sent, t.abrupt('return', new GP({ source: n })); case 5: case 'end': return t.stop(); } }, t, this); })); return function () { return t.apply(this, arguments); }; }()), mount() { fp.methods.mount.call(this); }, unmount() { fp.methods.unmount.call(this); }, subscribeAll() {},
    }; const UP = Sf(['source'], () => function () { this.scheduleRecreate(); }); const zP = {
      name: 'vl-interaction-snap', mixins: [fp], props: VP, methods: BP, watch: UP,
    }; const YP = zP; const XP = void 0; const WP = void 0; const KP = void 0; const HP = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function qP(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'interaction.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var ZP = qP({}, XP, YP, WP, HP, KP, void 0, void 0); function JP(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; JP.installed || (JP.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(ZP, e), t.component(ZP.name, ZP)); } var QP = JP; const tL = 'http://tiles.maps.sputnik.ru/{z}/{x}/{y}.png?apikey={apikey}'; const eL = `<a href="http://maps.sputnik.ru/" target="_blank">Спутник</a> &copy; <a href="http://rt.ru/" target="_blank">Ростелеком</a>, ${(new Date()).getFullYear()}`; const nL = { url: { type: String, default: tL }, apiKey: { type: String }, attributions: { type: String, default: eL } }; const iL = { urlTokens() { return ['apiKey']; } }; const rL = {
      name: 'vl-source-sputnik', mixins: [Ug], props: nL, computed: iL,
    }; const oL = rL; const sL = void 0; const aL = void 0; const uL = void 0; const cL = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function hL(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var lL = hL({}, sL, oL, aL, cL, uL, void 0, void 0); function fL(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; fL.installed || (fL.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(lL, e), t.component(lL.name, lL)); } var pL = fL; const dL = ['Map tiles by <a href="https://stamen.com/">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.', KR]; const vL = {
      terrain: { extension: 'jpg', opaque: !0 }, 'terrain-background': { extension: 'jpg', opaque: !0 }, 'terrain-labels': { extension: 'png', opaque: !1 }, 'terrain-lines': { extension: 'png', opaque: !1 }, 'toner-background': { extension: 'png', opaque: !0 }, toner: { extension: 'png', opaque: !0 }, 'toner-hybrid': { extension: 'png', opaque: !1 }, 'toner-labels': { extension: 'png', opaque: !1 }, 'toner-lines': { extension: 'png', opaque: !1 }, 'toner-lite': { extension: 'png', opaque: !0 }, watercolor: { extension: 'jpg', opaque: !0 },
    }; const gL = { terrain: { minZoom: 4, maxZoom: 18 }, toner: { minZoom: 0, maxZoom: 20 }, watercolor: { minZoom: 1, maxZoom: 16 } }; const yL = (function (t) {
      function e(e) {
        const n = e.layer.indexOf('-'); const i = n == -1 ? e.layer : e.layer.slice(0, n); const r = gL[i]; const o = vL[e.layer]; const s = void 0 !== e.url ? e.url : `https://stamen-tiles-{a-d}.a.ssl.fastly.net/${e.layer}/{z}/{x}/{y}.${o.extension}`; t.call(this, {
          attributions: dL, cacheSize: e.cacheSize, crossOrigin: 'anonymous', maxZoom: void 0 != e.maxZoom ? e.maxZoom : r.maxZoom, minZoom: void 0 != e.minZoom ? e.minZoom : r.minZoom, opaque: o.opaque, reprojectionErrorThreshold: e.reprojectionErrorThreshold, tileLoadFunction: e.tileLoadFunction, url: s, wrapX: e.wrapX,
        });
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e;
    }($g)); const mL = yL; const _L = { layer: { type: String, required: !0 }, url: String }; const bL = {
      createSource() {
        return new mL({
          cacheSize: this.cacheSize, layer: this.layer, minZoom: this.minZoom, maxZoom: this.maxZoom, opaque: this.opaque, reprojectionErrorThreshold: this.reprojectionErrorThreshold, tileLoadFunction: this.tileLoadFunction, url: this.urlTmpl || void 0, wrapX: this.wrapX,
        });
      },
    }; const wL = {
      name: 'vl-source-stamen', mixins: [Ug], props: _L, methods: bL,
    }; const xL = wL; const EL = void 0; const SL = void 0; const TL = void 0; const OL = void 0; function CL(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var RL = CL({}, EL, xL, SL, OL, TL, void 0, void 0); function IL(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; IL.installed || (IL.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(RL, e), t.component(RL.name, RL)); } var PL = IL; const LL = {
      color: [Array, String], lineCap: { type: String, default: 'round' }, lineJoin: { type: String, default: 'round' }, lineDash: Array, lineDashOffset: { type: Number, default: 0 }, miterLimit: { type: Number, default: 10 }, width: { type: Number, default: 1.25 },
    }; const AL = {
      createStyle() {
        return new ag({
          color: this.color, lineCap: this.lineCap, lineJoin: this.lineJoin, lineDash: this.lineDash, lineDashOffset: this.lineDashOffset, miterLimit: this.miterLimit, width: this.width,
        });
      },
      mount() { this.$stylesContainer && this.$stylesContainer.setStroke(this); },
      unmount() { this.$stylesContainer && this.$stylesContainer.setStroke(void 0); },
    }; const FL = {
      color(t) { this.$style && !Object(gr.j)(t, this.$style.getColor()) && (this.$style.setColor(t), this.scheduleRefresh()); }, lineCap(t) { this.$style && !Object(gr.j)(t, this.$style.getLineCap()) && (this.$style.setLineCap(t), this.scheduleRefresh()); }, lineDash(t) { this.$style && !Object(gr.j)(t, this.$style.getLineDash()) && (this.$style.setLineDash(t), this.scheduleRefresh()); }, lineJoin(t) { this.$style && !Object(gr.j)(t, this.$style.getLineJoin()) && (this.$style.setLineJoin(t), this.scheduleRefresh()); }, width(t) { this.$style && !Object(gr.j)(t, this.$style.getWidth()) && (this.$style.setWidth(t), this.scheduleRefresh()); },
    }; const jL = {
      name: 'vl-style-stroke', mixins: [np], props: LL, watch: FL, methods: AL,
    }; const kL = jL; const ML = void 0; const NL = void 0; const DL = void 0; const $L = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function GL(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var VL = GL({}, ML, kL, NL, $L, DL, void 0, void 0); function BL(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; BL.installed || (BL.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(VL, e), t.component(VL.name, VL)); } var UL = BL; const zL = { zIndex: { type: Number, default: 0 }, condition: { type: [Function, Boolean], default: !0 } }; const YL = {
      createStyle() {
        return new dg({
          zIndex: this.zIndex, image: this._image, stroke: this._stroke, fill: this._fill, text: this._text, geometry: this._geometry,
        });
      },
      getServices() { const t = this; return xl(np.methods.getServices.call(this), { get stylesContainer() { return t; } }); },
      mount() { this.$stylesContainer && this.$stylesContainer.addStyle(this); },
      unmount() { this.$stylesContainer && this.$stylesContainer.removeStyle(this); },
      setImage(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._image && (this._image = t), this.$style && t !== this.$style.getImage() && (this.$style.setImage(t), this.scheduleRefresh()); },
      setGeometry(t) { t = t instanceof Rr.a ? t.$geometry : t, t !== this._geometry && (this._geometry = t), this.$style && t !== this.$style.getGeometry() && (this.$style.setGeometry(t), this.scheduleRefresh()); },
      setText(t) { t = t instanceof Rr.a ? t.$style : t, t !== this._text && (this._text = t), this.$style && t !== this.$style.getText() && (this.$style.setText(t), this.scheduleRefresh()); },
    }; const XL = { zIndex(t) { this.$style && !Object(gr.j)(t, this.$style.getZIndex()) && (this.$style.setZIndex(t), this.scheduleRefresh()); } }; const WL = {
      name: 'vl-style-box', mixins: [np, Kd], props: zL, methods: YL, watch: XL, created() { this._image = void 0, this._text = void 0, this._geometry = void 0; },
    }; const KL = WL; const HL = void 0; const qL = void 0; const ZL = void 0; const JL = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function QL(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var tA = QL({}, HL, KL, qL, JL, ZL, void 0, void 0); function eA(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; eA.installed || (eA.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(tA, e), t.component(tA.name, tA)); } var nA = eA; const iA = { factory: { type: Function, required: !0 } }; const rA = { styleFunc() { let t = this.factory(); return Object(gr.l)(t) || (t = gr.t), t; } }; const oA = {
      createStyle() { io(this); const t = this.styleFunc; const e = this.createStyleFunc(); return function (n, i) { const r = t(n, i); return r === null || Fo()(r) && r.length ? r : e(n, i); }; }, mount() { this.$stylesContainer && this.$stylesContainer.addStyle(this); }, unmount() { this.$stylesContainer && this.$stylesContainer.removeStyle(this); }, getServices() { const t = this; return xl(np.methods.getServices.call(this), { get stylesContainer() { return t; } }); }, setStyle(t) { t !== this._styles && (this._styles = t, this.scheduleRefresh()); }, refresh() { return this.recreate(); },
    }; const sA = { factory() { this.scheduleRefresh(); } }; const aA = {
      name: 'vl-style-func', mixins: [np, td], props: iA, computed: rA, methods: oA, watch: sA, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } },
    }; const uA = aA; const cA = void 0; const hA = void 0; const lA = void 0; const fA = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function pA(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var dA = pA({}, cA, uA, hA, fA, lA, void 0, void 0); function vA(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; vA.installed || (vA.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(dA, e), t.component(dA.name, dA)); } var gA = vA; const yA = {
      font: { type: String, default: '10px sans-serif' }, placement: String, offsetX: { type: Number, default: 0 }, offsetY: { type: Number, default: 0 }, rotateWithView: { type: Boolean, default: !1 }, rotation: { type: Number, default: 0 }, scale: { type: Number, default: 1 }, text: String, textAlign: String, textBaseline: String,
    }; const mA = {
      createStyle() {
        return new mg({
          font: this.font, placement: this.placement, offsetX: this.offsetX, offsetY: this.offsetY, rotateWithView: this.rotateWithView, rotation: this.rotation, scale: this.scale, text: this.text, textAlign: this.textAlign, textBaseline: this.textBaseline, fill: this._fill, stroke: this._stroke,
        });
      },
      mount() { this.$stylesContainer && this.$stylesContainer.setText(this); },
      unmount() { this.$stylesContainer && this.$stylesContainer.setText(void 0); },
      getServices() { const t = this; return xl(np.methods.getServices.call(this), { get stylesContainer() { return t; } }); },
    }; const _A = {
      font(t) { this.$style && !Object(gr.j)(t, this.$style.getFont()) && (this.$style.setFont(t), this.scheduleRefresh()); }, offsetX(t) { this.$style && !Object(gr.j)(t, this.$style.getOffsetX()) && (this.$style.setOffsetX(t), this.scheduleRefresh()); }, offsetY(t) { this.$style && !Object(gr.j)(t, this.$style.getOffsetY()) && (this.$style.setOffsetY(t), this.scheduleRefresh()); }, rotation(t) { this.$style && !Object(gr.j)(t, this.$style.getRotation()) && (this.$style.setRotation(t), this.scheduleRefresh()); }, scale(t) { this.$style && !Object(gr.j)(t, this.$style.getScale()) && (this.$style.setScale(t), this.scheduleRefresh()); }, text(t) { this.$style && !Object(gr.j)(t, this.$style.getText()) && (this.$style.setText(t), this.scheduleRefresh()); }, textAlign(t) { this.$style && !Object(gr.j)(t, this.$style.getTextAlign()) && (this.$style.setTextAlign(t), this.scheduleRefresh()); }, textBaseline(t) { this.$style && !Object(gr.j)(t, this.$style.getTextBaseline()) && (this.$style.setTextBaseline(t), this.scheduleRefresh()); },
    }; const bA = {
      name: 'vl-style-text', mixins: [np, Kd], props: yA, methods: mA, watch: _A, stubVNode: { empty: !1, attrs() { return { class: this.$options.name }; } },
    }; const wA = bA; const xA = void 0; const EA = void 0; const SA = void 0; const TA = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function OA(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'style.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var CA = OA({}, xA, wA, EA, TA, SA, void 0, void 0); function RA(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; RA.installed || (RA.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(CA, e), t.component(CA.name, CA)); } var IA = RA; const PA = { PRELOAD: 'preload', USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError' }; const LA = (function (t) { function e(e) { const n = e || {}; const i = qt({}, n); delete i.preload, delete i.useInterimTilesOnError, t.call(this, i), this.setPreload(void 0 !== n.preload ? n.preload : 0), this.setUseInterimTilesOnError(void 0 === n.useInterimTilesOnError || n.useInterimTilesOnError), this.type = S_.TILE; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getPreload = function () { return this.get(PA.PRELOAD); }, e.prototype.setPreload = function (t) { this.set(PA.PRELOAD, t); }, e.prototype.getUseInterimTilesOnError = function () { return this.get(PA.USE_INTERIM_TILES_ON_ERROR); }, e.prototype.setUseInterimTilesOnError = function (t) { this.set(PA.USE_INTERIM_TILES_ON_ERROR, t); }, e; }(R_)); LA.prototype.getSource; const AA = LA; const FA = { preload: { type: Number, default: 0 } }; const jA = {
      createLayer() {
        return new AA({
          id: this.id, minResolution: this.minResolution, maxResolution: this.maxResolution, opacity: this.opacity, visible: this.visible, preload: this.preload, extent: this.extent, zIndex: this.zIndex, source: this._source,
        });
      },
    }; const kA = {
      name: 'vl-layer-tile', mixins: [Ap], props: FA, methods: jA,
    }; const MA = kA; const NA = void 0; const DA = void 0; const $A = void 0; const GA = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function VA(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'layer.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var BA = VA({}, NA, MA, DA, GA, $A, void 0, void 0); function UA(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; UA.installed || (UA.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(BA, e), t.component(BA.name, BA)); } var zA = UA; const YA = ['vector', 'image']; const XA = { renderMode: { type: String, default: 'vector', validator(t) { return YA.includes(t); } } }; const WA = {
      createLayer() {
        return new A_({
          id: this.id, minResolution: this.minResolution, maxResolution: this.maxResolution, opacity: this.opacity, visible: this.visible, extent: this.extent, zIndex: this.zIndex, updateWhileAnimating: this.updateWhileAnimating, updateWhileInteracting: this.updateWhileInteracting, source: this._source, renderMode: this.renderMode, renderBuffer: this.renderBuffer, renderOrder: this.renderOrder, declutter: this.declutter,
        });
      },
    }; const KA = {
      name: 'vl-layer-vector', mixins: [Fd], props: XA, methods: WA,
    }; const HA = KA; const qA = void 0; const ZA = void 0; const JA = void 0; const QA = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function tF(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'layer.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var eF = tF({}, qA, HA, ZA, QA, JA, void 0, void 0); function nF(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; nF.installed || (nF.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(eF, e), t.component(eF.name, eF)); } var iF = nF; function rF(t) { if (Fo()(t)) return t; } const oF = n('5d73'); const sF = n.n(oF); function aF(t, e) { const n = []; let i = !0; let r = !1; let o = void 0; try { for (var s, a = sF()(t); !(i = (s = a.next()).done); i = !0) if (n.push(s.value), e && n.length === e) break; } catch (u) { r = !0, o = u; } finally { try { i || a.return == null || a.return(); } finally { if (r) throw o; } } return n; } function uF() { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } function cF(t, e) { return rF(t) || aF(t, e) || uF(); } const hF = {
      searchParams: 'URLSearchParams' in self, iterable: 'Symbol' in self && 'iterator' in Symbol, blob: 'FileReader' in self && 'Blob' in self && (function () { try { return new Blob(), !0; } catch (t) { return !1; } }()), formData: 'FormData' in self, arrayBuffer: 'ArrayBuffer' in self,
    }; function lF(t) { return t && DataView.prototype.isPrototypeOf(t); } if (hF.arrayBuffer) var fF = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]']; const pF = ArrayBuffer.isView || function (t) { return t && fF.indexOf(Object.prototype.toString.call(t)) > -1; }; function dF(t) { if (typeof t !== 'string' && (t = String(t)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t)) throw new TypeError('Invalid character in header field name'); return t.toLowerCase(); } function vF(t) { return typeof t !== 'string' && (t = String(t)), t; } function gF(t) { const e = { next() { const e = t.shift(); return { done: void 0 === e, value: e }; } }; return hF.iterable && (e[Symbol.iterator] = function () { return e; }), e; } function yF(t) { this.map = {}, t instanceof yF ? t.forEach(function (t, e) { this.append(e, t); }, this) : Array.isArray(t) ? t.forEach(function (t) { this.append(t[0], t[1]); }, this) : t && Object.getOwnPropertyNames(t).forEach(function (e) { this.append(e, t[e]); }, this); } function mF(t) { if (t.bodyUsed) return Promise.reject(new TypeError('Already read')); t.bodyUsed = !0; } function _F(t) { return new Promise(((e, n) => { t.onload = function () { e(t.result); }, t.onerror = function () { n(t.error); }; })); } function bF(t) {
      const e = new FileReader(); const
        n = _F(e); return e.readAsArrayBuffer(t), n;
    } function wF(t) {
      const e = new FileReader(); const
        n = _F(e); return e.readAsText(t), n;
    } function xF(t) { for (var e = new Uint8Array(t), n = new Array(e.length), i = 0; i < e.length; i++)n[i] = String.fromCharCode(e[i]); return n.join(''); } function EF(t) { if (t.slice) return t.slice(0); const e = new Uint8Array(t.byteLength); return e.set(new Uint8Array(t)), e.buffer; } function SF() { return this.bodyUsed = !1, this._initBody = function (t) { this._bodyInit = t, t ? typeof t === 'string' ? this._bodyText = t : hF.blob && Blob.prototype.isPrototypeOf(t) ? this._bodyBlob = t : hF.formData && FormData.prototype.isPrototypeOf(t) ? this._bodyFormData = t : hF.searchParams && URLSearchParams.prototype.isPrototypeOf(t) ? this._bodyText = t.toString() : hF.arrayBuffer && hF.blob && lF(t) ? (this._bodyArrayBuffer = EF(t.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : hF.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(t) || pF(t)) ? this._bodyArrayBuffer = EF(t) : this._bodyText = t = Object.prototype.toString.call(t) : this._bodyText = '', this.headers.get('content-type') || (typeof t === 'string' ? this.headers.set('content-type', 'text/plain;charset=UTF-8') : this._bodyBlob && this._bodyBlob.type ? this.headers.set('content-type', this._bodyBlob.type) : hF.searchParams && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')); }, hF.blob && (this.blob = function () { const t = mF(this); if (t) return t; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error('could not read FormData body as blob'); return Promise.resolve(new Blob([this._bodyText])); }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? mF(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(bF); }), this.text = function () { const t = mF(this); if (t) return t; if (this._bodyBlob) return wF(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(xF(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error('could not read FormData body as text'); return Promise.resolve(this._bodyText); }, hF.formData && (this.formData = function () { return this.text().then(RF); }), this.json = function () { return this.text().then(JSON.parse); }, this; }yF.prototype.append = function (t, e) { t = dF(t), e = vF(e); const n = this.map[t]; this.map[t] = n ? `${n}, ${e}` : e; }, yF.prototype.delete = function (t) { delete this.map[dF(t)]; }, yF.prototype.get = function (t) { return t = dF(t), this.has(t) ? this.map[t] : null; }, yF.prototype.has = function (t) { return this.map.hasOwnProperty(dF(t)); }, yF.prototype.set = function (t, e) { this.map[dF(t)] = vF(e); }, yF.prototype.forEach = function (t, e) { for (const n in this.map) this.map.hasOwnProperty(n) && t.call(e, this.map[n], n, this); }, yF.prototype.keys = function () { const t = []; return this.forEach((e, n) => { t.push(n); }), gF(t); }, yF.prototype.values = function () { const t = []; return this.forEach((e) => { t.push(e); }), gF(t); }, yF.prototype.entries = function () { const t = []; return this.forEach((e, n) => { t.push([n, e]); }), gF(t); }, hF.iterable && (yF.prototype[Symbol.iterator] = yF.prototype.entries); const TF = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']; function OF(t) { const e = t.toUpperCase(); return TF.indexOf(e) > -1 ? e : t; } function CF(t, e) { e = e || {}; let n = e.body; if (t instanceof CF) { if (t.bodyUsed) throw new TypeError('Already read'); this.url = t.url, this.credentials = t.credentials, e.headers || (this.headers = new yF(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, n || t._bodyInit == null || (n = t._bodyInit, t.bodyUsed = !0); } else this.url = String(t); if (this.credentials = e.credentials || this.credentials || 'same-origin', !e.headers && this.headers || (this.headers = new yF(e.headers)), this.method = OF(e.method || this.method || 'GET'), this.mode = e.mode || this.mode || null, this.signal = e.signal || this.signal, this.referrer = null, (this.method === 'GET' || this.method === 'HEAD') && n) throw new TypeError('Body not allowed for GET or HEAD requests'); this._initBody(n); } function RF(t) { const e = new FormData(); return t.trim().split('&').forEach((t) => { if (t) { const n = t.split('='); const i = n.shift().replace(/\+/g, ' '); const r = n.join('=').replace(/\+/g, ' '); e.append(decodeURIComponent(i), decodeURIComponent(r)); } }), e; } function IF(t) {
      const e = new yF(); const
        n = t.replace(/\r?\n[\t ]+/g, ' '); return n.split(/\r?\n/).forEach((t) => { const n = t.split(':'); const i = n.shift().trim(); if (i) { const r = n.join(':').trim(); e.append(i, r); } }), e;
    } function PF(t, e) { e || (e = {}), this.type = 'default', this.status = void 0 === e.status ? 200 : e.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = 'statusText' in e ? e.statusText : 'OK', this.headers = new yF(e.headers), this.url = e.url || '', this._initBody(t); }CF.prototype.clone = function () { return new CF(this, { body: this._bodyInit }); }, SF.call(CF.prototype), SF.call(PF.prototype), PF.prototype.clone = function () {
      return new PF(this._bodyInit, {
        status: this.status, statusText: this.statusText, headers: new yF(this.headers), url: this.url,
      });
    }, PF.error = function () { const t = new PF(null, { status: 0, statusText: '' }); return t.type = 'error', t; }; const LF = [301, 302, 303, 307, 308]; PF.redirect = function (t, e) { if (LF.indexOf(e) === -1) throw new RangeError('Invalid status code'); return new PF(null, { status: e, headers: { location: t } }); }; let AF = self.DOMException; try { new AF(); } catch (Ok) { AF = function (t, e) { this.message = t, this.name = e; const n = Error(t); this.stack = n.stack; }, AF.prototype = Object.create(Error.prototype), AF.prototype.constructor = AF; } function FF(t, e) { return new Promise(((n, i) => { const r = new CF(t, e); if (r.signal && r.signal.aborted) return i(new AF('Aborted', 'AbortError')); const o = new XMLHttpRequest(); function s() { o.abort(); }o.onload = function () { const t = { status: o.status, statusText: o.statusText, headers: IF(o.getAllResponseHeaders() || '') }; t.url = 'responseURL' in o ? o.responseURL : t.headers.get('X-Request-URL'); const e = 'response' in o ? o.response : o.responseText; n(new PF(e, t)); }, o.onerror = function () { i(new TypeError('Network request failed')); }, o.ontimeout = function () { i(new TypeError('Network request failed')); }, o.onabort = function () { i(new AF('Aborted', 'AbortError')); }, o.open(r.method, r.url, !0), r.credentials === 'include' ? o.withCredentials = !0 : r.credentials === 'omit' && (o.withCredentials = !1), 'responseType' in o && hF.blob && (o.responseType = 'blob'), r.headers.forEach((t, e) => { o.setRequestHeader(e, t); }), r.signal && (r.signal.addEventListener('abort', s), o.onreadystatechange = function () { o.readyState === 4 && r.signal.removeEventListener('abort', s); }), o.send(typeof r._bodyInit === 'undefined' ? null : r._bodyInit); })); }FF.polyfill = !0, self.fetch || (self.fetch = FF, self.Headers = yF, self.Request = CF, self.Response = PF);
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */
    const jF = {
      features: { type: Array, default: gr.z }, loaderFactory: { type: Function, default: BF }, formatFactory: { type: Function, default: VF }, url: [String, Function], strategyFactory: { type: Function, default: GF }, overlaps: { type: Boolean, default: !0 },
    }; const kF = { featureIds() { return this.features.map(Ar); } }; const MF = {
      createSource() {
        return new bm({
          attributions: this.attributions, projection: this.resolvedDataProjection, loader: this.createLoader(), useSpatialIndex: this.useSpatialIndex, wrapX: this.wrapX, logo: this.logo, strategy: this.strategyFactory.call(void 0, this), format: this.formatFactory.call(void 0, this), url: this.createUrlFunc(), overlaps: this.overlaps,
        });
      },
      createUrlFunc() { const t = this; if (this.url) { let e = this.url; return Object(gr.l)(e) || (e = Object(gr.c)(this.url)), function (n, i, r) { return e(UF(n, r, t.resolvedDataProjection), i, t.resolvedDataProjection); }; } },
      createLoader() { const t = this; if (this.url) { const e = this.loaderFactory.call(void 0, this); return (function () { const n = Rl(Sl.a.mark(function n(i, r, o) { let s; return Sl.a.wrap((n) => { while (1) switch (n.prev = n.next) { case 0: return n.next = 2, e(UF(i, o, t.resolvedDataProjection), r, t.resolvedDataProjection); case 2: s = n.sent, Fo()(s) && t.$source.addFeatures(s); case 4: case 'end': return n.stop(); } }, n, this); })); return function (t, e, i) { return n.apply(this, arguments); }; }()); } },
      mount() { Yd.methods.mount.call(this), this.addFeatures(this.features); },
      unmount() { this.clear(), Yd.methods.unmount.call(this); },
    }; const NF = function (t, e) { return t.id === e.id; }; const DF = { features(t, e) { if (this.$source) { const n = Object(gr.d)(t, e, NF); const i = Object(gr.d)(e, t, NF); this.addFeatures(n), this.removeFeatures(i); } } }; const $F = {
      name: 'vl-source-vector', mixins: [Yd], props: jF, computed: kF, methods: MF, watch: DF,
    }; function GF() { return Hd; } function VF() { return Ic(); } function BF(t) { return function (e, n, i) { let r = t.$source.getUrl(); return Object(gr.l)(r) && (r = r(e, n, i)), Object(gr.i)(r) ? [] : FF(r, { credentials: 'same-origin', mode: 'cors' }).then(t => t.text()).then(e => (t.$source ? t.$source.getFormat().readFeatures(e, { featureProjection: t.viewProjection, dataProjection: t.resolvedDataProjection }) : [])); }; } function UF(t, e, n) { if (t = t.slice(), Object(gr.k)(t[0]) && Object(gr.k)(t[1])) { const i = zn([t[0], t[1]], e, n); const r = cF(i, 2); t[0] = r[0], t[1] = r[1]; } if (Object(gr.k)(t[2]) && Object(gr.k)(t[3])) { const o = zn([t[2], t[3]], e, n); const s = cF(o, 2); t[2] = s[0], t[3] = s[1]; } return t; } const zF = $F; const YF = void 0; const XF = void 0; const WF = void 0; const KF = void 0; function HF(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var qF = HF({}, YF, zF, XF, KF, WF, void 0, void 0); function ZF(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; ZF.installed || (ZF.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(qF, e), t.component(qF.name, qF)); } var JF = ZF; const QF = (function (t) { function e(e) { const n = e || {}; let i = n.renderMode || NO.HYBRID; Q(void 0 == i || i == NO.IMAGE || i == NO.HYBRID || i == NO.VECTOR, 28), n.declutter && i == NO.IMAGE && (i = NO.HYBRID), n.renderMode = i; const r = qt({}, n); delete r.preload, delete r.useInterimTilesOnError, t.call(this, r), this.setPreload(n.preload ? n.preload : 0), this.setUseInterimTilesOnError(void 0 === n.useInterimTilesOnError || n.useInterimTilesOnError), this.type = S_.VECTOR_TILE; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getPreload = function () { return this.get(PA.PRELOAD); }, e.prototype.getUseInterimTilesOnError = function () { return this.get(PA.USE_INTERIM_TILES_ON_ERROR); }, e.prototype.setPreload = function (t) { this.set(PA.PRELOAD, t); }, e.prototype.setUseInterimTilesOnError = function (t) { this.set(PA.USE_INTERIM_TILES_ON_ERROR, t); }, e; }(A_)); QF.prototype.getSource; const tj = QF; const ej = ['vector', 'image', 'hybrid']; const nj = { renderMode: { type: String, default: 'hybrid', validator(t) { return ej.includes(t); } }, preload: { type: Number, default: 0 } }; const ij = {
      createLayer() {
        return new tj({
          id: this.id, minResolution: this.minResolution, maxResolution: this.maxResolution, opacity: this.opacity, visible: this.visible, preload: this.preload, extent: this.extent, zIndex: this.zIndex, updateWhileAnimating: this.updateWhileAnimating, updateWhileInteracting: this.updateWhileInteracting, source: this._source, renderMode: this.renderMode, renderBuffer: this.renderBuffer, renderOrder: this.renderOrder, declutter: this.declutter,
        });
      },
    }; const rj = {
      name: 'vl-layer-vector-tile', mixins: [Fd], props: nj, methods: ij,
    }; const oj = rj; const sj = void 0; const aj = void 0; const uj = void 0; const cj = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function hj(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'layer.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var lj = hj({}, sj, oj, aj, cj, uj, void 0, void 0); function fj(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; fj.installed || (fj.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(lj, e), t.component(lj.name, lj)); } var pj = fj; const dj = (function (t) {
      function e(n, i, r, o, s, a, u, c, h, l, f, p, d, v, g) { if (t.call(this, n, i, { transition: 0 }), this.context_ = {}, this.loader_, this.replayState_ = {}, this.sourceTiles_ = l, this.tileKeys = [], this.extent = null, this.sourceRevision_ = r, this.wrappedTileCoord = a, this.loadListenerKeys_ = [], this.sourceTileListenerKeys_ = [], a) { const y = this.extent = h.getTileCoordExtent(a); const m = h.getResolution(g); const _ = c.getZForResolution(m); const b = g != n[0]; let w = 0; if (c.forEachTileCoord(y, _, (t) => { let e = Lt(y, c.getTileCoordExtent(t)); const n = c.getExtent(); if (n && (e = Lt(e, n, e)), jt(e) / m >= 0.5 && Pt(e) / m >= 0.5) { ++w; const i = t.toString(); let r = l[i]; if (!r && !b) { const a = u(t, f, p); r = l[i] = new d(t, void 0 == a ? se.EMPTY : se.IDLE, void 0 == a ? '' : a, o, s), this.sourceTileListenerKeys_.push(_e(r, Ae.CHANGE, v)); }!r || b && r.getState() != se.LOADED || (r.consumers++, this.tileKeys.push(i)); } }), b && w == this.tileKeys.length && this.finishLoading_(), g <= n[0] && this.state != se.LOADED) while (g > h.getMinZoom()) { const x = new e(n, i, r, o, s, a, u, c, h, l, f, p, d, Oe, --g); if (x.state == se.LOADED) { this.interimTile = x; break; } } } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.state = se.ABORT, this.changed(), this.interimTile && this.interimTile.dispose(); for (let e = 0, n = this.tileKeys.length; e < n; ++e) { const i = this.tileKeys[e]; const r = this.getTile(i); r.consumers--, r.consumers == 0 && (delete this.sourceTiles_[i], r.dispose()); } this.tileKeys.length = 0, this.sourceTiles_ = null, this.loadListenerKeys_.forEach(xe), this.loadListenerKeys_.length = 0, this.sourceTileListenerKeys_.forEach(xe), this.sourceTileListenerKeys_.length = 0, t.prototype.disposeInternal.call(this); }, e.prototype.getContext = function (t) { const e = H(t); return e in this.context_ || (this.context_[e] = ke()), this.context_[e]; }, e.prototype.getImage = function (t) { return this.getReplayState(t).renderedTileRevision == -1 ? null : this.getContext(t).canvas; }, e.prototype.getReplayState = function (t) {
        const e = H(t); return e in this.replayState_ || (this.replayState_[e] = {
          dirty: !1, renderedRenderOrder: null, renderedRevision: -1, renderedTileRevision: -1,
        }), this.replayState_[e];
      }, e.prototype.getKey = function () { return `${this.tileKeys.join('/')}-${this.sourceRevision_}`; }, e.prototype.getTile = function (t) { return this.sourceTiles_[t]; }, e.prototype.load = function () { let t = 0; const e = {}; this.state == se.IDLE && this.setState(se.LOADING), this.state == se.LOADING && this.tileKeys.forEach((n) => { const i = this.getTile(n); if (i.state == se.IDLE && (i.setLoader(this.loader_), i.load()), i.state == se.LOADING) { const r = _e(i, Ae.CHANGE, (n) => { const r = i.getState(); if (r == se.LOADED || r == se.ERROR) { const o = H(i); r == se.ERROR ? e[o] = !0 : (--t, delete e[o]), t - Object.keys(e).length == 0 && this.finishLoading_(); } }); this.loadListenerKeys_.push(r), ++t; } }), t - Object.keys(e).length == 0 && setTimeout(this.finishLoading_.bind(this), 0); }, e.prototype.finishLoading_ = function () { for (var t = this.tileKeys.length, e = 0, n = t - 1; n >= 0; --n) { const i = this.getTile(this.tileKeys[n]).getState(); i != se.LOADED && --t, i == se.EMPTY && ++e; }t == this.tileKeys.length ? (this.loadListenerKeys_.forEach(xe), this.loadListenerKeys_.length = 0, this.setState(se.LOADED)) : this.setState(e == this.tileKeys.length ? se.EMPTY : se.ERROR); }, e;
    }(je)); const vj = dj; function gj(t, e) { const n = lm(e, t.getFormat(), t.onLoad.bind(t), t.onError.bind(t)); t.setLoader(n); } const yj = [0, 0, 4096, 4096]; const mj = (function (t) { function e(e, n, i, r, o, s) { t.call(this, e, n, s), this.consumers = 0, this.extent_ = null, this.format_ = r, this.features_ = null, this.loader_, this.projection_ = null, this.replayGroups_ = {}, this.tileLoadFunction_ = o, this.url_ = i; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.disposeInternal = function () { this.features_ = null, this.replayGroups_ = {}, this.state = se.ABORT, this.changed(), t.prototype.disposeInternal.call(this); }, e.prototype.getExtent = function () { return this.extent_ || yj; }, e.prototype.getFormat = function () { return this.format_; }, e.prototype.getFeatures = function () { return this.features_; }, e.prototype.getKey = function () { return this.url_; }, e.prototype.getProjection = function () { return this.projection_; }, e.prototype.getReplayGroup = function (t, e) { return this.replayGroups_[`${H(t)},${e}`]; }, e.prototype.load = function () { this.state == se.IDLE && (this.setState(se.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_(null, NaN, null)); }, e.prototype.onLoad = function (t, e, n) { this.setProjection(e), this.setFeatures(t), this.setExtent(n); }, e.prototype.onError = function () { this.setState(se.ERROR); }, e.prototype.setExtent = function (t) { this.extent_ = t; }, e.prototype.setFeatures = function (t) { this.features_ = t, this.setState(se.LOADED); }, e.prototype.setProjection = function (t) { this.projection_ = t; }, e.prototype.setReplayGroup = function (t, e, n) { this.replayGroups_[`${H(t)},${e}`] = n; }, e.prototype.setLoader = function (t) { this.loader_ = t; }, e; }(je)); const _j = mj; const bj = (function (t) {
      function e(e) {
        const n = e.projection || 'EPSG:3857'; const i = e.extent || Ui(n); const r = e.tileGrid || Gi({
          extent: i, maxZoom: e.maxZoom || 22, minZoom: e.minZoom, tileSize: e.tileSize || 512,
        }); t.call(this, {
          attributions: e.attributions, cacheSize: void 0 !== e.cacheSize ? e.cacheSize : 128, opaque: !1, projection: n, state: e.state, tileGrid: r, tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : gj, tileUrlFunction: e.tileUrlFunction, url: e.url, urls: e.urls, wrapX: void 0 === e.wrapX || e.wrapX, transition: e.transition,
        }), this.format_ = e.format ? e.format : null, this.sourceTiles_ = {}, this.overlaps_ = void 0 == e.overlaps || e.overlaps, this.tileClass = e.tileClass ? e.tileClass : _j, this.tileGrids_ = {};
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getOverlaps = function () { return this.overlaps_; }, e.prototype.clear = function () { this.tileCache.clear(), this.sourceTiles_ = {}; }, e.prototype.getTile = function (t, e, n, i, r) { const o = We(t, e, n); if (this.tileCache.containsKey(o)) return this.tileCache.get(o); const s = [t, e, n]; const a = this.getTileCoordForTileUrlFunction(s, r); const u = new vj(s, a !== null ? se.IDLE : se.EMPTY, this.getRevision(), this.format_, this.tileLoadFunction, a, this.tileUrlFunction, this.tileGrid, this.getTileGridForProjection(r), this.sourceTiles_, i, r, this.tileClass, this.handleTileChange.bind(this), s[0]); return this.tileCache.set(o, u), u; }, e.prototype.getTileGridForProjection = function (t) { const e = t.getCode(); let n = this.tileGrids_[e]; if (!n) { const i = this.tileGrid; n = this.tileGrids_[e] = Bi(t, void 0, i ? i.getTileSize(i.getMinZoom()) : void 0); } return n; }, e.prototype.getTilePixelRatio = function (t) { return t; }, e.prototype.getTilePixelSize = function (t, e, n) { const i = this.getTileGridForProjection(n); const r = ie(i.getTileSize(t), this.tmpSize); return [Math.round(r[0] * e), Math.round(r[1] * e)]; }, e;
    }(Hi)); const wj = bj; const xj = { cacheSize: { type: Number, default: 128 }, formatFactory: { type: Function, default: Tj }, overlaps: { type: Boolean, default: !0 } }; const Ej = {
      createSource() {
        return new wj({
          attributions: this.attributions, cacheSize: this.cacheSize, format: this.formatFactory(), logo: this.logo, overlaps: this.overlaps, projection: this.projection, tileGrid: this._tileGrid, tileLoadFunction: this.tileLoadFunction, tileUrlFunction: this.createUrlFunc(), wrapX: this.wrapX, transition: this.transition,
        });
      },
    }; const Sj = {
      name: 'vl-source-vector-tile', mixins: [Id], props: xj, methods: Ej,
    }; function Tj() { return Pc(); } const Oj = Sj; const Cj = void 0; const Rj = void 0; const Ij = void 0; const Pj = void 0; function Lj(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Aj = Lj({}, Cj, Oj, Rj, Pj, Ij, void 0, void 0); function Fj(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Fj.installed || (Fj.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Aj, e), t.component(Aj.name, Aj)); } var jj = Fj; const kj = (function (t) {
      function e(e) {
        const n = e || {}; const i = n.params || {}; const r = !('TRANSPARENT' in i) || i.TRANSPARENT; t.call(this, {
          attributions: n.attributions, cacheSize: n.cacheSize, crossOrigin: n.crossOrigin, opaque: !r, projection: n.projection, reprojectionErrorThreshold: n.reprojectionErrorThreshold, tileClass: n.tileClass, tileGrid: n.tileGrid, tileLoadFunction: n.tileLoadFunction, tileUrlFunction: Mj, url: n.url, urls: n.urls, wrapX: void 0 === n.wrapX || n.wrapX, transition: n.transition,
        }), this.gutter_ = void 0 !== n.gutter ? n.gutter : 0, this.params_ = i, this.v13_ = !0, this.serverType_ = n.serverType, this.hidpi_ = void 0 === n.hidpi || n.hidpi, this.tmpExtent_ = lt(), this.updateV13_(), this.setKey(this.getKeyForParams_());
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getGetFeatureInfoUrl = function (t, e, n, i) {
        const r = jn(n); const o = this.getProjection(); let s = this.getTileGrid(); s || (s = this.getTileGridForProjection(r)); const a = s.getTileCoordForCoordAndResolution(t, e); if (!(s.getResolutions().length <= a[0])) {
          let u = s.getResolution(a[0]); let c = s.getTileCoordExtent(a, this.tmpExtent_); let h = ie(s.getTileSize(a[0]), this.tmpSize); const l = this.gutter_; l !== 0 && (h = te(h, l, this.tmpSize), c = rt(c, u * l, c)), o && o !== r && (u = Wn(o, r, t, u), c = Yn(c, r, o), t = zn(t, r, o)); const f = {
            SERVICE: 'WMS', VERSION: jx, REQUEST: 'GetFeatureInfo', FORMAT: 'image/png', TRANSPARENT: !0, QUERY_LAYERS: this.params_.LAYERS,
          }; qt(f, this.params_, i); const p = Math.floor((t[0] - c[0]) / u); const d = Math.floor((c[3] - t[1]) / u); return f[this.v13_ ? 'I' : 'X'] = p, f[this.v13_ ? 'J' : 'Y'] = d, this.getRequestUrl_(a, h, c, 1, o || r, f);
        }
      }, e.prototype.getGutter = function () { return this.gutter_; }, e.prototype.getParams = function () { return this.params_; }, e.prototype.getRequestUrl_ = function (t, e, n, i, r, o) { const s = this.urls; if (s) { if (o.WIDTH = e[0], o.HEIGHT = e[1], o[this.v13_ ? 'CRS' : 'SRS'] = r.getCode(), 'STYLES' in this.params_ || (o.STYLES = ''), i != 1) switch (this.serverType_) { case kx.GEOSERVER: var a = 90 * i + 0.5 | 0; 'FORMAT_OPTIONS' in o ? o.FORMAT_OPTIONS += `;dpi:${a}` : o.FORMAT_OPTIONS = `dpi:${a}`; break; case kx.MAPSERVER: o.MAP_RESOLUTION = 90 * i; break; case kx.CARMENTA_SERVER: case kx.QGIS: o.DPI = 90 * i; break; default: Q(!1, 52); break; } let u; let c; const h = r.getAxisOrientation(); const l = n; if (this.v13_ && h.substr(0, 2) == 'ne')u = n[0], l[0] = n[1], l[1] = u, u = n[2], l[2] = n[3], l[3] = u; if (o.BBOX = l.join(','), s.length == 1)c = s[0]; else { const f = Kt(qe(t), s.length); c = s[f]; } return Qi(c, o); } }, e.prototype.getTilePixelRatio = function (t) { return this.hidpi_ && void 0 !== this.serverType_ ? t : 1; }, e.prototype.getKeyForParams_ = function () { let t = 0; const e = []; for (const n in this.params_)e[t++] = `${n}-${this.params_[n]}`; return e.join('/'); }, e.prototype.updateParams = function (t) { qt(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_()); }, e.prototype.updateV13_ = function () { const t = this.params_.VERSION || jx; this.v13_ = Hy(t, '1.3') >= 0; }, e;
    }(Ji)); function Mj(t, e, n) {
      let i = this.getTileGrid(); if (i || (i = this.getTileGridForProjection(n)), !(i.getResolutions().length <= t[0])) {
        e == 1 || this.hidpi_ && void 0 !== this.serverType_ || (e = 1); const r = i.getResolution(t[0]); let o = i.getTileCoordExtent(t, this.tmpExtent_); let s = ie(i.getTileSize(t[0]), this.tmpSize); const a = this.gutter_; a !== 0 && (s = te(s, a, this.tmpSize), o = rt(o, r * a, o)), e != 1 && (s = ne(s, e, this.tmpSize)); const u = {
          SERVICE: 'WMS', VERSION: jx, REQUEST: 'GetMap', FORMAT: 'image/png', TRANSPARENT: !0,
        }; return qt(u, this.params_), this.getRequestUrl_(t, s, o, e, n, u);
      }
    } const Nj = kj; const Dj = {
      gutter: Number, hidpi: { type: Boolean, default: !0 }, serverType: { type: String, validator(t) { return !t | Gm()(kx).includes(t); } }, url: { type: String, required: !0, validator(t) { return !!t.length; } },
    }; const $j = {
      createSource() {
        return new Nj({
          attributions: this.attributions, cacheSize: this.cacheSize, params: this.allParams, crossOrigin: this.crossOrigin, gutter: this.gutter, hidpi: this.hidpi, logo: this.logo, tileGrid: this._tileGrid, projection: this.projection, reprojectionErrorThreshold: this.reprojectionErrorThreshold, serverType: this.serverType, wrapX: this.wrapX, url: this.urlTmpl, transition: this.transition, tileLoadFunction: this.tileLoadFunction,
        });
      },
    }; const Gj = {
      name: 'vl-source-wms', mixins: [Id, Ng], props: Dj, methods: $j,
    }; const Vj = Gj; const Bj = void 0; const Uj = void 0; const zj = void 0; const Yj = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Xj(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var Wj = Xj({}, Bj, Vj, Uj, Yj, zj, void 0, void 0); function Kj(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Kj.installed || (Kj.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(Wj, e), t.component(Wj.name, Wj)); } var Hj = Kj; const qj = { KVP: 'KVP', REST: 'REST' }; const Zj = (function (t) {
      function e(e) {
        t.call(this, {
          extent: e.extent, origin: e.origin, origins: e.origins, resolutions: e.resolutions, tileSize: e.tileSize, tileSizes: e.tileSizes, sizes: e.sizes,
        }), this.matrixIds_ = e.matrixIds;
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getMatrixId = function (t) { return this.matrixIds_[t]; }, e.prototype.getMatrixIds = function () { return this.matrixIds_; }, e;
    }(Mi)); const Jj = Zj; const Qj = (function (t) {
      function e(e) {
        const n = void 0 !== e.requestEncoding ? e.requestEncoding : qj.KVP; const i = e.tileGrid; let r = e.urls; void 0 === r && void 0 !== e.url && (r = si(e.url)), t.call(this, {
          attributions: e.attributions, cacheSize: e.cacheSize, crossOrigin: e.crossOrigin, projection: e.projection, reprojectionErrorThreshold: e.reprojectionErrorThreshold, tileClass: e.tileClass, tileGrid: i, tileLoadFunction: e.tileLoadFunction, tilePixelRatio: e.tilePixelRatio, tileUrlFunction: oi, urls: r, wrapX: void 0 !== e.wrapX && e.wrapX, transition: e.transition,
        }), this.version_ = void 0 !== e.version ? e.version : '1.0.0', this.format_ = void 0 !== e.format ? e.format : 'image/jpeg', this.dimensions_ = void 0 !== e.dimensions ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = n, this.setKey(this.getKeyForDimensions_()), r && r.length > 0 && (this.tileUrlFunction = ri(r.map(ek.bind(this))));
      } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setUrls = function (t) { this.urls = t; const e = t.join('\n'); this.setTileUrlFunction(ri(t.map(ek.bind(this))), e); }, e.prototype.getDimensions = function () { return this.dimensions_; }, e.prototype.getFormat = function () { return this.format_; }, e.prototype.getLayer = function () { return this.layer_; }, e.prototype.getMatrixSet = function () { return this.matrixSet_; }, e.prototype.getRequestEncoding = function () { return this.requestEncoding_; }, e.prototype.getStyle = function () { return this.style_; }, e.prototype.getVersion = function () { return this.version_; }, e.prototype.getKeyForDimensions_ = function () { let t = 0; const e = []; for (const n in this.dimensions_)e[t++] = `${n}-${this.dimensions_[n]}`; return e.join('/'); }, e.prototype.updateDimensions = function (t) { qt(this.dimensions_, t), this.setKey(this.getKeyForDimensions_()); }, e;
    }(Ji)); const tk = Qj; function ek(t) {
      const e = this.requestEncoding_; const n = { layer: this.layer_, style: this.style_, tilematrixset: this.matrixSet_ }; e == qj.KVP && qt(n, {
        Service: 'WMTS', Request: 'GetTile', Version: this.version_, Format: this.format_,
      }), t = e == qj.KVP ? Qi(t, n) : t.replace(/\{(\w+?)\}/g, (t, e) => (e.toLowerCase() in n ? n[e.toLowerCase()] : t)); const i = this.tileGrid; const r = this.dimensions_; return function (n, o, s) { if (n) { const a = { TileMatrix: i.getMatrixId(n[0]), TileCol: n[1], TileRow: -n[2] - 1 }; qt(a, r); let u = t; return u = e == qj.KVP ? Qi(u, a) : u.replace(/\{(\w+?)\}/g, (t, e) => a[e]), u; } };
    }
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */const nk = {
      dimensions: Object, format: { type: String, default: Lo }, layerName: { type: String, required: !0 }, matrixSet: { type: String, required: !0 }, requestEncoding: { type: String, default: Po }, styleName: { type: String, required: !0 }, version: { type: String, default: Io }, url: { type: String, required: !0 },
    }; const ik = {
      createSource() {
        return new tk({
          attributions: this.attributions, cacheSize: this.cacheSize, crossOrigin: this.crossOrigin, dimensions: this.dimensions, format: this.format, layer: this.layerName, logo: this.logo, matrixSet: this.matrixSet, projection: this.projection, reprojectionErrorThreshold: this.reprojectionErrorThreshold, requestEncoding: this.requestEncoding, tileGrid: this._tileGrid, tilePixelRatio: this.tilePixelRatio, style: this.styleName, version: this.version, url: this.urlTmpl, wrapX: this.wrapX, transition: this.transition, tileLoadFunction: this.tileLoadFunction,
        });
      },
      createTileGrid() {
        ro(this); const t = Wh(this.$view.getProjection()); const e = wd(t, this.maxZoom, this.tileSize); return new Jj({
          extent: t, resolutions: e, tileSize: this.tileSize, minZoom: this.minZoom, matrixIds: qh()(Object(gr.w)(this.minZoom, e.length)),
        });
      },
    }; const rk = {
      name: 'vl-source-wmts', mixins: [Id], props: nk, methods: ik,
    }; const ok = rk; const sk = void 0; const ak = void 0; const uk = void 0; const ck = void 0; function hk(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var lk = hk({}, sk, ok, ak, ck, uk, void 0, void 0); function fk(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; fk.installed || (fk.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(lk, e), t.component(lk.name, lk)); } var pk = fk; const dk = {}; const vk = { name: 'vl-source-xyz', mixins: [Ug], props: dk }; const gk = vk; const yk = void 0; const mk = void 0; const _k = void 0; const bk = void 0;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function wk(t, e, n, i, r, o, s, a) { const u = (typeof n === 'function' ? n.options : n) || {}; return u.__file = 'source.vue', u.render || (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, r && (u.functional = !0)), u._scopeId = i, u; } var xk = wk({}, yk, gk, mk, bk, _k, void 0, void 0); function Ek(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Ek.installed || (Ek.installed = !0, e = Object(gr.u)(e, 'dataProjection'), Zd()(xk, e), t.component(xk.name, xk)); } var Sk = Ek;
    /**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.1
 * @license MIT
 * @copyright (c) 2017-2018, Vladimir Vershinin <ghettovoice@gmail.com>
 */function Tk(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Tk.installed || (Tk.installed = !0, t.use(r, e), t.use(o, e), t.use(s, e), t.use(a, e), t.use(u, e), t.use(c, e), t.use(h, e), t.use(l, e), t.use(f, e), t.use(p, e), t.use(d, e), t.use(v, e), t.use(g, e), t.use(y, e), t.use(m, e), t.use(_, e), t.use(b, e), t.use(w, e), t.use(x, e), t.use(E, e), t.use(S, e), t.use(T, e), t.use(O, e), t.use(C, e), t.use(R, e), t.use(I, e), t.use(P, e), t.use(L, e), t.use(A, e), t.use(F, e), t.use(j, e), t.use(k, e), t.use(M, e), t.use(N, e), t.use(D, e), t.use($, e), t.use(G, e), t.use(V, e), t.use(B, e), t.use(U, e), t.use(z, e), t.use(Y, e), t.use(X, e)); }e.a = Tk;
  },
  '1d2b': function (t, e, n) {
    t.exports = function (t, e) { return function () { for (var n = new Array(arguments.length), i = 0; i < n.length; i++)n[i] = arguments[i]; return t.apply(e, n); }; };
  },
  '1df8': function (t, e, n) { const i = n('63b6'); i(i.S, 'Object', { setPrototypeOf: n('ead6').set }); },
  '1ec9': function (t, e, n) { const i = n('f772'); const r = n('e53d').document; const o = i(r) && i(r.createElement); t.exports = function (t) { return o ? r.createElement(t) : {}; }; },
  '1fa8': function (t, e, n) { const i = n('cb7c'); t.exports = function (t, e, n, r) { try { return r ? e(i(n)[0], n[1]) : e(n); } catch (s) { const o = t.return; throw void 0 !== o && i(o.call(t)), s; } }; },
  2074(t, e, n) {},
  '20fd': function (t, e, n) {
    const i = n('d9f6'); const r = n('aebd'); t.exports = function (t, e, n) { e in t ? i.f(t, e, r(0, n)) : t[e] = n; };
  },
  '230e': function (t, e, n) { const i = n('d3f4'); const r = n('7726').document; const o = i(r) && i(r.createElement); t.exports = function (t) { return o ? r.createElement(t) : {}; }; },
  2366(t, e) { for (var n = [], i = 0; i < 256; ++i)n[i] = (i + 256).toString(16).substr(1); function r(t, e) { let i = e || 0; const r = n; return [r[t[i++]], r[t[i++]], r[t[i++]], r[t[i++]], '-', r[t[i++]], r[t[i++]], '-', r[t[i++]], r[t[i++]], '-', r[t[i++]], r[t[i++]], '-', r[t[i++]], r[t[i++]], r[t[i++]], r[t[i++]], r[t[i++]], r[t[i++]]].join(''); }t.exports = r; },
  '23bf': function (t, e, n) {
    const i = n('2b0e'); e.a = i.a.extend({
      name: 'measurable',
      props: {
        height: [Number, String], maxHeight: [Number, String], maxWidth: [Number, String], width: [Number, String],
      },
    });
  },
  '23c6': function (t, e, n) { const i = n('2d95'); const r = n('2b4c')('toStringTag'); const o = i(function () { return arguments; }()) == 'Arguments'; const s = function (t, e) { try { return t[e]; } catch (n) {} }; t.exports = function (t) { let e; let n; let a; return void 0 === t ? 'Undefined' : t === null ? 'Null' : typeof (n = s(e = Object(t), r)) === 'string' ? n : o ? i(e) : (a = i(e)) == 'Object' && typeof e.callee === 'function' ? 'Arguments' : a; }; },
  '241e': function (t, e, n) { const i = n('25eb'); t.exports = function (t) { return Object(i(t)); }; },
  2444(t, e, n) {
    (function (e) {
      const i = n('c532'); const r = n('c8af'); const o = { 'Content-Type': 'application/x-www-form-urlencoded' }; function s(t, e) { !i.isUndefined(t) && i.isUndefined(t['Content-Type']) && (t['Content-Type'] = e); } function a() { let t; return typeof XMLHttpRequest !== 'undefined' ? t = n('b50d') : typeof e !== 'undefined' && (t = n('b50d')), t; } const u = {
        adapter: a(), transformRequest: [function (t, e) { return r(e, 'Content-Type'), i.isFormData(t) || i.isArrayBuffer(t) || i.isBuffer(t) || i.isStream(t) || i.isFile(t) || i.isBlob(t) ? t : i.isArrayBufferView(t) ? t.buffer : i.isURLSearchParams(t) ? (s(e, 'application/x-www-form-urlencoded;charset=utf-8'), t.toString()) : i.isObject(t) ? (s(e, 'application/json;charset=utf-8'), JSON.stringify(t)) : t; }], transformResponse: [function (t) { if (typeof t === 'string') try { t = JSON.parse(t); } catch (e) {} return t; }], timeout: 0, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, validateStatus(t) { return t >= 200 && t < 300; }, headers: { common: { Accept: 'application/json, text/plain, */*' } },
      }; i.forEach(['delete', 'get', 'head'], (t) => { u.headers[t] = {}; }), i.forEach(['post', 'put', 'patch'], (t) => { u.headers[t] = i.merge(o); }), t.exports = u;
    }).call(this, n('4362'));
  },
  '24c5': function (t, e, n) {
    let i; let r; let o; let s; const a = n('b8e3'); const u = n('e53d'); const c = n('d864'); const h = n('40c3'); const l = n('63b6'); const f = n('f772'); const p = n('79aa'); const d = n('1173'); const v = n('a22a'); const g = n('f201'); const y = n('4178').set; const m = n('aba2')(); const _ = n('656e'); const b = n('4439'); const w = n('bc13'); const x = n('cd78'); const E = 'Promise'; const S = u.TypeError; const T = u.process; const O = T && T.versions; const C = O && O.v8 || ''; let R = u[E]; const I = h(T) == 'process'; const P = function () {}; let L = r = _.f; const A = !!(function () { try { const t = R.resolve(1); const e = (t.constructor = {})[n('5168')('species')] = function (t) { t(P, P); }; return (I || typeof PromiseRejectionEvent === 'function') && t.then(P) instanceof e && C.indexOf('6.6') !== 0 && w.indexOf('Chrome/66') === -1; } catch (i) {} }()); const F = function (t) { let e; return !(!f(t) || typeof (e = t.then) !== 'function') && e; }; const j = function (t, e) { if (!t._n) { t._n = !0; const n = t._c; m(() => { const i = t._v; const r = t._s == 1; let o = 0; const s = function (e) { let n; let o; let s; const a = r ? e.ok : e.fail; const u = e.resolve; const c = e.reject; const h = e.domain; try { a ? (r || (t._h == 2 && N(t), t._h = 1), !0 === a ? n = i : (h && h.enter(), n = a(i), h && (h.exit(), s = !0)), n === e.promise ? c(S('Promise-chain cycle')) : (o = F(n)) ? o.call(n, u, c) : u(n)) : c(i); } catch (l) { h && !s && h.exit(), c(l); } }; while (n.length > o)s(n[o++]); t._c = [], t._n = !1, e && !t._h && k(t); }); } }; var k = function (t) { y.call(u, () => { let e; let n; let i; const r = t._v; const o = M(t); if (o && (e = b(() => { I ? T.emit('unhandledRejection', r, t) : (n = u.onunhandledrejection) ? n({ promise: t, reason: r }) : (i = u.console) && i.error && i.error('Unhandled promise rejection', r); }), t._h = I || M(t) ? 2 : 1), t._a = void 0, o && e.e) throw e.v; }); }; var M = function (t) { return t._h !== 1 && (t._a || t._c).length === 0; }; var N = function (t) { y.call(u, () => { let e; I ? T.emit('rejectionHandled', t) : (e = u.onrejectionhandled) && e({ promise: t, reason: t._v }); }); }; const D = function (t) { let e = this; e._d || (e._d = !0, e = e._w || e, e._v = t, e._s = 2, e._a || (e._a = e._c.slice()), j(e, !0)); }; var $ = function (t) { let e; let n = this; if (!n._d) { n._d = !0, n = n._w || n; try { if (n === t) throw S("Promise can't be resolved itself"); (e = F(t)) ? m(() => { const i = { _w: n, _d: !1 }; try { e.call(t, c($, i, 1), c(D, i, 1)); } catch (r) { D.call(i, r); } }) : (n._v = t, n._s = 1, j(n, !1)); } catch (i) { D.call({ _w: n, _d: !1 }, i); } } }; A || (R = function (t) { d(this, R, E, '_h'), p(t), i.call(this); try { t(c($, this, 1), c(D, this, 1)); } catch (e) { D.call(this, e); } }, i = function (t) { this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1; }, i.prototype = n('5c95')(R.prototype, { then(t, e) { const n = L(g(this, R)); return n.ok = typeof t !== 'function' || t, n.fail = typeof e === 'function' && e, n.domain = I ? T.domain : void 0, this._c.push(n), this._a && this._a.push(n), this._s && j(this, !1), n.promise; }, catch(t) { return this.then(void 0, t); } }), o = function () { const t = new i(); this.promise = t, this.resolve = c($, t, 1), this.reject = c(D, t, 1); }, _.f = L = function (t) { return t === R || t === s ? new o(t) : r(t); }), l(l.G + l.W + l.F * !A, { Promise: R }), n('45f2')(R, E), n('4c95')(E), s = n('584a')[E], l(l.S + l.F * !A, E, { reject(t) { const e = L(this); const n = e.reject; return n(t), e.promise; } }), l(l.S + l.F * (a || !A), E, { resolve(t) { return x(a && this === s ? R : this, t); } }), l(l.S + l.F * !(A && n('4ee1')((t) => { R.all(t).catch(P); })), E, { all(t) { const e = this; const n = L(e); const i = n.resolve; const r = n.reject; const o = b(() => { const n = []; let o = 0; let s = 1; v(t, !1, (t) => { const a = o++; let u = !1; n.push(void 0), s++, e.resolve(t).then((t) => { u || (u = !0, n[a] = t, --s || i(n)); }, r); }), --s || i(n); }); return o.e && r(o.v), n.promise; }, race(t) { const e = this; const n = L(e); const i = n.reject; const r = b(() => { v(t, !1, (t) => { e.resolve(t).then(n.resolve, i); }); }); return r.e && i(r.v), n.promise; } });
  },
  '253d': function (t, e, n) {},
  '25b0': function (t, e, n) { n('1df8'), t.exports = n('584a').Object.setPrototypeOf; },
  '25eb': function (t, e) { t.exports = function (t) { if (void 0 == t) throw TypeError(`Can't call method on  ${t}`); return t; }; },
  '268f': function (t, e, n) { t.exports = n('fde4'); },
  '27ee': function (t, e, n) { const i = n('23c6'); const r = n('2b4c')('iterator'); const o = n('84f2'); t.exports = n('8378').getIteratorMethod = function (t) { if (void 0 != t) return t[r] || t['@@iterator'] || o[i(t)]; }; },
  2877(t, e, n) {
    function i(t, e, n, i, r, o, s, a) { let u; const c = typeof t === 'function' ? t.options : t; if (e && (c.render = e, c.staticRenderFns = n, c._compiled = !0), i && (c.functional = !0), o && (c._scopeId = `data-v-${o}`), s ? (u = function (t) { t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, t || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (t = __VUE_SSR_CONTEXT__), r && r.call(this, t), t && t._registeredComponents && t._registeredComponents.add(s); }, c._ssrRegister = u) : r && (u = a ? function () { r.call(this, this.$root.$options.shadowRoot); } : r), u) if (c.functional) { c._injectStyles = u; const h = c.render; c.render = function (t, e) { return u.call(e), h(t, e); }; } else { const l = c.beforeCreate; c.beforeCreate = l ? [].concat(l, u) : [u]; } return { exports: t, options: c }; }n.d(e, 'a', () => i);
  },
  '294c': function (t, e) { t.exports = function (t) { try { return !!t(); } catch (e) { return !0; } }; },
  '2a7f': function (t, e, n) {
    const i = n('80d2'); const r = n('71d9'); const o = n('8336'); const s = o.a; const a = n('132d'); const u = a.a; const c = { name: 'v-toolbar-side-icon', functional: !0, render(t, e) { const n = e.slots; const i = e.listeners; const r = e.props; const o = e.data; const a = o.staticClass ? `${o.staticClass} v-toolbar__side-icon` : 'v-toolbar__side-icon'; const c = Object.assign(o, { staticClass: a, props: Object.assign(r, { icon: !0 }), on: i }); const h = n().default; return t(s, c, h || [t(u, '$vuetify.icons.menu')]); } }; n.d(e, 'a', () => h); var h = Object(i.b)('v-toolbar__title'); const l = Object(i.b)('v-toolbar__items'); r.a;
  },
  '2aba': function (t, e, n) { const i = n('7726'); const r = n('32e9'); const o = n('69a8'); const s = n('ca5a')('src'); const a = 'toString'; const u = Function[a]; const c = (`${u}`).split(a); n('8378').inspectSource = function (t) { return u.call(t); }, (t.exports = function (t, e, n, a) { const u = typeof n === 'function'; u && (o(n, 'name') || r(n, 'name', e)), t[e] !== n && (u && (o(n, s) || r(n, s, t[e] ? `${t[e]}` : c.join(String(e)))), t === i ? t[e] = n : a ? t[e] ? t[e] = n : r(t, e, n) : (delete t[e], r(t, e, n))); })(Function.prototype, a, function () { return typeof this === 'function' && this[s] || u.call(this); }); },
  '2aeb': function (t, e, n) { const i = n('cb7c'); const r = n('1495'); const o = n('e11e'); const s = n('613b')('IE_PROTO'); const a = function () {}; const u = 'prototype'; var c = function () { let t; const e = n('230e')('iframe'); let i = o.length; const r = '<'; const s = '>'; e.style.display = 'none', n('fab2').appendChild(e), e.src = 'javascript:', t = e.contentWindow.document, t.open(), t.write(`${r}script${s}document.F=Object${r}/script${s}`), t.close(), c = t.F; while (i--) delete c[u][o[i]]; return c(); }; t.exports = Object.create || function (t, e) { let n; return t !== null ? (a[u] = i(t), n = new a(), a[u] = null, n[s] = t) : n = c(), void 0 === e ? n : r(n, e); }; },
  '2b0e': function (t, e, n) {
    (function (t) {
    /*!
 * Vue.js v2.5.17
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
      const n = Object.freeze({}); function i(t) { return void 0 === t || t === null; } function r(t) { return void 0 !== t && t !== null; } function o(t) { return !0 === t; } function s(t) { return !1 === t; } function a(t) { return typeof t === 'string' || typeof t === 'number' || typeof t === 'symbol' || typeof t === 'boolean'; } function u(t) { return t !== null && typeof t === 'object'; } const c = Object.prototype.toString; function h(t) { return c.call(t) === '[object Object]'; } function l(t) { return c.call(t) === '[object RegExp]'; } function f(t) { const e = parseFloat(String(t)); return e >= 0 && Math.floor(e) === e && isFinite(t); } function p(t) { return t == null ? '' : typeof t === 'object' ? JSON.stringify(t, null, 2) : String(t); } function d(t) { const e = parseFloat(t); return isNaN(e) ? t : e; } function v(t, e) { for (var n = Object.create(null), i = t.split(','), r = 0; r < i.length; r++)n[i[r]] = !0; return e ? function (t) { return n[t.toLowerCase()]; } : function (t) { return n[t]; }; }v('slot,component', !0); const g = v('key,ref,slot,slot-scope,is'); function y(t, e) { if (t.length) { const n = t.indexOf(e); if (n > -1) return t.splice(n, 1); } } const m = Object.prototype.hasOwnProperty; function _(t, e) { return m.call(t, e); } function b(t) { const e = Object.create(null); return function (n) { const i = e[n]; return i || (e[n] = t(n)); }; } const w = /-(\w)/g; const x = b(t => t.replace(w, (t, e) => (e ? e.toUpperCase() : ''))); const E = b(t => t.charAt(0).toUpperCase() + t.slice(1)); const S = /\B([A-Z])/g; const T = b(t => t.replace(S, '-$1').toLowerCase()); function O(t, e) { function n(n) { const i = arguments.length; return i ? i > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e); } return n._length = t.length, n; } function C(t, e) { return t.bind(e); } const R = Function.prototype.bind ? C : O; function I(t, e) { e = e || 0; let n = t.length - e; const i = new Array(n); while (n--)i[n] = t[n + e]; return i; } function P(t, e) { for (const n in e)t[n] = e[n]; return t; } function L(t) { for (var e = {}, n = 0; n < t.length; n++)t[n] && P(e, t[n]); return e; } function A(t, e, n) {} const F = function (t, e, n) { return !1; }; const j = function (t) { return t; }; function k(t, e) { if (t === e) return !0; const n = u(t); const i = u(e); if (!n || !i) return !n && !i && String(t) === String(e); try { const r = Array.isArray(t); const o = Array.isArray(e); if (r && o) return t.length === e.length && t.every((t, n) => k(t, e[n])); if (r || o) return !1; const s = Object.keys(t); const a = Object.keys(e); return s.length === a.length && s.every(n => k(t[n], e[n])); } catch (c) { return !1; } } function M(t, e) { for (let n = 0; n < t.length; n++) if (k(t[n], e)) return n; return -1; } function N(t) { let e = !1; return function () { e || (e = !0, t.apply(this, arguments)); }; } const D = 'data-server-rendered'; const $ = ['component', 'directive', 'filter']; const G = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured']; const V = {
        optionMergeStrategies: Object.create(null), silent: !1, productionTip: !1, devtools: !1, performance: !1, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: Object.create(null), isReservedTag: F, isReservedAttr: F, isUnknownElement: F, getTagNamespace: A, parsePlatformTagName: j, mustUseProp: F, _lifecycleHooks: G,
      }; function B(t) { const e = (`${t}`).charCodeAt(0); return e === 36 || e === 95; } function U(t, e, n, i) {
        Object.defineProperty(t, e, {
          value: n, enumerable: !!i, writable: !0, configurable: !0,
        });
      } const z = /[^\w.$]/; function Y(t) { if (!z.test(t)) { const e = t.split('.'); return function (t) { for (let n = 0; n < e.length; n++) { if (!t) return; t = t[e[n]]; } return t; }; } } let X; const W = '__proto__' in {}; const K = typeof window !== 'undefined'; const H = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform; const q = H && WXEnvironment.platform.toLowerCase(); const Z = K && window.navigator.userAgent.toLowerCase(); const J = Z && /msie|trident/.test(Z); const Q = Z && Z.indexOf('msie 9.0') > 0; const tt = Z && Z.indexOf('edge/') > 0; const et = (Z && Z.indexOf('android'), Z && /iphone|ipad|ipod|ios/.test(Z) || q === 'ios'); const nt = (Z && /chrome\/\d+/.test(Z), {}.watch); let it = !1; if (K) try { const rt = {}; Object.defineProperty(rt, 'passive', { get() { it = !0; } }), window.addEventListener('test-passive', null, rt); } catch (ts) {} const ot = function () { return void 0 === X && (X = !K && !H && typeof t !== 'undefined' && t.process.env.VUE_ENV === 'server'), X; }; const st = K && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function at(t) { return typeof t === 'function' && /native code/.test(t.toString()); } let ut; const ct = typeof Symbol !== 'undefined' && at(Symbol) && typeof Reflect !== 'undefined' && at(Reflect.ownKeys); ut = typeof Set !== 'undefined' && at(Set) ? Set : (function () { function t() { this.set = Object.create(null); } return t.prototype.has = function (t) { return !0 === this.set[t]; }, t.prototype.add = function (t) { this.set[t] = !0; }, t.prototype.clear = function () { this.set = Object.create(null); }, t; }()); const ht = A; let lt = 0; const ft = function () { this.id = lt++, this.subs = []; }; ft.prototype.addSub = function (t) { this.subs.push(t); }, ft.prototype.removeSub = function (t) { y(this.subs, t); }, ft.prototype.depend = function () { ft.target && ft.target.addDep(this); }, ft.prototype.notify = function () { for (let t = this.subs.slice(), e = 0, n = t.length; e < n; e++)t[e].update(); }, ft.target = null; const pt = []; function dt(t) { ft.target && pt.push(ft.target), ft.target = t; } function vt() { ft.target = pt.pop(); } const gt = function (t, e, n, i, r, o, s, a) { this.tag = t, this.data = e, this.children = n, this.text = i, this.elm = r, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = s, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = a, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1; }; const yt = { child: { configurable: !0 } }; yt.child.get = function () { return this.componentInstance; }, Object.defineProperties(gt.prototype, yt); const mt = function (t) { void 0 === t && (t = ''); const e = new gt(); return e.text = t, e.isComment = !0, e; }; function _t(t) { return new gt(void 0, void 0, void 0, String(t)); } function bt(t) { const e = new gt(t.tag, t.data, t.children, t.text, t.elm, t.context, t.componentOptions, t.asyncFactory); return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.isCloned = !0, e; } const wt = Array.prototype; const xt = Object.create(wt); const Et = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']; Et.forEach((t) => { const e = wt[t]; U(xt, t, function () { const n = []; let i = arguments.length; while (i--)n[i] = arguments[i]; let r; const o = e.apply(this, n); const s = this.__ob__; switch (t) { case 'push': case 'unshift': r = n; break; case 'splice': r = n.slice(2); break; } return r && s.observeArray(r), s.dep.notify(), o; }); }); const St = Object.getOwnPropertyNames(xt); let Tt = !0; function Ot(t) { Tt = t; } const Ct = function (t) { if (this.value = t, this.dep = new ft(), this.vmCount = 0, U(t, '__ob__', this), Array.isArray(t)) { const e = W ? Rt : It; e(t, xt, St), this.observeArray(t); } else this.walk(t); }; function Rt(t, e, n) { t.__proto__ = e; } function It(t, e, n) { for (let i = 0, r = n.length; i < r; i++) { const o = n[i]; U(t, o, e[o]); } } function Pt(t, e) { let n; if (u(t) && !(t instanceof gt)) return _(t, '__ob__') && t.__ob__ instanceof Ct ? n = t.__ob__ : Tt && !ot() && (Array.isArray(t) || h(t)) && Object.isExtensible(t) && !t._isVue && (n = new Ct(t)), e && n && n.vmCount++, n; } function Lt(t, e, n, i, r) {
        const o = new ft(); const
          s = Object.getOwnPropertyDescriptor(t, e); if (!s || !1 !== s.configurable) {
          const a = s && s.get; a || arguments.length !== 2 || (n = t[e]); const u = s && s.set; let c = !r && Pt(n); Object.defineProperty(t, e, {
            enumerable: !0, configurable: !0, get() { const e = a ? a.call(t) : n; return ft.target && (o.depend(), c && (c.dep.depend(), Array.isArray(e) && jt(e))), e; }, set(e) { const i = a ? a.call(t) : n; e === i || e !== e && i !== i || (u ? u.call(t, e) : n = e, c = !r && Pt(e), o.notify()); },
          });
        }
      } function At(t, e, n) { if (Array.isArray(t) && f(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n; if (e in t && !(e in Object.prototype)) return t[e] = n, n; const i = t.__ob__; return t._isVue || i && i.vmCount ? n : i ? (Lt(i.value, e, n), i.dep.notify(), n) : (t[e] = n, n); } function Ft(t, e) { if (Array.isArray(t) && f(e))t.splice(e, 1); else { const n = t.__ob__; t._isVue || n && n.vmCount || _(t, e) && (delete t[e], n && n.dep.notify()); } } function jt(t) { for (let e = void 0, n = 0, i = t.length; n < i; n++)e = t[n], e && e.__ob__ && e.__ob__.dep.depend(), Array.isArray(e) && jt(e); }Ct.prototype.walk = function (t) { for (let e = Object.keys(t), n = 0; n < e.length; n++)Lt(t, e[n]); }, Ct.prototype.observeArray = function (t) { for (let e = 0, n = t.length; e < n; e++)Pt(t[e]); }; const kt = V.optionMergeStrategies; function Mt(t, e) { if (!e) return t; for (var n, i, r, o = Object.keys(e), s = 0; s < o.length; s++)n = o[s], i = t[n], r = e[n], _(t, n) ? h(i) && h(r) && Mt(i, r) : At(t, n, r); return t; } function Nt(t, e, n) { return n ? function () { const i = typeof e === 'function' ? e.call(n, n) : e; const r = typeof t === 'function' ? t.call(n, n) : t; return i ? Mt(i, r) : r; } : e ? t ? function () { return Mt(typeof e === 'function' ? e.call(this, this) : e, typeof t === 'function' ? t.call(this, this) : t); } : e : t; } function Dt(t, e) { return e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t; } function $t(t, e, n, i) { const r = Object.create(t || null); return e ? P(r, e) : r; }kt.data = function (t, e, n) { return n ? Nt(t, e, n) : e && typeof e !== 'function' ? t : Nt(t, e); }, G.forEach((t) => { kt[t] = Dt; }), $.forEach((t) => { kt[`${t}s`] = $t; }), kt.watch = function (t, e, n, i) { if (t === nt && (t = void 0), e === nt && (e = void 0), !e) return Object.create(t || null); if (!t) return e; const r = {}; for (const o in P(r, t), e) { let s = r[o]; const a = e[o]; s && !Array.isArray(s) && (s = [s]), r[o] = s ? s.concat(a) : Array.isArray(a) ? a : [a]; } return r; }, kt.props = kt.methods = kt.inject = kt.computed = function (t, e, n, i) { if (!t) return e; const r = Object.create(null); return P(r, t), e && P(r, e), r; }, kt.provide = Nt; const Gt = function (t, e) { return void 0 === e ? t : e; }; function Vt(t, e) { const n = t.props; if (n) { let i; let r; let o; const s = {}; if (Array.isArray(n)) { i = n.length; while (i--)r = n[i], typeof r === 'string' && (o = x(r), s[o] = { type: null }); } else if (h(n)) for (const a in n)r = n[a], o = x(a), s[o] = h(r) ? r : { type: r }; else 0; t.props = s; } } function Bt(t, e) { const n = t.inject; if (n) { const i = t.inject = {}; if (Array.isArray(n)) for (let r = 0; r < n.length; r++)i[n[r]] = { from: n[r] }; else if (h(n)) for (const o in n) { const s = n[o]; i[o] = h(s) ? P({ from: o }, s) : { from: s }; } else 0; } } function Ut(t) { const e = t.directives; if (e) for (const n in e) { const i = e[n]; typeof i === 'function' && (e[n] = { bind: i, update: i }); } } function zt(t, e, n) { typeof e === 'function' && (e = e.options), Vt(e, n), Bt(e, n), Ut(e); const i = e.extends; if (i && (t = zt(t, i, n)), e.mixins) for (let r = 0, o = e.mixins.length; r < o; r++)t = zt(t, e.mixins[r], n); let s; const a = {}; for (s in t)u(s); for (s in e)_(t, s) || u(s); function u(i) { const r = kt[i] || Gt; a[i] = r(t[i], e[i], n, i); } return a; } function Yt(t, e, n, i) { if (typeof n === 'string') { const r = t[e]; if (_(r, n)) return r[n]; const o = x(n); if (_(r, o)) return r[o]; const s = E(o); if (_(r, s)) return r[s]; const a = r[n] || r[o] || r[s]; return a; } } function Xt(t, e, n, i) { const r = e[t]; const o = !_(n, t); let s = n[t]; const a = qt(Boolean, r.type); if (a > -1) if (o && !_(r, 'default'))s = !1; else if (s === '' || s === T(t)) { const u = qt(String, r.type); (u < 0 || a < u) && (s = !0); } if (void 0 === s) { s = Wt(i, r, t); const c = Tt; Ot(!0), Pt(s), Ot(c); } return s; } function Wt(t, e, n) { if (_(e, 'default')) { const i = e.default; return t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n] ? t._props[n] : typeof i === 'function' && Kt(e.type) !== 'Function' ? i.call(t) : i; } } function Kt(t) { const e = t && t.toString().match(/^\s*function (\w+)/); return e ? e[1] : ''; } function Ht(t, e) { return Kt(t) === Kt(e); } function qt(t, e) { if (!Array.isArray(e)) return Ht(e, t) ? 0 : -1; for (let n = 0, i = e.length; n < i; n++) if (Ht(e[n], t)) return n; return -1; } function Zt(t, e, n) { if (e) { let i = e; while (i = i.$parent) { const r = i.$options.errorCaptured; if (r) for (let o = 0; o < r.length; o++) try { const s = !1 === r[o].call(i, t, e, n); if (s) return; } catch (ts) { Jt(ts, i, 'errorCaptured hook'); } } }Jt(t, e, n); } function Jt(t, e, n) { if (V.errorHandler) try { return V.errorHandler.call(null, t, e, n); } catch (ts) { Qt(ts, null, 'config.errorHandler'); }Qt(t, e, n); } function Qt(t, e, n) { if (!K && !H || typeof console === 'undefined') throw t; console.error(t); } let te; let ee; const ne = []; let ie = !1; function re() { ie = !1; const t = ne.slice(0); ne.length = 0; for (let e = 0; e < t.length; e++)t[e](); } let oe = !1; if (typeof setImmediate !== 'undefined' && at(setImmediate))ee = function () { setImmediate(re); }; else if (typeof MessageChannel === 'undefined' || !at(MessageChannel) && MessageChannel.toString() !== '[object MessageChannelConstructor]')ee = function () { setTimeout(re, 0); }; else {
        const se = new MessageChannel(); const
          ae = se.port2; se.port1.onmessage = re, ee = function () { ae.postMessage(1); };
      } if (typeof Promise !== 'undefined' && at(Promise)) { const ue = Promise.resolve(); te = function () { ue.then(re), et && setTimeout(A); }; } else te = ee; function ce(t) { return t._withTask || (t._withTask = function () { oe = !0; const e = t(...arguments); return oe = !1, e; }); } function he(t, e) { let n; if (ne.push(() => { if (t) try { t.call(e); } catch (ts) { Zt(ts, e, 'nextTick'); } else n && n(e); }), ie || (ie = !0, oe ? ee() : te()), !t && typeof Promise !== 'undefined') return new Promise(((t) => { n = t; })); } const le = new ut(); function fe(t) { pe(t, le), le.clear(); } function pe(t, e) { let n; let i; const r = Array.isArray(t); if (!(!r && !u(t) || Object.isFrozen(t) || t instanceof gt)) { if (t.__ob__) { const o = t.__ob__.dep.id; if (e.has(o)) return; e.add(o); } if (r) { n = t.length; while (n--)pe(t[n], e); } else { i = Object.keys(t), n = i.length; while (n--)pe(t[i[n]], e); } } } let de; const ve = b((t) => {
        const e = t.charAt(0) === '&'; t = e ? t.slice(1) : t; const n = t.charAt(0) === '~'; t = n ? t.slice(1) : t; const i = t.charAt(0) === '!'; return t = i ? t.slice(1) : t, {
          name: t, once: n, capture: i, passive: e,
        };
      }); function ge(t) { function e() { const t = arguments; const n = e.fns; if (!Array.isArray(n)) return n(...arguments); for (let i = n.slice(), r = 0; r < i.length; r++)i[r].apply(null, t); } return e.fns = t, e; } function ye(t, e, n, r, o) { let s; let a; let u; let c; for (s in t)a = t[s], u = e[s], c = ve(s), i(a) || (i(u) ? (i(a.fns) && (a = t[s] = ge(a)), n(c.name, a, c.once, c.capture, c.passive, c.params)) : a !== u && (u.fns = a, t[s] = u)); for (s in e)i(t[s]) && (c = ve(s), r(c.name, e[s], c.capture)); } function me(t, e, n) { let s; t instanceof gt && (t = t.data.hook || (t.data.hook = {})); const a = t[e]; function u() { n.apply(this, arguments), y(s.fns, u); }i(a) ? s = ge([u]) : r(a.fns) && o(a.merged) ? (s = a, s.fns.push(u)) : s = ge([a, u]), s.merged = !0, t[e] = s; } function _e(t, e, n) { const o = e.options.props; if (!i(o)) { const s = {}; const a = t.attrs; const u = t.props; if (r(a) || r(u)) for (const c in o) { const h = T(c); be(s, u, c, h, !0) || be(s, a, c, h, !1); } return s; } } function be(t, e, n, i, o) { if (r(e)) { if (_(e, n)) return t[n] = e[n], o || delete e[n], !0; if (_(e, i)) return t[n] = e[i], o || delete e[i], !0; } return !1; } function we(t) { for (let e = 0; e < t.length; e++) if (Array.isArray(t[e])) return Array.prototype.concat.apply([], t); return t; } function xe(t) { return a(t) ? [_t(t)] : Array.isArray(t) ? Se(t) : void 0; } function Ee(t) { return r(t) && r(t.text) && s(t.isComment); } function Se(t, e) { let n; let s; let u; let c; const h = []; for (n = 0; n < t.length; n++)s = t[n], i(s) || typeof s === 'boolean' || (u = h.length - 1, c = h[u], Array.isArray(s) ? s.length > 0 && (s = Se(s, `${e || ''}_${n}`), Ee(s[0]) && Ee(c) && (h[u] = _t(c.text + s[0].text), s.shift()), h.push(...s)) : a(s) ? Ee(c) ? h[u] = _t(c.text + s) : s !== '' && h.push(_t(s)) : Ee(s) && Ee(c) ? h[u] = _t(c.text + s.text) : (o(t._isVList) && r(s.tag) && i(s.key) && r(e) && (s.key = `__vlist${e}_${n}__`), h.push(s))); return h; } function Te(t, e) { return (t.__esModule || ct && t[Symbol.toStringTag] === 'Module') && (t = t.default), u(t) ? e.extend(t) : t; } function Oe(t, e, n, i, r) {
        const o = mt(); return o.asyncFactory = t, o.asyncMeta = {
          data: e, context: n, children: i, tag: r,
        }, o;
      } function Ce(t, e, n) { if (o(t.error) && r(t.errorComp)) return t.errorComp; if (r(t.resolved)) return t.resolved; if (o(t.loading) && r(t.loadingComp)) return t.loadingComp; if (!r(t.contexts)) { const s = t.contexts = [n]; let a = !0; const c = function () { for (let t = 0, e = s.length; t < e; t++)s[t].$forceUpdate(); }; const h = N((n) => { t.resolved = Te(n, e), a || c(); }); const l = N((e) => { r(t.errorComp) && (t.error = !0, c()); }); const f = t(h, l); return u(f) && (typeof f.then === 'function' ? i(t.resolved) && f.then(h, l) : r(f.component) && typeof f.component.then === 'function' && (f.component.then(h, l), r(f.error) && (t.errorComp = Te(f.error, e)), r(f.loading) && (t.loadingComp = Te(f.loading, e), f.delay === 0 ? t.loading = !0 : setTimeout(() => { i(t.resolved) && i(t.error) && (t.loading = !0, c()); }, f.delay || 200)), r(f.timeout) && setTimeout(() => { i(t.resolved) && l(null); }, f.timeout))), a = !1, t.loading ? t.loadingComp : t.resolved; }t.contexts.push(n); } function Re(t) { return t.isComment && t.asyncFactory; } function Ie(t) { if (Array.isArray(t)) for (let e = 0; e < t.length; e++) { const n = t[e]; if (r(n) && (r(n.componentOptions) || Re(n))) return n; } } function Pe(t) { t._events = Object.create(null), t._hasHookEvent = !1; const e = t.$options._parentListeners; e && Fe(t, e); } function Le(t, e, n) { n ? de.$once(t, e) : de.$on(t, e); } function Ae(t, e) { de.$off(t, e); } function Fe(t, e, n) { de = t, ye(e, n || {}, Le, Ae, t), de = void 0; } function je(t) { const e = /^hook:/; t.prototype.$on = function (t, n) { const i = this; const r = this; if (Array.isArray(t)) for (let o = 0, s = t.length; o < s; o++)i.$on(t[o], n); else (r._events[t] || (r._events[t] = [])).push(n), e.test(t) && (r._hasHookEvent = !0); return r; }, t.prototype.$once = function (t, e) { const n = this; function i() { n.$off(t, i), e.apply(n, arguments); } return i.fn = e, n.$on(t, i), n; }, t.prototype.$off = function (t, e) { const n = this; const i = this; if (!arguments.length) return i._events = Object.create(null), i; if (Array.isArray(t)) { for (let r = 0, o = t.length; r < o; r++)n.$off(t[r], e); return i; } const s = i._events[t]; if (!s) return i; if (!e) return i._events[t] = null, i; if (e) { let a; let u = s.length; while (u--) if (a = s[u], a === e || a.fn === e) { s.splice(u, 1); break; } } return i; }, t.prototype.$emit = function (t) { const e = this; let n = e._events[t]; if (n) { n = n.length > 1 ? I(n) : n; for (let i = I(arguments, 1), r = 0, o = n.length; r < o; r++) try { n[r].apply(e, i); } catch (ts) { Zt(ts, e, `event handler for "${t}"`); } } return e; }; } function ke(t, e) { const n = {}; if (!t) return n; for (let i = 0, r = t.length; i < r; i++) { const o = t[i]; const s = o.data; if (s && s.attrs && s.attrs.slot && delete s.attrs.slot, o.context !== e && o.fnContext !== e || !s || s.slot == null)(n.default || (n.default = [])).push(o); else { const a = s.slot; const u = n[a] || (n[a] = []); o.tag === 'template' ? u.push(...o.children || []) : u.push(o); } } for (const c in n)n[c].every(Me) && delete n[c]; return n; } function Me(t) { return t.isComment && !t.asyncFactory || t.text === ' '; } function Ne(t, e) { e = e || {}; for (let n = 0; n < t.length; n++)Array.isArray(t[n]) ? Ne(t[n], e) : e[t[n].key] = t[n].fn; return e; } let De = null; function $e(t) { const e = t.$options; let n = e.parent; if (n && !e.abstract) { while (n.$options.abstract && n.$parent)n = n.$parent; n.$children.push(t); }t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1; } function Ge(t) { t.prototype._update = function (t, e) { const n = this; n._isMounted && Xe(n, 'beforeUpdate'); const i = n.$el; const r = n._vnode; const o = De; De = n, n._vnode = t, r ? n.$el = n.__patch__(r, t) : (n.$el = n.__patch__(n.$el, t, e, !1, n.$options._parentElm, n.$options._refElm), n.$options._parentElm = n.$options._refElm = null), De = o, i && (i.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el); }, t.prototype.$forceUpdate = function () { const t = this; t._watcher && t._watcher.update(); }, t.prototype.$destroy = function () { const t = this; if (!t._isBeingDestroyed) { Xe(t, 'beforeDestroy'), t._isBeingDestroyed = !0; const e = t.$parent; !e || e._isBeingDestroyed || t.$options.abstract || y(e.$children, t), t._watcher && t._watcher.teardown(); let n = t._watchers.length; while (n--)t._watchers[n].teardown(); t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), Xe(t, 'destroyed'), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null); } }; } function Ve(t, e, n) { let i; return t.$el = e, t.$options.render || (t.$options.render = mt), Xe(t, 'beforeMount'), i = function () { t._update(t._render(), n); }, new an(t, i, A, null, !0), n = !1, t.$vnode == null && (t._isMounted = !0, Xe(t, 'mounted')), t; } function Be(t, e, i, r, o) { const s = !!(o || t.$options._renderChildren || r.data.scopedSlots || t.$scopedSlots !== n); if (t.$options._parentVnode = r, t.$vnode = r, t._vnode && (t._vnode.parent = r), t.$options._renderChildren = o, t.$attrs = r.data.attrs || n, t.$listeners = i || n, e && t.$options.props) { Ot(!1); for (let a = t._props, u = t.$options._propKeys || [], c = 0; c < u.length; c++) { const h = u[c]; const l = t.$options.props; a[h] = Xt(h, l, e, t); }Ot(!0), t.$options.propsData = e; }i = i || n; const f = t.$options._parentListeners; t.$options._parentListeners = i, Fe(t, i, f), s && (t.$slots = ke(o, r.context), t.$forceUpdate()); } function Ue(t) { while (t && (t = t.$parent)) if (t._inactive) return !0; return !1; } function ze(t, e) { if (e) { if (t._directInactive = !1, Ue(t)) return; } else if (t._directInactive) return; if (t._inactive || t._inactive === null) { t._inactive = !1; for (let n = 0; n < t.$children.length; n++)ze(t.$children[n]); Xe(t, 'activated'); } } function Ye(t, e) { if ((!e || (t._directInactive = !0, !Ue(t))) && !t._inactive) { t._inactive = !0; for (let n = 0; n < t.$children.length; n++)Ye(t.$children[n]); Xe(t, 'deactivated'); } } function Xe(t, e) { dt(); const n = t.$options[e]; if (n) for (let i = 0, r = n.length; i < r; i++) try { n[i].call(t); } catch (ts) { Zt(ts, t, `${e} hook`); }t._hasHookEvent && t.$emit(`hook:${e}`), vt(); } const We = []; const Ke = []; let He = {}; let qe = !1; let Ze = !1; let Je = 0; function Qe() { Je = We.length = Ke.length = 0, He = {}, qe = Ze = !1; } function tn() { let t; let e; for (Ze = !0, We.sort((t, e) => t.id - e.id), Je = 0; Je < We.length; Je++)t = We[Je], e = t.id, He[e] = null, t.run(); const n = Ke.slice(); const i = We.slice(); Qe(), rn(n), en(i), st && V.devtools && st.emit('flush'); } function en(t) { let e = t.length; while (e--) { const n = t[e]; const i = n.vm; i._watcher === n && i._isMounted && Xe(i, 'updated'); } } function nn(t) { t._inactive = !1, Ke.push(t); } function rn(t) { for (let e = 0; e < t.length; e++)t[e]._inactive = !0, ze(t[e], !0); } function on(t) { const e = t.id; if (He[e] == null) { if (He[e] = !0, Ze) { let n = We.length - 1; while (n > Je && We[n].id > t.id)n--; We.splice(n + 1, 0, t); } else We.push(t); qe || (qe = !0, he(tn)); } } let sn = 0; var an = function (t, e, n, i, r) { this.vm = t, r && (t._watcher = this), t._watchers.push(this), i ? (this.deep = !!i.deep, this.user = !!i.user, this.lazy = !!i.lazy, this.sync = !!i.sync) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++sn, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ut(), this.newDepIds = new ut(), this.expression = '', typeof e === 'function' ? this.getter = e : (this.getter = Y(e), this.getter || (this.getter = function () {})), this.value = this.lazy ? void 0 : this.get(); }; an.prototype.get = function () { let t; dt(this); const e = this.vm; try { t = this.getter.call(e, e); } catch (ts) { if (!this.user) throw ts; Zt(ts, e, `getter for watcher "${this.expression}"`); } finally { this.deep && fe(t), vt(), this.cleanupDeps(); } return t; }, an.prototype.addDep = function (t) { const e = t.id; this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this)); }, an.prototype.cleanupDeps = function () { const t = this; let e = this.deps.length; while (e--) { const n = t.deps[e]; t.newDepIds.has(n.id) || n.removeSub(t); } let i = this.depIds; this.depIds = this.newDepIds, this.newDepIds = i, this.newDepIds.clear(), i = this.deps, this.deps = this.newDeps, this.newDeps = i, this.newDeps.length = 0; }, an.prototype.update = function () { this.lazy ? this.dirty = !0 : this.sync ? this.run() : on(this); }, an.prototype.run = function () { if (this.active) { const t = this.get(); if (t !== this.value || u(t) || this.deep) { const e = this.value; if (this.value = t, this.user) try { this.cb.call(this.vm, t, e); } catch (ts) { Zt(ts, this.vm, `callback for watcher "${this.expression}"`); } else this.cb.call(this.vm, t, e); } } }, an.prototype.evaluate = function () { this.value = this.get(), this.dirty = !1; }, an.prototype.depend = function () { const t = this; let e = this.deps.length; while (e--)t.deps[e].depend(); }, an.prototype.teardown = function () { const t = this; if (this.active) { this.vm._isBeingDestroyed || y(this.vm._watchers, this); let e = this.deps.length; while (e--)t.deps[e].removeSub(t); this.active = !1; } }; const un = {
        enumerable: !0, configurable: !0, get: A, set: A,
      }; function cn(t, e, n) { un.get = function () { return this[e][n]; }, un.set = function (t) { this[e][n] = t; }, Object.defineProperty(t, n, un); } function hn(t) { t._watchers = []; const e = t.$options; e.props && ln(t, e.props), e.methods && mn(t, e.methods), e.data ? fn(t) : Pt(t._data = {}, !0), e.computed && vn(t, e.computed), e.watch && e.watch !== nt && _n(t, e.watch); } function ln(t, e) { const n = t.$options.propsData || {}; const i = t._props = {}; const r = t.$options._propKeys = []; const o = !t.$parent; o || Ot(!1); const s = function (o) { r.push(o); const s = Xt(o, e, n, t); Lt(i, o, s), o in t || cn(t, '_props', o); }; for (const a in e)s(a); Ot(!0); } function fn(t) { let e = t.$options.data; e = t._data = typeof e === 'function' ? pn(e, t) : e || {}, h(e) || (e = {}); const n = Object.keys(e); const i = t.$options.props; let r = (t.$options.methods, n.length); while (r--) { const o = n[r]; 0, i && _(i, o) || B(o) || cn(t, '_data', o); }Pt(e, !0); } function pn(t, e) { dt(); try { return t.call(e, e); } catch (ts) { return Zt(ts, e, 'data()'), {}; } finally { vt(); } } const dn = { lazy: !0 }; function vn(t, e) { const n = t._computedWatchers = Object.create(null); const i = ot(); for (const r in e) { const o = e[r]; const s = typeof o === 'function' ? o : o.get; 0, i || (n[r] = new an(t, s || A, A, dn)), r in t || gn(t, r, o); } } function gn(t, e, n) { const i = !ot(); typeof n === 'function' ? (un.get = i ? yn(e) : n, un.set = A) : (un.get = n.get ? i && !1 !== n.cache ? yn(e) : n.get : A, un.set = n.set ? n.set : A), Object.defineProperty(t, e, un); } function yn(t) { return function () { const e = this._computedWatchers && this._computedWatchers[t]; if (e) return e.dirty && e.evaluate(), ft.target && e.depend(), e.value; }; } function mn(t, e) { t.$options.props; for (const n in e)t[n] = e[n] == null ? A : R(e[n], t); } function _n(t, e) { for (const n in e) { const i = e[n]; if (Array.isArray(i)) for (let r = 0; r < i.length; r++)bn(t, n, i[r]); else bn(t, n, i); } } function bn(t, e, n, i) { return h(n) && (i = n, n = n.handler), typeof n === 'string' && (n = t[n]), t.$watch(e, n, i); } function wn(t) { const e = { get() { return this._data; } }; const n = { get() { return this._props; } }; Object.defineProperty(t.prototype, '$data', e), Object.defineProperty(t.prototype, '$props', n), t.prototype.$set = At, t.prototype.$delete = Ft, t.prototype.$watch = function (t, e, n) { const i = this; if (h(e)) return bn(i, t, e, n); n = n || {}, n.user = !0; const r = new an(i, t, e, n); return n.immediate && e.call(i, r.value), function () { r.teardown(); }; }; } function xn(t) { const e = t.$options.provide; e && (t._provided = typeof e === 'function' ? e.call(t) : e); } function En(t) { const e = Sn(t.$options.inject, t); e && (Ot(!1), Object.keys(e).forEach((n) => { Lt(t, n, e[n]); }), Ot(!0)); } function Sn(t, e) { if (t) { for (var n = Object.create(null), i = ct ? Reflect.ownKeys(t).filter(e => Object.getOwnPropertyDescriptor(t, e).enumerable) : Object.keys(t), r = 0; r < i.length; r++) { const o = i[r]; const s = t[o].from; let a = e; while (a) { if (a._provided && _(a._provided, s)) { n[o] = a._provided[s]; break; }a = a.$parent; } if (!a) if ('default' in t[o]) { const u = t[o].default; n[o] = typeof u === 'function' ? u.call(e) : u; } else 0; } return n; } } function Tn(t, e) { let n; let i; let o; let s; let a; if (Array.isArray(t) || typeof t === 'string') for (n = new Array(t.length), i = 0, o = t.length; i < o; i++)n[i] = e(t[i], i); else if (typeof t === 'number') for (n = new Array(t), i = 0; i < t; i++)n[i] = e(i + 1, i); else if (u(t)) for (s = Object.keys(t), n = new Array(s.length), i = 0, o = s.length; i < o; i++)a = s[i], n[i] = e(t[a], a, i); return r(n) && (n._isVList = !0), n; } function On(t, e, n, i) { let r; const o = this.$scopedSlots[t]; if (o)n = n || {}, i && (n = P(P({}, i), n)), r = o(n) || e; else { const s = this.$slots[t]; s && (s._rendered = !0), r = s || e; } const a = n && n.slot; return a ? this.$createElement('template', { slot: a }, r) : r; } function Cn(t) { return Yt(this.$options, 'filters', t, !0) || j; } function Rn(t, e) { return Array.isArray(t) ? t.indexOf(e) === -1 : t !== e; } function In(t, e, n, i, r) { const o = V.keyCodes[e] || n; return r && i && !V.keyCodes[e] ? Rn(r, i) : o ? Rn(o, t) : i ? T(i) !== e : void 0; } function Pn(t, e, n, i, r) { if (n) if (u(n)) { let o; Array.isArray(n) && (n = L(n)); const s = function (s) { if (s === 'class' || s === 'style' || g(s))o = t; else { const a = t.attrs && t.attrs.type; o = i || V.mustUseProp(e, a, s) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {}); } if (!(s in o) && (o[s] = n[s], r)) { const u = t.on || (t.on = {}); u[`update:${s}`] = function (t) { n[s] = t; }; } }; for (const a in n)s(a); } else;return t; } function Ln(t, e) { const n = this._staticTrees || (this._staticTrees = []); let i = n[t]; return i && !e ? i : (i = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), Fn(i, `__static__${t}`, !1), i); } function An(t, e, n) { return Fn(t, `__once__${e}${n ? `_${n}` : ''}`, !0), t; } function Fn(t, e, n) { if (Array.isArray(t)) for (let i = 0; i < t.length; i++)t[i] && typeof t[i] !== 'string' && jn(t[i], `${e}_${i}`, n); else jn(t, e, n); } function jn(t, e, n) { t.isStatic = !0, t.key = e, t.isOnce = n; } function kn(t, e) { if (e) if (h(e)) { const n = t.on = t.on ? P({}, t.on) : {}; for (const i in e) { const r = n[i]; const o = e[i]; n[i] = r ? [].concat(r, o) : o; } } else;return t; } function Mn(t) { t._o = An, t._n = d, t._s = p, t._l = Tn, t._t = On, t._q = k, t._i = M, t._m = Ln, t._f = Cn, t._k = In, t._b = Pn, t._v = _t, t._e = mt, t._u = Ne, t._g = kn; } function Nn(t, e, i, r, s) { let a; const u = s.options; _(r, '_uid') ? (a = Object.create(r), a._original = r) : (a = r, r = r._original); const c = o(u._compiled); const h = !c; this.data = t, this.props = e, this.children = i, this.parent = r, this.listeners = t.on || n, this.injections = Sn(u.inject, r), this.slots = function () { return ke(i, r); }, c && (this.$options = u, this.$slots = this.slots(), this.$scopedSlots = t.scopedSlots || n), u._scopeId ? this._c = function (t, e, n, i) { const o = Hn(a, t, e, n, i, h); return o && !Array.isArray(o) && (o.fnScopeId = u._scopeId, o.fnContext = r), o; } : this._c = function (t, e, n, i) { return Hn(a, t, e, n, i, h); }; } function Dn(t, e, i, o, s) { const a = t.options; const u = {}; const c = a.props; if (r(c)) for (const h in c)u[h] = Xt(h, c, e || n); else r(i.attrs) && Gn(u, i.attrs), r(i.props) && Gn(u, i.props); const l = new Nn(i, u, s, o, t); const f = a.render.call(null, l._c, l); if (f instanceof gt) return $n(f, i, l.parent, a); if (Array.isArray(f)) { for (var p = xe(f) || [], d = new Array(p.length), v = 0; v < p.length; v++)d[v] = $n(p[v], i, l.parent, a); return d; } } function $n(t, e, n, i) { const r = bt(t); return r.fnContext = n, r.fnOptions = i, e.slot && ((r.data || (r.data = {})).slot = e.slot), r; } function Gn(t, e) { for (const n in e)t[x(n)] = e[n]; }Mn(Nn.prototype); var Vn = {
        init(t, e, n, i) { if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) { const r = t; Vn.prepatch(r, r); } else { const o = t.componentInstance = zn(t, De, n, i); o.$mount(e ? t.elm : void 0, e); } }, prepatch(t, e) { const n = e.componentOptions; const i = e.componentInstance = t.componentInstance; Be(i, n.propsData, n.listeners, e, n.children); }, insert(t) { const e = t.context; const n = t.componentInstance; n._isMounted || (n._isMounted = !0, Xe(n, 'mounted')), t.data.keepAlive && (e._isMounted ? nn(n) : ze(n, !0)); }, destroy(t) { const e = t.componentInstance; e._isDestroyed || (t.data.keepAlive ? Ye(e, !0) : e.$destroy()); },
      }; const Bn = Object.keys(Vn); function Un(t, e, n, s, a) {
        if (!i(t)) {
          const c = n.$options._base; if (u(t) && (t = c.extend(t)), typeof t === 'function') {
            let h; if (i(t.cid) && (h = t, t = Ce(h, c, n), void 0 === t)) return Oe(h, e, n, s, a); e = e || {}, ri(t), r(e.model) && Xn(t.options, e); const l = _e(e, t, a); if (o(t.options.functional)) return Dn(t, l, e, n, s); const f = e.on; if (e.on = e.nativeOn, o(t.options.abstract)) { const p = e.slot; e = {}, p && (e.slot = p); }Yn(e); const d = t.options.name || a; const v = new gt(`vue-component-${t.cid}${d ? `-${d}` : ''}`, e, void 0, void 0, void 0, n, {
              Ctor: t, propsData: l, listeners: f, tag: a, children: s,
            }, h); return v;
          }
        }
      } function zn(t, e, n, i) {
        const o = {
          _isComponent: !0, parent: e, _parentVnode: t, _parentElm: n || null, _refElm: i || null,
        }; const s = t.data.inlineTemplate; return r(s) && (o.render = s.render, o.staticRenderFns = s.staticRenderFns), new t.componentOptions.Ctor(o);
      } function Yn(t) { for (let e = t.hook || (t.hook = {}), n = 0; n < Bn.length; n++) { const i = Bn[n]; e[i] = Vn[i]; } } function Xn(t, e) { const n = t.model && t.model.prop || 'value'; const i = t.model && t.model.event || 'input'; (e.props || (e.props = {}))[n] = e.model.value; const o = e.on || (e.on = {}); r(o[i]) ? o[i] = [e.model.callback].concat(o[i]) : o[i] = e.model.callback; } const Wn = 1; const Kn = 2; function Hn(t, e, n, i, r, s) { return (Array.isArray(n) || a(n)) && (r = i, i = n, n = void 0), o(s) && (r = Kn), qn(t, e, n, i, r); } function qn(t, e, n, i, o) { if (r(n) && r(n.__ob__)) return mt(); if (r(n) && r(n.is) && (e = n.is), !e) return mt(); let s; let a; let u; (Array.isArray(i) && typeof i[0] === 'function' && (n = n || {}, n.scopedSlots = { default: i[0] }, i.length = 0), o === Kn ? i = xe(i) : o === Wn && (i = we(i)), typeof e === 'string') ? (a = t.$vnode && t.$vnode.ns || V.getTagNamespace(e), s = V.isReservedTag(e) ? new gt(V.parsePlatformTagName(e), n, i, void 0, void 0, t) : r(u = Yt(t.$options, 'components', e)) ? Un(u, n, t, i, e) : new gt(e, n, i, void 0, void 0, t)) : s = Un(e, n, t, i); return Array.isArray(s) ? s : r(s) ? (r(a) && Zn(s, a), r(n) && Jn(n), s) : mt(); } function Zn(t, e, n) { if (t.ns = e, t.tag === 'foreignObject' && (e = void 0, n = !0), r(t.children)) for (let s = 0, a = t.children.length; s < a; s++) { const u = t.children[s]; r(u.tag) && (i(u.ns) || o(n) && u.tag !== 'svg') && Zn(u, e, n); } } function Jn(t) { u(t.style) && fe(t.style), u(t.class) && fe(t.class); } function Qn(t) { t._vnode = null, t._staticTrees = null; const e = t.$options; const i = t.$vnode = e._parentVnode; const r = i && i.context; t.$slots = ke(e._renderChildren, r), t.$scopedSlots = n, t._c = function (e, n, i, r) { return Hn(t, e, n, i, r, !1); }, t.$createElement = function (e, n, i, r) { return Hn(t, e, n, i, r, !0); }; const o = i && i.data; Lt(t, '$attrs', o && o.attrs || n, null, !0), Lt(t, '$listeners', e._parentListeners || n, null, !0); } function ti(t) { Mn(t.prototype), t.prototype.$nextTick = function (t) { return he(t, this); }, t.prototype._render = function () { let t; const e = this; const i = e.$options; const r = i.render; const o = i._parentVnode; o && (e.$scopedSlots = o.data.scopedSlots || n), e.$vnode = o; try { t = r.call(e._renderProxy, e.$createElement); } catch (ts) { Zt(ts, e, 'render'), t = e._vnode; } return t instanceof gt || (t = mt()), t.parent = o, t; }; } let ei = 0; function ni(t) { t.prototype._init = function (t) { const e = this; e._uid = ei++, e._isVue = !0, t && t._isComponent ? ii(e, t) : e.$options = zt(ri(e.constructor), t || {}, e), e._renderProxy = e, e._self = e, $e(e), Pe(e), Qn(e), Xe(e, 'beforeCreate'), En(e), hn(e), xn(e), Xe(e, 'created'), e.$options.el && e.$mount(e.$options.el); }; } function ii(t, e) { const n = t.$options = Object.create(t.constructor.options); const i = e._parentVnode; n.parent = e.parent, n._parentVnode = i, n._parentElm = e._parentElm, n._refElm = e._refElm; const r = i.componentOptions; n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns); } function ri(t) { let e = t.options; if (t.super) { const n = ri(t.super); const i = t.superOptions; if (n !== i) { t.superOptions = n; const r = oi(t); r && P(t.extendOptions, r), e = t.options = zt(n, t.extendOptions), e.name && (e.components[e.name] = t); } } return e; } function oi(t) { let e; const n = t.options; const i = t.extendOptions; const r = t.sealedOptions; for (const o in n)n[o] !== r[o] && (e || (e = {}), e[o] = si(n[o], i[o], r[o])); return e; } function si(t, e, n) { if (Array.isArray(t)) { const i = []; n = Array.isArray(n) ? n : [n], e = Array.isArray(e) ? e : [e]; for (let r = 0; r < t.length; r++)(e.indexOf(t[r]) >= 0 || n.indexOf(t[r]) < 0) && i.push(t[r]); return i; } return t; } function ai(t) { this._init(t); } function ui(t) { t.use = function (t) { const e = this._installedPlugins || (this._installedPlugins = []); if (e.indexOf(t) > -1) return this; const n = I(arguments, 1); return n.unshift(this), typeof t.install === 'function' ? t.install(...n) : typeof t === 'function' && t(...n), e.push(t), this; }; } function ci(t) { t.mixin = function (t) { return this.options = zt(this.options, t), this; }; } function hi(t) { t.cid = 0; let e = 1; t.extend = function (t) { t = t || {}; const n = this; const i = n.cid; const r = t._Ctor || (t._Ctor = {}); if (r[i]) return r[i]; const o = t.name || n.options.name; const s = function (t) { this._init(t); }; return s.prototype = Object.create(n.prototype), s.prototype.constructor = s, s.cid = e++, s.options = zt(n.options, t), s.super = n, s.options.props && li(s), s.options.computed && fi(s), s.extend = n.extend, s.mixin = n.mixin, s.use = n.use, $.forEach((t) => { s[t] = n[t]; }), o && (s.options.components[o] = s), s.superOptions = n.options, s.extendOptions = t, s.sealedOptions = P({}, s.options), r[i] = s, s; }; } function li(t) { const e = t.options.props; for (const n in e)cn(t.prototype, '_props', n); } function fi(t) { const e = t.options.computed; for (const n in e)gn(t.prototype, n, e[n]); } function pi(t) { $.forEach((e) => { t[e] = function (t, n) { return n ? (e === 'component' && h(n) && (n.name = n.name || t, n = this.options._base.extend(n)), e === 'directive' && typeof n === 'function' && (n = { bind: n, update: n }), this.options[`${e}s`][t] = n, n) : this.options[`${e}s`][t]; }; }); } function di(t) { return t && (t.Ctor.options.name || t.tag); } function vi(t, e) { return Array.isArray(t) ? t.indexOf(e) > -1 : typeof t === 'string' ? t.split(',').indexOf(e) > -1 : !!l(t) && t.test(e); } function gi(t, e) { const n = t.cache; const i = t.keys; const r = t._vnode; for (const o in n) { const s = n[o]; if (s) { const a = di(s.componentOptions); a && !e(a) && yi(n, o, i, r); } } } function yi(t, e, n, i) { const r = t[e]; !r || i && r.tag === i.tag || r.componentInstance.$destroy(), t[e] = null, y(n, e); }ni(ai), wn(ai), je(ai), Ge(ai), ti(ai); const mi = [String, RegExp, Array]; const _i = {
        name: 'keep-alive', abstract: !0, props: { include: mi, exclude: mi, max: [String, Number] }, created() { this.cache = Object.create(null), this.keys = []; }, destroyed() { const t = this; for (const e in t.cache)yi(t.cache, e, t.keys); }, mounted() { const t = this; this.$watch('include', (e) => { gi(t, t => vi(e, t)); }), this.$watch('exclude', (e) => { gi(t, t => !vi(e, t)); }); }, render() { const t = this.$slots.default; const e = Ie(t); const n = e && e.componentOptions; if (n) { const i = di(n); const r = this; const o = r.include; const s = r.exclude; if (o && (!i || !vi(o, i)) || s && i && vi(s, i)) return e; const a = this; const u = a.cache; const c = a.keys; const h = e.key == null ? n.Ctor.cid + (n.tag ? `::${n.tag}` : '') : e.key; u[h] ? (e.componentInstance = u[h].componentInstance, y(c, h), c.push(h)) : (u[h] = e, c.push(h), this.max && c.length > parseInt(this.max) && yi(u, c[0], c, this._vnode)), e.data.keepAlive = !0; } return e || t && t[0]; },
      }; const bi = { KeepAlive: _i }; function wi(t) {
        const e = { get() { return V; } }; Object.defineProperty(t, 'config', e), t.util = {
          warn: ht, extend: P, mergeOptions: zt, defineReactive: Lt,
        }, t.set = At, t.delete = Ft, t.nextTick = he, t.options = Object.create(null), $.forEach((e) => { t.options[`${e}s`] = Object.create(null); }), t.options._base = t, P(t.options.components, bi), ui(t), ci(t), hi(t), pi(t);
      }wi(ai), Object.defineProperty(ai.prototype, '$isServer', { get: ot }), Object.defineProperty(ai.prototype, '$ssrContext', { get() { return this.$vnode && this.$vnode.ssrContext; } }), Object.defineProperty(ai, 'FunctionalRenderContext', { value: Nn }), ai.version = '2.5.17'; const xi = v('style,class'); const Ei = v('input,textarea,option,select,progress'); const Si = function (t, e, n) { return n === 'value' && Ei(t) && e !== 'button' || n === 'selected' && t === 'option' || n === 'checked' && t === 'input' || n === 'muted' && t === 'video'; }; const Ti = v('contenteditable,draggable,spellcheck'); const Oi = v('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible'); const Ci = 'http://www.w3.org/1999/xlink'; const Ri = function (t) { return t.charAt(5) === ':' && t.slice(0, 5) === 'xlink'; }; const Ii = function (t) { return Ri(t) ? t.slice(6, t.length) : ''; }; const Pi = function (t) { return t == null || !1 === t; }; function Li(t) { let e = t.data; let n = t; let i = t; while (r(i.componentInstance))i = i.componentInstance._vnode, i && i.data && (e = Ai(i.data, e)); while (r(n = n.parent))n && n.data && (e = Ai(e, n.data)); return Fi(e.staticClass, e.class); } function Ai(t, e) { return { staticClass: ji(t.staticClass, e.staticClass), class: r(t.class) ? [t.class, e.class] : e.class }; } function Fi(t, e) { return r(t) || r(e) ? ji(t, ki(e)) : ''; } function ji(t, e) { return t ? e ? `${t} ${e}` : t : e || ''; } function ki(t) { return Array.isArray(t) ? Mi(t) : u(t) ? Ni(t) : typeof t === 'string' ? t : ''; } function Mi(t) { for (var e, n = '', i = 0, o = t.length; i < o; i++)r(e = ki(t[i])) && e !== '' && (n && (n += ' '), n += e); return n; } function Ni(t) { let e = ''; for (const n in t)t[n] && (e && (e += ' '), e += n); return e; } const Di = { svg: 'http://www.w3.org/2000/svg', math: 'http://www.w3.org/1998/Math/MathML' }; const $i = v('html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot'); const Gi = v('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', !0); const Vi = function (t) { return $i(t) || Gi(t); }; function Bi(t) { return Gi(t) ? 'svg' : t === 'math' ? 'math' : void 0; } const Ui = Object.create(null); function zi(t) { if (!K) return !0; if (Vi(t)) return !1; if (t = t.toLowerCase(), Ui[t] != null) return Ui[t]; const e = document.createElement(t); return t.indexOf('-') > -1 ? Ui[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : Ui[t] = /HTMLUnknownElement/.test(e.toString()); } const Yi = v('text,number,password,search,email,tel,url'); function Xi(t) { if (typeof t === 'string') { const e = document.querySelector(t); return e || document.createElement('div'); } return t; } function Wi(t, e) { const n = document.createElement(t); return t !== 'select' ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute('multiple', 'multiple'), n); } function Ki(t, e) { return document.createElementNS(Di[t], e); } function Hi(t) { return document.createTextNode(t); } function qi(t) { return document.createComment(t); } function Zi(t, e, n) { t.insertBefore(e, n); } function Ji(t, e) { t.removeChild(e); } function Qi(t, e) { t.appendChild(e); } function tr(t) { return t.parentNode; } function er(t) { return t.nextSibling; } function nr(t) { return t.tagName; } function ir(t, e) { t.textContent = e; } function rr(t, e) { t.setAttribute(e, ''); } const or = Object.freeze({
        createElement: Wi, createElementNS: Ki, createTextNode: Hi, createComment: qi, insertBefore: Zi, removeChild: Ji, appendChild: Qi, parentNode: tr, nextSibling: er, tagName: nr, setTextContent: ir, setStyleScope: rr,
      }); const sr = { create(t, e) { ar(e); }, update(t, e) { t.data.ref !== e.data.ref && (ar(t, !0), ar(e)); }, destroy(t) { ar(t, !0); } }; function ar(t, e) { const n = t.data.ref; if (r(n)) { const i = t.context; const o = t.componentInstance || t.elm; const s = i.$refs; e ? Array.isArray(s[n]) ? y(s[n], o) : s[n] === o && (s[n] = void 0) : t.data.refInFor ? Array.isArray(s[n]) ? s[n].indexOf(o) < 0 && s[n].push(o) : s[n] = [o] : s[n] = o; } } const ur = new gt('', {}, []); const cr = ['create', 'activate', 'update', 'remove', 'destroy']; function hr(t, e) { return t.key === e.key && (t.tag === e.tag && t.isComment === e.isComment && r(t.data) === r(e.data) && lr(t, e) || o(t.isAsyncPlaceholder) && t.asyncFactory === e.asyncFactory && i(e.asyncFactory.error)); } function lr(t, e) { if (t.tag !== 'input') return !0; let n; const i = r(n = t.data) && r(n = n.attrs) && n.type; const o = r(n = e.data) && r(n = n.attrs) && n.type; return i === o || Yi(i) && Yi(o); } function fr(t, e, n) { let i; let o; const s = {}; for (i = e; i <= n; ++i)o = t[i].key, r(o) && (s[o] = i); return s; } function pr(t) { let e; let n; const s = {}; const u = t.modules; const c = t.nodeOps; for (e = 0; e < cr.length; ++e) for (s[cr[e]] = [], n = 0; n < u.length; ++n)r(u[n][cr[e]]) && s[cr[e]].push(u[n][cr[e]]); function h(t) { return new gt(c.tagName(t).toLowerCase(), {}, [], void 0, t); } function l(t, e) { function n() { --n.listeners === 0 && f(t); } return n.listeners = e, n; } function f(t) { const e = c.parentNode(t); r(e) && c.removeChild(e, t); } function p(t, e, n, i, s, a, u) { if (r(t.elm) && r(a) && (t = a[u] = bt(t)), t.isRootInsert = !s, !d(t, e, n, i)) { const h = t.data; const l = t.children; const f = t.tag; r(f) ? (t.elm = t.ns ? c.createElementNS(t.ns, f) : c.createElement(f, t), x(t), _(t, l, e), r(h) && w(t, e), m(n, t.elm, i)) : o(t.isComment) ? (t.elm = c.createComment(t.text), m(n, t.elm, i)) : (t.elm = c.createTextNode(t.text), m(n, t.elm, i)); } } function d(t, e, n, i) { let s = t.data; if (r(s)) { const a = r(t.componentInstance) && s.keepAlive; if (r(s = s.hook) && r(s = s.init) && s(t, !1, n, i), r(t.componentInstance)) return g(t, e), o(a) && y(t, e, n, i), !0; } } function g(t, e) { r(t.data.pendingInsert) && (e.push(...t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, b(t) ? (w(t, e), x(t)) : (ar(t), e.push(t)); } function y(t, e, n, i) { let o; let a = t; while (a.componentInstance) if (a = a.componentInstance._vnode, r(o = a.data) && r(o = o.transition)) { for (o = 0; o < s.activate.length; ++o)s.activate[o](ur, a); e.push(a); break; }m(n, t.elm, i); } function m(t, e, n) { r(t) && (r(n) ? n.parentNode === t && c.insertBefore(t, e, n) : c.appendChild(t, e)); } function _(t, e, n) { if (Array.isArray(e)) { 0; for (let i = 0; i < e.length; ++i)p(e[i], n, t.elm, null, !0, e, i); } else a(t.text) && c.appendChild(t.elm, c.createTextNode(String(t.text))); } function b(t) { while (t.componentInstance)t = t.componentInstance._vnode; return r(t.tag); } function w(t, n) { for (let i = 0; i < s.create.length; ++i)s.create[i](ur, t); e = t.data.hook, r(e) && (r(e.create) && e.create(ur, t), r(e.insert) && n.push(t)); } function x(t) { let e; if (r(e = t.fnScopeId))c.setStyleScope(t.elm, e); else { let n = t; while (n)r(e = n.context) && r(e = e.$options._scopeId) && c.setStyleScope(t.elm, e), n = n.parent; }r(e = De) && e !== t.context && e !== t.fnContext && r(e = e.$options._scopeId) && c.setStyleScope(t.elm, e); } function E(t, e, n, i, r, o) { for (;i <= r; ++i)p(n[i], o, t, e, !1, n, i); } function S(t) { let e; let n; const i = t.data; if (r(i)) for (r(e = i.hook) && r(e = e.destroy) && e(t), e = 0; e < s.destroy.length; ++e)s.destroy[e](t); if (r(e = t.children)) for (n = 0; n < t.children.length; ++n)S(t.children[n]); } function T(t, e, n, i) { for (;n <= i; ++n) { const o = e[n]; r(o) && (r(o.tag) ? (O(o), S(o)) : f(o.elm)); } } function O(t, e) { if (r(e) || r(t.data)) { let n; const i = s.remove.length + 1; for (r(e) ? e.listeners += i : e = l(t.elm, i), r(n = t.componentInstance) && r(n = n._vnode) && r(n.data) && O(n, e), n = 0; n < s.remove.length; ++n)s.remove[n](t, e); r(n = t.data.hook) && r(n = n.remove) ? n(t, e) : e(); } else f(t.elm); } function C(t, e, n, o, s) { let a; let u; let h; let l; let f = 0; let d = 0; let v = e.length - 1; let g = e[0]; let y = e[v]; let m = n.length - 1; let _ = n[0]; let b = n[m]; const w = !s; while (f <= v && d <= m)i(g) ? g = e[++f] : i(y) ? y = e[--v] : hr(g, _) ? (I(g, _, o), g = e[++f], _ = n[++d]) : hr(y, b) ? (I(y, b, o), y = e[--v], b = n[--m]) : hr(g, b) ? (I(g, b, o), w && c.insertBefore(t, g.elm, c.nextSibling(y.elm)), g = e[++f], b = n[--m]) : hr(y, _) ? (I(y, _, o), w && c.insertBefore(t, y.elm, g.elm), y = e[--v], _ = n[++d]) : (i(a) && (a = fr(e, f, v)), u = r(_.key) ? a[_.key] : R(_, e, f, v), i(u) ? p(_, o, t, g.elm, !1, n, d) : (h = e[u], hr(h, _) ? (I(h, _, o), e[u] = void 0, w && c.insertBefore(t, h.elm, g.elm)) : p(_, o, t, g.elm, !1, n, d)), _ = n[++d]); f > v ? (l = i(n[m + 1]) ? null : n[m + 1].elm, E(t, l, n, d, m, o)) : d > m && T(t, e, f, v); } function R(t, e, n, i) { for (let o = n; o < i; o++) { const s = e[o]; if (r(s) && hr(t, s)) return o; } } function I(t, e, n, a) { if (t !== e) { const u = e.elm = t.elm; if (o(t.isAsyncPlaceholder))r(e.asyncFactory.resolved) ? A(t.elm, e, n) : e.isAsyncPlaceholder = !0; else if (o(e.isStatic) && o(t.isStatic) && e.key === t.key && (o(e.isCloned) || o(e.isOnce)))e.componentInstance = t.componentInstance; else { let h; const l = e.data; r(l) && r(h = l.hook) && r(h = h.prepatch) && h(t, e); const f = t.children; const p = e.children; if (r(l) && b(e)) { for (h = 0; h < s.update.length; ++h)s.update[h](t, e); r(h = l.hook) && r(h = h.update) && h(t, e); }i(e.text) ? r(f) && r(p) ? f !== p && C(u, f, p, n, a) : r(p) ? (r(t.text) && c.setTextContent(u, ''), E(u, null, p, 0, p.length - 1, n)) : r(f) ? T(u, f, 0, f.length - 1) : r(t.text) && c.setTextContent(u, '') : t.text !== e.text && c.setTextContent(u, e.text), r(l) && r(h = l.hook) && r(h = h.postpatch) && h(t, e); } } } function P(t, e, n) { if (o(n) && r(t.parent))t.parent.data.pendingInsert = e; else for (let i = 0; i < e.length; ++i)e[i].data.hook.insert(e[i]); } const L = v('attrs,class,staticClass,staticStyle,key'); function A(t, e, n, i) { let s; const a = e.tag; const u = e.data; const c = e.children; if (i = i || u && u.pre, e.elm = t, o(e.isComment) && r(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0; if (r(u) && (r(s = u.hook) && r(s = s.init) && s(e, !0), r(s = e.componentInstance))) return g(e, n), !0; if (r(a)) { if (r(c)) if (t.hasChildNodes()) if (r(s = u) && r(s = s.domProps) && r(s = s.innerHTML)) { if (s !== t.innerHTML) return !1; } else { for (var h = !0, l = t.firstChild, f = 0; f < c.length; f++) { if (!l || !A(l, c[f], n, i)) { h = !1; break; }l = l.nextSibling; } if (!h || l) return !1; } else _(e, c, n); if (r(u)) { let p = !1; for (const d in u) if (!L(d)) { p = !0, w(e, n); break; }!p && u.class && fe(u.class); } } else t.data !== e.text && (t.data = e.text); return !0; } return function (t, e, n, a, u, l) { if (!i(e)) { let f = !1; const d = []; if (i(t))f = !0, p(e, d, u, l); else { const v = r(t.nodeType); if (!v && hr(t, e))I(t, e, d, a); else { if (v) { if (t.nodeType === 1 && t.hasAttribute(D) && (t.removeAttribute(D), n = !0), o(n) && A(t, e, d)) return P(e, d, !0), t; t = h(t); } const g = t.elm; const y = c.parentNode(g); if (p(e, d, g._leaveCb ? null : y, c.nextSibling(g)), r(e.parent)) { let m = e.parent; const _ = b(e); while (m) { for (let w = 0; w < s.destroy.length; ++w)s.destroy[w](m); if (m.elm = e.elm, _) { for (let x = 0; x < s.create.length; ++x)s.create[x](ur, m); const E = m.data.hook.insert; if (E.merged) for (let O = 1; O < E.fns.length; O++)E.fns[O](); } else ar(m); m = m.parent; } }r(y) ? T(y, [t], 0, 0) : r(t.tag) && S(t); } } return P(e, d, f), e.elm; }r(t) && S(t); }; } const dr = { create: vr, update: vr, destroy(t) { vr(t, ur); } }; function vr(t, e) { (t.data.directives || e.data.directives) && gr(t, e); } function gr(t, e) { let n; let i; let r; const o = t === ur; const s = e === ur; const a = mr(t.data.directives, t.context); const u = mr(e.data.directives, e.context); const c = []; const h = []; for (n in u)i = a[n], r = u[n], i ? (r.oldValue = i.value, br(r, 'update', e, t), r.def && r.def.componentUpdated && h.push(r)) : (br(r, 'bind', e, t), r.def && r.def.inserted && c.push(r)); if (c.length) { const l = function () { for (let n = 0; n < c.length; n++)br(c[n], 'inserted', e, t); }; o ? me(e, 'insert', l) : l(); } if (h.length && me(e, 'postpatch', () => { for (let n = 0; n < h.length; n++)br(h[n], 'componentUpdated', e, t); }), !o) for (n in a)u[n] || br(a[n], 'unbind', t, t, s); } const yr = Object.create(null); function mr(t, e) { let n; let i; const r = Object.create(null); if (!t) return r; for (n = 0; n < t.length; n++)i = t[n], i.modifiers || (i.modifiers = yr), r[_r(i)] = i, i.def = Yt(e.$options, 'directives', i.name, !0); return r; } function _r(t) { return t.rawName || `${t.name}.${Object.keys(t.modifiers || {}).join('.')}`; } function br(t, e, n, i, r) { const o = t.def && t.def[e]; if (o) try { o(n.elm, t, n, i, r); } catch (ts) { Zt(ts, n.context, `directive ${t.name} ${e} hook`); } } const wr = [sr, dr]; function xr(t, e) { const n = e.componentOptions; if ((!r(n) || !1 !== n.Ctor.options.inheritAttrs) && (!i(t.data.attrs) || !i(e.data.attrs))) { let o; let s; let a; const u = e.elm; const c = t.data.attrs || {}; let h = e.data.attrs || {}; for (o in r(h.__ob__) && (h = e.data.attrs = P({}, h)), h)s = h[o], a = c[o], a !== s && Er(u, o, s); for (o in (J || tt) && h.value !== c.value && Er(u, 'value', h.value), c)i(h[o]) && (Ri(o) ? u.removeAttributeNS(Ci, Ii(o)) : Ti(o) || u.removeAttribute(o)); } } function Er(t, e, n) { t.tagName.indexOf('-') > -1 ? Sr(t, e, n) : Oi(e) ? Pi(n) ? t.removeAttribute(e) : (n = e === 'allowfullscreen' && t.tagName === 'EMBED' ? 'true' : e, t.setAttribute(e, n)) : Ti(e) ? t.setAttribute(e, Pi(n) || n === 'false' ? 'false' : 'true') : Ri(e) ? Pi(n) ? t.removeAttributeNS(Ci, Ii(e)) : t.setAttributeNS(Ci, e, n) : Sr(t, e, n); } function Sr(t, e, n) { if (Pi(n))t.removeAttribute(e); else { if (J && !Q && t.tagName === 'TEXTAREA' && e === 'placeholder' && !t.__ieph) { var i = function (e) { e.stopImmediatePropagation(), t.removeEventListener('input', i); }; t.addEventListener('input', i), t.__ieph = !0; }t.setAttribute(e, n); } } const Tr = { create: xr, update: xr }; function Or(t, e) { const n = e.elm; const o = e.data; const s = t.data; if (!(i(o.staticClass) && i(o.class) && (i(s) || i(s.staticClass) && i(s.class)))) { let a = Li(e); const u = n._transitionClasses; r(u) && (a = ji(a, ki(u))), a !== n._prevClass && (n.setAttribute('class', a), n._prevClass = a); } } let Cr; const Rr = { create: Or, update: Or }; const Ir = '__r'; const Pr = '__c'; function Lr(t) { if (r(t[Ir])) { const e = J ? 'change' : 'input'; t[e] = [].concat(t[Ir], t[e] || []), delete t[Ir]; }r(t[Pr]) && (t.change = [].concat(t[Pr], t.change || []), delete t[Pr]); } function Ar(t, e, n) { const i = Cr; return function r() { const o = t(...arguments); o !== null && jr(e, r, n, i); }; } function Fr(t, e, n, i, r) { e = ce(e), n && (e = Ar(e, t, i)), Cr.addEventListener(t, e, it ? { capture: i, passive: r } : i); } function jr(t, e, n, i) { (i || Cr).removeEventListener(t, e._withTask || e, n); } function kr(t, e) { if (!i(t.data.on) || !i(e.data.on)) { const n = e.data.on || {}; const r = t.data.on || {}; Cr = e.elm, Lr(n), ye(n, r, Fr, jr, e.context), Cr = void 0; } } const Mr = { create: kr, update: kr }; function Nr(t, e) { if (!i(t.data.domProps) || !i(e.data.domProps)) { let n; let o; const s = e.elm; const a = t.data.domProps || {}; let u = e.data.domProps || {}; for (n in r(u.__ob__) && (u = e.data.domProps = P({}, u)), a)i(u[n]) && (s[n] = ''); for (n in u) { if (o = u[n], n === 'textContent' || n === 'innerHTML') { if (e.children && (e.children.length = 0), o === a[n]) continue; s.childNodes.length === 1 && s.removeChild(s.childNodes[0]); } if (n === 'value') { s._value = o; const c = i(o) ? '' : String(o); Dr(s, c) && (s.value = c); } else s[n] = o; } } } function Dr(t, e) { return !t.composing && (t.tagName === 'OPTION' || $r(t, e) || Gr(t, e)); } function $r(t, e) { let n = !0; try { n = document.activeElement !== t; } catch (ts) {} return n && t.value !== e; } function Gr(t, e) { const n = t.value; const i = t._vModifiers; if (r(i)) { if (i.lazy) return !1; if (i.number) return d(n) !== d(e); if (i.trim) return n.trim() !== e.trim(); } return n !== e; } const Vr = { create: Nr, update: Nr }; const Br = b((t) => { const e = {}; const n = /;(?![^(]*\))/g; const i = /:(.+)/; return t.split(n).forEach((t) => { if (t) { const n = t.split(i); n.length > 1 && (e[n[0].trim()] = n[1].trim()); } }), e; }); function Ur(t) { const e = zr(t.style); return t.staticStyle ? P(t.staticStyle, e) : e; } function zr(t) { return Array.isArray(t) ? L(t) : typeof t === 'string' ? Br(t) : t; } function Yr(t, e) { let n; const i = {}; if (e) { let r = t; while (r.componentInstance)r = r.componentInstance._vnode, r && r.data && (n = Ur(r.data)) && P(i, n); }(n = Ur(t.data)) && P(i, n); let o = t; while (o = o.parent)o.data && (n = Ur(o.data)) && P(i, n); return i; } let Xr; const Wr = /^--/; const Kr = /\s*!important$/; const Hr = function (t, e, n) { if (Wr.test(e))t.style.setProperty(e, n); else if (Kr.test(n))t.style.setProperty(e, n.replace(Kr, ''), 'important'); else { const i = Zr(e); if (Array.isArray(n)) for (let r = 0, o = n.length; r < o; r++)t.style[i] = n[r]; else t.style[i] = n; } }; const qr = ['Webkit', 'Moz', 'ms']; var Zr = b((t) => { if (Xr = Xr || document.createElement('div').style, t = x(t), t !== 'filter' && t in Xr) return t; for (let e = t.charAt(0).toUpperCase() + t.slice(1), n = 0; n < qr.length; n++) { const i = qr[n] + e; if (i in Xr) return i; } }); function Jr(t, e) { const n = e.data; const o = t.data; if (!(i(n.staticStyle) && i(n.style) && i(o.staticStyle) && i(o.style))) { let s; let a; const u = e.elm; const c = o.staticStyle; const h = o.normalizedStyle || o.style || {}; const l = c || h; const f = zr(e.data.style) || {}; e.data.normalizedStyle = r(f.__ob__) ? P({}, f) : f; const p = Yr(e, !0); for (a in l)i(p[a]) && Hr(u, a, ''); for (a in p)s = p[a], s !== l[a] && Hr(u, a, s == null ? '' : s); } } const Qr = { create: Jr, update: Jr }; function to(t, e) { if (e && (e = e.trim())) if (t.classList)e.indexOf(' ') > -1 ? e.split(/\s+/).forEach(e => t.classList.add(e)) : t.classList.add(e); else { const n = ` ${t.getAttribute('class') || ''} `; n.indexOf(` ${e} `) < 0 && t.setAttribute('class', (n + e).trim()); } } function eo(t, e) { if (e && (e = e.trim())) if (t.classList)e.indexOf(' ') > -1 ? e.split(/\s+/).forEach(e => t.classList.remove(e)) : t.classList.remove(e), t.classList.length || t.removeAttribute('class'); else { let n = ` ${t.getAttribute('class') || ''} `; const i = ` ${e} `; while (n.indexOf(i) >= 0)n = n.replace(i, ' '); n = n.trim(), n ? t.setAttribute('class', n) : t.removeAttribute('class'); } } function no(t) { if (t) { if (typeof t === 'object') { const e = {}; return !1 !== t.css && P(e, io(t.name || 'v')), P(e, t), e; } return typeof t === 'string' ? io(t) : void 0; } } var io = b(t => ({
        enterClass: `${t}-enter`, enterToClass: `${t}-enter-to`, enterActiveClass: `${t}-enter-active`, leaveClass: `${t}-leave`, leaveToClass: `${t}-leave-to`, leaveActiveClass: `${t}-leave-active`,
      })); const ro = K && !Q; const oo = 'transition'; const so = 'animation'; let ao = 'transition'; let uo = 'transitionend'; let co = 'animation'; let ho = 'animationend'; ro && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (ao = 'WebkitTransition', uo = 'webkitTransitionEnd'), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (co = 'WebkitAnimation', ho = 'webkitAnimationEnd')); const lo = K ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (t) { return t(); }; function fo(t) { lo(() => { lo(t); }); } function po(t, e) { const n = t._transitionClasses || (t._transitionClasses = []); n.indexOf(e) < 0 && (n.push(e), to(t, e)); } function vo(t, e) { t._transitionClasses && y(t._transitionClasses, e), eo(t, e); } function go(t, e, n) { const i = mo(t, e); const r = i.type; const o = i.timeout; const s = i.propCount; if (!r) return n(); const a = r === oo ? uo : ho; let u = 0; const c = function () { t.removeEventListener(a, h), n(); }; var h = function (e) { e.target === t && ++u >= s && c(); }; setTimeout(() => { u < s && c(); }, o + 1), t.addEventListener(a, h); } const yo = /\b(transform|all)(,|$)/; function mo(t, e) {
        let n; const i = window.getComputedStyle(t); const r = i[`${ao}Delay`].split(', '); const o = i[`${ao}Duration`].split(', '); const s = _o(r, o); const a = i[`${co}Delay`].split(', '); const u = i[`${co}Duration`].split(', '); const c = _o(a, u); let h = 0; let l = 0; e === oo ? s > 0 && (n = oo, h = s, l = o.length) : e === so ? c > 0 && (n = so, h = c, l = u.length) : (h = Math.max(s, c), n = h > 0 ? s > c ? oo : so : null, l = n ? n === oo ? o.length : u.length : 0); const f = n === oo && yo.test(i[`${ao}Property`]); return {
          type: n, timeout: h, propCount: l, hasTransform: f,
        };
      } function _o(t, e) { while (t.length < e.length)t = t.concat(t); return Math.max.apply(null, e.map((e, n) => bo(e) + bo(t[n]))); } function bo(t) { return 1e3 * Number(t.slice(0, -1)); } function wo(t, e) { const n = t.elm; r(n._leaveCb) && (n._leaveCb.cancelled = !0, n._leaveCb()); const o = no(t.data.transition); if (!i(o) && !r(n._enterCb) && n.nodeType === 1) { const s = o.css; const a = o.type; const c = o.enterClass; const h = o.enterToClass; const l = o.enterActiveClass; const f = o.appearClass; const p = o.appearToClass; const v = o.appearActiveClass; const g = o.beforeEnter; const y = o.enter; const m = o.afterEnter; const _ = o.enterCancelled; const b = o.beforeAppear; const w = o.appear; const x = o.afterAppear; const E = o.appearCancelled; const S = o.duration; let T = De; let O = De.$vnode; while (O && O.parent)O = O.parent, T = O.context; const C = !T._isMounted || !t.isRootInsert; if (!C || w || w === '') { const R = C && f ? f : c; const I = C && v ? v : l; const P = C && p ? p : h; const L = C && b || g; const A = C && typeof w === 'function' ? w : y; const F = C && x || m; const j = C && E || _; const k = d(u(S) ? S.enter : S); 0; const M = !1 !== s && !Q; const D = So(A); var $ = n._enterCb = N(() => { M && (vo(n, P), vo(n, I)), $.cancelled ? (M && vo(n, R), j && j(n)) : F && F(n), n._enterCb = null; }); t.data.show || me(t, 'insert', () => { const e = n.parentNode; const i = e && e._pending && e._pending[t.key]; i && i.tag === t.tag && i.elm._leaveCb && i.elm._leaveCb(), A && A(n, $); }), L && L(n), M && (po(n, R), po(n, I), fo(() => { vo(n, R), $.cancelled || (po(n, P), D || (Eo(k) ? setTimeout($, k) : go(n, a, $))); })), t.data.show && (e && e(), A && A(n, $)), M || D || $(); } } } function xo(t, e) { const n = t.elm; r(n._enterCb) && (n._enterCb.cancelled = !0, n._enterCb()); const o = no(t.data.transition); if (i(o) || n.nodeType !== 1) return e(); if (!r(n._leaveCb)) { const s = o.css; var a = o.type; var c = o.leaveClass; var h = o.leaveToClass; var l = o.leaveActiveClass; var f = o.beforeLeave; var p = o.leave; const v = o.afterLeave; const g = o.leaveCancelled; const y = o.delayLeave; const m = o.duration; var _ = !1 !== s && !Q; var b = So(p); var w = d(u(m) ? m.leave : m); 0; var x = n._leaveCb = N(() => { n.parentNode && n.parentNode._pending && (n.parentNode._pending[t.key] = null), _ && (vo(n, h), vo(n, l)), x.cancelled ? (_ && vo(n, c), g && g(n)) : (e(), v && v(n)), n._leaveCb = null; }); y ? y(E) : E(); } function E() { x.cancelled || (t.data.show || ((n.parentNode._pending || (n.parentNode._pending = {}))[t.key] = t), f && f(n), _ && (po(n, c), po(n, l), fo(() => { vo(n, c), x.cancelled || (po(n, h), b || (Eo(w) ? setTimeout(x, w) : go(n, a, x))); })), p && p(n, x), _ || b || x()); } } function Eo(t) { return typeof t === 'number' && !isNaN(t); } function So(t) { if (i(t)) return !1; const e = t.fns; return r(e) ? So(Array.isArray(e) ? e[0] : e) : (t._length || t.length) > 1; } function To(t, e) { !0 !== e.data.show && wo(e); } const Oo = K ? { create: To, activate: To, remove(t, e) { !0 !== t.data.show ? xo(t, e) : e(); } } : {}; const Co = [Tr, Rr, Mr, Vr, Qr, Oo]; const Ro = Co.concat(wr); const Io = pr({ nodeOps: or, modules: Ro }); Q && document.addEventListener('selectionchange', () => { const t = document.activeElement; t && t.vmodel && No(t, 'input'); }); var Po = { inserted(t, e, n, i) { n.tag === 'select' ? (i.elm && !i.elm._vOptions ? me(n, 'postpatch', () => { Po.componentUpdated(t, e, n); }) : Lo(t, e, n.context), t._vOptions = [].map.call(t.options, jo)) : (n.tag === 'textarea' || Yi(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener('compositionstart', ko), t.addEventListener('compositionend', Mo), t.addEventListener('change', Mo), Q && (t.vmodel = !0))); }, componentUpdated(t, e, n) { if (n.tag === 'select') { Lo(t, e, n.context); const i = t._vOptions; const r = t._vOptions = [].map.call(t.options, jo); if (r.some((t, e) => !k(t, i[e]))) { const o = t.multiple ? e.value.some(t => Fo(t, r)) : e.value !== e.oldValue && Fo(e.value, r); o && No(t, 'change'); } } } }; function Lo(t, e, n) { Ao(t, e, n), (J || tt) && setTimeout(() => { Ao(t, e, n); }, 0); } function Ao(t, e, n) { const i = e.value; const r = t.multiple; if (!r || Array.isArray(i)) { for (var o, s, a = 0, u = t.options.length; a < u; a++) if (s = t.options[a], r)o = M(i, jo(s)) > -1, s.selected !== o && (s.selected = o); else if (k(jo(s), i)) return void (t.selectedIndex !== a && (t.selectedIndex = a)); r || (t.selectedIndex = -1); } } function Fo(t, e) { return e.every(e => !k(e, t)); } function jo(t) { return '_value' in t ? t._value : t.value; } function ko(t) { t.target.composing = !0; } function Mo(t) { t.target.composing && (t.target.composing = !1, No(t.target, 'input')); } function No(t, e) { const n = document.createEvent('HTMLEvents'); n.initEvent(e, !0, !0), t.dispatchEvent(n); } function Do(t) { return !t.componentInstance || t.data && t.data.transition ? t : Do(t.componentInstance._vnode); } const $o = { bind(t, e, n) { const i = e.value; n = Do(n); const r = n.data && n.data.transition; const o = t.__vOriginalDisplay = t.style.display === 'none' ? '' : t.style.display; i && r ? (n.data.show = !0, wo(n, () => { t.style.display = o; })) : t.style.display = i ? o : 'none'; }, update(t, e, n) { const i = e.value; const r = e.oldValue; if (!i !== !r) { n = Do(n); const o = n.data && n.data.transition; o ? (n.data.show = !0, i ? wo(n, () => { t.style.display = t.__vOriginalDisplay; }) : xo(n, () => { t.style.display = 'none'; })) : t.style.display = i ? t.__vOriginalDisplay : 'none'; } }, unbind(t, e, n, i, r) { r || (t.style.display = t.__vOriginalDisplay); } }; const Go = { model: Po, show: $o }; const Vo = {
        name: String, appear: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass: String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object],
      }; function Bo(t) { const e = t && t.componentOptions; return e && e.Ctor.options.abstract ? Bo(Ie(e.children)) : t; } function Uo(t) { const e = {}; const n = t.$options; for (const i in n.propsData)e[i] = t[i]; const r = n._parentListeners; for (const o in r)e[x(o)] = r[o]; return e; } function zo(t, e) { if (/\d-keep-alive$/.test(e.tag)) return t('keep-alive', { props: e.componentOptions.propsData }); } function Yo(t) { while (t = t.parent) if (t.data.transition) return !0; } function Xo(t, e) { return e.key === t.key && e.tag === t.tag; } const Wo = {
        name: 'transition', props: Vo, abstract: !0, render(t) { const e = this; let n = this.$slots.default; if (n && (n = n.filter(t => t.tag || Re(t)), n.length)) { 0; const i = this.mode; 0; const r = n[0]; if (Yo(this.$vnode)) return r; const o = Bo(r); if (!o) return r; if (this._leaving) return zo(t, r); const s = `__transition-${this._uid}-`; o.key = o.key == null ? o.isComment ? `${s}comment` : s + o.tag : a(o.key) ? String(o.key).indexOf(s) === 0 ? o.key : s + o.key : o.key; const u = (o.data || (o.data = {})).transition = Uo(this); const c = this._vnode; const h = Bo(c); if (o.data.directives && o.data.directives.some(t => t.name === 'show') && (o.data.show = !0), h && h.data && !Xo(o, h) && !Re(h) && (!h.componentInstance || !h.componentInstance._vnode.isComment)) { const l = h.data.transition = P({}, u); if (i === 'out-in') return this._leaving = !0, me(l, 'afterLeave', () => { e._leaving = !1, e.$forceUpdate(); }), zo(t, r); if (i === 'in-out') { if (Re(o)) return c; let f; const p = function () { f(); }; me(u, 'afterEnter', p), me(u, 'enterCancelled', p), me(l, 'delayLeave', (t) => { f = t; }); } } return r; } },
      }; const Ko = P({ tag: String, moveClass: String }, Vo); delete Ko.mode; const Ho = {
        props: Ko, render(t) { for (var e = this.tag || this.$vnode.data.tag || 'span', n = Object.create(null), i = this.prevChildren = this.children, r = this.$slots.default || [], o = this.children = [], s = Uo(this), a = 0; a < r.length; a++) { const u = r[a]; if (u.tag) if (u.key != null && String(u.key).indexOf('__vlist') !== 0)o.push(u), n[u.key] = u, (u.data || (u.data = {})).transition = s; else; } if (i) { for (var c = [], h = [], l = 0; l < i.length; l++) { const f = i[l]; f.data.transition = s, f.data.pos = f.elm.getBoundingClientRect(), n[f.key] ? c.push(f) : h.push(f); } this.kept = t(e, null, c), this.removed = h; } return t(e, null, o); }, beforeUpdate() { this.__patch__(this._vnode, this.kept, !1, !0), this._vnode = this.kept; }, updated() { const t = this.prevChildren; const e = this.moveClass || `${this.name || 'v'}-move`; t.length && this.hasMove(t[0].elm, e) && (t.forEach(qo), t.forEach(Zo), t.forEach(Jo), this._reflow = document.body.offsetHeight, t.forEach((t) => { if (t.data.moved) { const n = t.elm; const i = n.style; po(n, e), i.transform = i.WebkitTransform = i.transitionDuration = '', n.addEventListener(uo, n._moveCb = function t(i) { i && !/transform$/.test(i.propertyName) || (n.removeEventListener(uo, t), n._moveCb = null, vo(n, e)); }); } })); }, methods: { hasMove(t, e) { if (!ro) return !1; if (this._hasMove) return this._hasMove; const n = t.cloneNode(); t._transitionClasses && t._transitionClasses.forEach((t) => { eo(n, t); }), to(n, e), n.style.display = 'none', this.$el.appendChild(n); const i = mo(n); return this.$el.removeChild(n), this._hasMove = i.hasTransform; } },
      }; function qo(t) { t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb(); } function Zo(t) { t.data.newPos = t.elm.getBoundingClientRect(); } function Jo(t) { const e = t.data.pos; const n = t.data.newPos; const i = e.left - n.left; const r = e.top - n.top; if (i || r) { t.data.moved = !0; const o = t.elm.style; o.transform = o.WebkitTransform = `translate(${i}px,${r}px)`, o.transitionDuration = '0s'; } } const Qo = { Transition: Wo, TransitionGroup: Ho }; ai.config.mustUseProp = Si, ai.config.isReservedTag = Vi, ai.config.isReservedAttr = xi, ai.config.getTagNamespace = Bi, ai.config.isUnknownElement = zi, P(ai.options.directives, Go), P(ai.options.components, Qo), ai.prototype.__patch__ = K ? Io : A, ai.prototype.$mount = function (t, e) { return t = t && K ? Xi(t) : void 0, Ve(this, t, e); }, K && setTimeout(() => { V.devtools && st && st.emit('init', ai); }, 0), e.a = ai;
    }).call(this, n('c8ba'));
  },
  '2b4c': function (t, e, n) { const i = n('5537')('wks'); const r = n('ca5a'); const o = n('7726').Symbol; const s = typeof o === 'function'; const a = t.exports = function (t) { return i[t] || (i[t] = s && o[t] || (s ? o : r)(`Symbol.${t}`)); }; a.store = i; },
  '2b69': function (t, e, n) {},
  '2d00': function (t, e) { t.exports = !1; },
  '2d7d': function (t, e, n) { t.exports = n('5037'); },
  '2d83': function (t, e, n) {
    const i = n('387f'); t.exports = function (t, e, n, r, o) { const s = new Error(t); return i(s, e, n, r, o); };
  },
  '2d95': function (t, e) { const n = {}.toString; t.exports = function (t) { return n.call(t).slice(8, -1); }; },
  '2e67': function (t, e, n) {
    t.exports = function (t) { return !(!t || !t.__CANCEL__); };
  },
  '2f62': function (t, e, n) {
    n.d(e, 'c', () => I), n.d(e, 'b', () => A);
    /**
 * vuex v3.0.1
 * (c) 2017 Evan You
 * @license MIT
 */
    const i = function (t) { const e = Number(t.version.split('.')[0]); if (e >= 2)t.mixin({ beforeCreate: i }); else { const n = t.prototype._init; t.prototype._init = function (t) { void 0 === t && (t = {}), t.init = t.init ? [i].concat(t.init) : i, n.call(this, t); }; } function i() { const t = this.$options; t.store ? this.$store = typeof t.store === 'function' ? t.store() : t.store : t.parent && t.parent.$store && (this.$store = t.parent.$store); } }; const r = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function o(t) { r && (t._devtoolHook = r, r.emit('vuex:init', t), r.on('vuex:travel-to-state', (e) => { t.replaceState(e); }), t.subscribe((t, e) => { r.emit('vuex:mutation', t, e); })); } function s(t, e) { Object.keys(t).forEach(n => e(t[n], n)); } function a(t) { return t !== null && typeof t === 'object'; } function u(t) { return t && typeof t.then === 'function'; } const c = function (t, e) { this.runtime = e, this._children = Object.create(null), this._rawModule = t; const n = t.state; this.state = (typeof n === 'function' ? n() : n) || {}; }; const h = { namespaced: { configurable: !0 } }; h.namespaced.get = function () { return !!this._rawModule.namespaced; }, c.prototype.addChild = function (t, e) { this._children[t] = e; }, c.prototype.removeChild = function (t) { delete this._children[t]; }, c.prototype.getChild = function (t) { return this._children[t]; }, c.prototype.update = function (t) { this._rawModule.namespaced = t.namespaced, t.actions && (this._rawModule.actions = t.actions), t.mutations && (this._rawModule.mutations = t.mutations), t.getters && (this._rawModule.getters = t.getters); }, c.prototype.forEachChild = function (t) { s(this._children, t); }, c.prototype.forEachGetter = function (t) { this._rawModule.getters && s(this._rawModule.getters, t); }, c.prototype.forEachAction = function (t) { this._rawModule.actions && s(this._rawModule.actions, t); }, c.prototype.forEachMutation = function (t) { this._rawModule.mutations && s(this._rawModule.mutations, t); }, Object.defineProperties(c.prototype, h); const l = function (t) { this.register([], t, !1); }; function f(t, e, n) { if (e.update(n), n.modules) for (const i in n.modules) { if (!e.getChild(i)) return void 0; f(t.concat(i), e.getChild(i), n.modules[i]); } }l.prototype.get = function (t) { return t.reduce((t, e) => t.getChild(e), this.root); }, l.prototype.getNamespace = function (t) { let e = this.root; return t.reduce((t, n) => e = e.getChild(n), t + (e.namespaced ? `${n}/` : ''), ''); }, l.prototype.update = function (t) { f([], this.root, t); }, l.prototype.register = function (t, e, n) { const i = this; void 0 === n && (n = !0); const r = new c(e, n); if (t.length === 0) this.root = r; else { const o = this.get(t.slice(0, -1)); o.addChild(t[t.length - 1], r); }e.modules && s(e.modules, (e, r) => { i.register(t.concat(r), e, n); }); }, l.prototype.unregister = function (t) { const e = this.get(t.slice(0, -1)); const n = t[t.length - 1]; e.getChild(n).runtime && e.removeChild(n); }; let p; const d = function (t) { const e = this; void 0 === t && (t = {}), !p && typeof window !== 'undefined' && window.Vue && R(window.Vue); let n = t.plugins; void 0 === n && (n = []); let i = t.strict; void 0 === i && (i = !1); let r = t.state; void 0 === r && (r = {}), typeof r === 'function' && (r = r() || {}), this._committing = !1, this._actions = Object.create(null), this._actionSubscribers = [], this._mutations = Object.create(null), this._wrappedGetters = Object.create(null), this._modules = new l(t), this._modulesNamespaceMap = Object.create(null), this._subscribers = [], this._watcherVM = new p(); const s = this; const a = this; const u = a.dispatch; const c = a.commit; this.dispatch = function (t, e) { return u.call(s, t, e); }, this.commit = function (t, e, n) { return c.call(s, t, e, n); }, this.strict = i, _(this, r, [], this._modules.root), m(this, r), n.forEach(t => t(e)), p.config.devtools && o(this); }; const v = { state: { configurable: !0 } }; function g(t, e) { return e.indexOf(t) < 0 && e.push(t), function () { const n = e.indexOf(t); n > -1 && e.splice(n, 1); }; } function y(t, e) { t._actions = Object.create(null), t._mutations = Object.create(null), t._wrappedGetters = Object.create(null), t._modulesNamespaceMap = Object.create(null); const n = t.state; _(t, n, [], t._modules.root, !0), m(t, n, e); } function m(t, e, n) { const i = t._vm; t.getters = {}; const r = t._wrappedGetters; const o = {}; s(r, (e, n) => { o[n] = function () { return e(t); }, Object.defineProperty(t.getters, n, { get() { return t._vm[n]; }, enumerable: !0 }); }); const a = p.config.silent; p.config.silent = !0, t._vm = new p({ data: { $$state: e }, computed: o }), p.config.silent = a, t.strict && T(t), i && (n && t._withCommit(() => { i._data.$$state = null; }), p.nextTick(() => i.$destroy())); } function _(t, e, n, i, r) { const o = !n.length; const s = t._modules.getNamespace(n); if (i.namespaced && (t._modulesNamespaceMap[s] = i), !o && !r) { const a = O(e, n.slice(0, -1)); const u = n[n.length - 1]; t._withCommit(() => { p.set(a, u, i.state); }); } const c = i.context = b(t, s, n); i.forEachMutation((e, n) => { const i = s + n; x(t, i, e, c); }), i.forEachAction((e, n) => { const i = e.root ? n : s + n; const r = e.handler || e; E(t, i, r, c); }), i.forEachGetter((e, n) => { const i = s + n; S(t, i, e, c); }), i.forEachChild((i, o) => { _(t, e, n.concat(o), i, r); }); } function b(t, e, n) { const i = e === ''; const r = { dispatch: i ? t.dispatch : function (n, i, r) { const o = C(n, i, r); const s = o.payload; const a = o.options; let u = o.type; return a && a.root || (u = e + u), t.dispatch(u, s); }, commit: i ? t.commit : function (n, i, r) { const o = C(n, i, r); const s = o.payload; const a = o.options; let u = o.type; a && a.root || (u = e + u), t.commit(u, s, a); } }; return Object.defineProperties(r, { getters: { get: i ? function () { return t.getters; } : function () { return w(t, e); } }, state: { get() { return O(t.state, n); } } }), r; } function w(t, e) { const n = {}; const i = e.length; return Object.keys(t.getters).forEach((r) => { if (r.slice(0, i) === e) { const o = r.slice(i); Object.defineProperty(n, o, { get() { return t.getters[r]; }, enumerable: !0 }); } }), n; } function x(t, e, n, i) { const r = t._mutations[e] || (t._mutations[e] = []); r.push((e) => { n.call(t, i.state, e); }); } function E(t, e, n, i) {
      const r = t._actions[e] || (t._actions[e] = []); r.push((e, r) => {
        let o = n.call(t, {
          dispatch: i.dispatch, commit: i.commit, getters: i.getters, state: i.state, rootGetters: t.getters, rootState: t.state,
        }, e, r); return u(o) || (o = Promise.resolve(o)), t._devtoolHook ? o.catch((e) => { throw t._devtoolHook.emit('vuex:error', e), e; }) : o;
      });
    } function S(t, e, n, i) { t._wrappedGetters[e] || (t._wrappedGetters[e] = function (t) { return n(i.state, i.getters, t.state, t.getters); }); } function T(t) { t._vm.$watch(function () { return this._data.$$state; }, () => { 0; }, { deep: !0, sync: !0 }); } function O(t, e) { return e.length ? e.reduce((t, e) => t[e], t) : t; } function C(t, e, n) { return a(t) && t.type && (n = e, e = t, t = t.type), { type: t, payload: e, options: n }; } function R(t) { p && t === p || (p = t, i(p)); }v.state.get = function () { return this._vm._data.$$state; }, v.state.set = function (t) { 0; }, d.prototype.commit = function (t, e, n) { const i = this; const r = C(t, e, n); const o = r.type; const s = r.payload; const a = (r.options, { type: o, payload: s }); const u = this._mutations[o]; u && (this._withCommit(() => { u.forEach((t) => { t(s); }); }), this._subscribers.forEach(t => t(a, i.state))); }, d.prototype.dispatch = function (t, e) { const n = this; const i = C(t, e); const r = i.type; const o = i.payload; const s = { type: r, payload: o }; const a = this._actions[r]; if (a) return this._actionSubscribers.forEach(t => t(s, n.state)), a.length > 1 ? Promise.all(a.map(t => t(o))) : a[0](o); }, d.prototype.subscribe = function (t) { return g(t, this._subscribers); }, d.prototype.subscribeAction = function (t) { return g(t, this._actionSubscribers); }, d.prototype.watch = function (t, e, n) { const i = this; return this._watcherVM.$watch(() => t(i.state, i.getters), e, n); }, d.prototype.replaceState = function (t) { const e = this; this._withCommit(() => { e._vm._data.$$state = t; }); }, d.prototype.registerModule = function (t, e, n) { void 0 === n && (n = {}), typeof t === 'string' && (t = [t]), this._modules.register(t, e), _(this, this.state, t, this._modules.get(t), n.preserveState), m(this, this.state); }, d.prototype.unregisterModule = function (t) { const e = this; typeof t === 'string' && (t = [t]), this._modules.unregister(t), this._withCommit(() => { const n = O(e.state, t.slice(0, -1)); p.delete(n, t[t.length - 1]); }), y(this); }, d.prototype.hotUpdate = function (t) { this._modules.update(t), y(this, !0); }, d.prototype._withCommit = function (t) { const e = this._committing; this._committing = !0, t(), this._committing = e; }, Object.defineProperties(d.prototype, v); var I = k((t, e) => { const n = {}; return j(e).forEach((e) => { const i = e.key; const r = e.val; n[i] = function () { let e = this.$store.state; let n = this.$store.getters; if (t) { const i = M(this.$store, 'mapState', t); if (!i) return; e = i.context.state, n = i.context.getters; } return typeof r === 'function' ? r.call(this, e, n) : e[r]; }, n[i].vuex = !0; }), n; }); const P = k((t, e) => { const n = {}; return j(e).forEach((e) => { const i = e.key; const r = e.val; n[i] = function () { const e = []; let n = arguments.length; while (n--)e[n] = arguments[n]; let i = this.$store.commit; if (t) { const o = M(this.$store, 'mapMutations', t); if (!o) return; i = o.context.commit; } return typeof r === 'function' ? r.apply(this, [i].concat(e)) : i.apply(this.$store, [r].concat(e)); }; }), n; }); const L = k((t, e) => { const n = {}; return j(e).forEach((e) => { const i = e.key; let r = e.val; r = t + r, n[i] = function () { if (!t || M(this.$store, 'mapGetters', t)) return this.$store.getters[r]; }, n[i].vuex = !0; }), n; }); var A = k((t, e) => { const n = {}; return j(e).forEach((e) => { const i = e.key; const r = e.val; n[i] = function () { const e = []; let n = arguments.length; while (n--)e[n] = arguments[n]; let i = this.$store.dispatch; if (t) { const o = M(this.$store, 'mapActions', t); if (!o) return; i = o.context.dispatch; } return typeof r === 'function' ? r.apply(this, [i].concat(e)) : i.apply(this.$store, [r].concat(e)); }; }), n; }); const F = function (t) {
      return {
        mapState: I.bind(null, t), mapGetters: L.bind(null, t), mapMutations: P.bind(null, t), mapActions: A.bind(null, t),
      };
    }; function j(t) { return Array.isArray(t) ? t.map(t => ({ key: t, val: t })) : Object.keys(t).map(e => ({ key: e, val: t[e] })); } function k(t) { return function (e, n) { return typeof e !== 'string' ? (n = e, e = '') : e.charAt(e.length - 1) !== '/' && (e += '/'), t(e, n); }; } function M(t, e, n) { const i = t._modulesNamespaceMap[n]; return i; } const N = {
      Store: d, install: R, version: '3.0.1', mapState: I, mapMutations: P, mapGetters: L, mapActions: A, createNamespacedHelpers: F,
    }; e.a = N;
  },
  3024(t, e) { t.exports = function (t, e, n) { const i = void 0 === n; switch (e.length) { case 0: return i ? t() : t.call(n); case 1: return i ? t(e[0]) : t.call(n, e[0]); case 2: return i ? t(e[0], e[1]) : t.call(n, e[0], e[1]); case 3: return i ? t(e[0], e[1], e[2]) : t.call(n, e[0], e[1], e[2]); case 4: return i ? t(e[0], e[1], e[2], e[3]) : t.call(n, e[0], e[1], e[2], e[3]); } return t.apply(n, e); }; },
  '30b5': function (t, e, n) {
    const i = n('c532'); function r(t) {
      return encodeURIComponent(t).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$')
        .replace(/%2C/gi, ',')
        .replace(/%20/g, '+')
        .replace(/%5B/gi, '[')
        .replace(/%5D/gi, ']');
    }t.exports = function (t, e, n) { if (!e) return t; let o; if (n)o = n(e); else if (i.isURLSearchParams(e))o = e.toString(); else { const s = []; i.forEach(e, (t, e) => { t !== null && typeof t !== 'undefined' && (i.isArray(t) ? e += '[]' : t = [t], i.forEach(t, (t) => { i.isDate(t) ? t = t.toISOString() : i.isObject(t) && (t = JSON.stringify(t)), s.push(`${r(e)}=${r(t)}`); })); }), o = s.join('&'); } return o && (t += (t.indexOf('?') === -1 ? '?' : '&') + o), t; };
  },
  '30f1': function (t, e, n) {
    const i = n('b8e3'); const r = n('63b6'); const o = n('9138'); const s = n('35e8'); const a = n('481b'); const u = n('8f60'); const c = n('45f2'); const h = n('53e2'); const l = n('5168')('iterator'); const f = !([].keys && 'next' in [].keys()); const p = '@@iterator'; const d = 'keys'; const v = 'values'; const g = function () { return this; }; t.exports = function (t, e, n, y, m, _, b) { u(n, e, y); let w; let x; let E; const S = function (t) { if (!f && t in R) return R[t]; switch (t) { case d: return function () { return new n(this, t); }; case v: return function () { return new n(this, t); }; } return function () { return new n(this, t); }; }; const T = `${e} Iterator`; const O = m == v; let C = !1; var R = t.prototype; const I = R[l] || R[p] || m && R[m]; let P = I || S(m); const L = m ? O ? S('entries') : P : void 0; const A = e == 'Array' && R.entries || I; if (A && (E = h(A.call(new t())), E !== Object.prototype && E.next && (c(E, T, !0), i || typeof E[l] === 'function' || s(E, l, g))), O && I && I.name !== v && (C = !0, P = function () { return I.call(this); }), i && !b || !f && !C && R[l] || s(R, l, P), a[e] = P, a[T] = g, m) if (w = { values: O ? P : S(v), keys: _ ? P : S(d), entries: L }, b) for (x in w)x in R || o(R, x, w[x]); else r(r.P + r.F * (f || C), e, w); return w; };
  },
  '31f4': function (t, e) { t.exports = function (t, e, n) { const i = void 0 === n; switch (e.length) { case 0: return i ? t() : t.call(n); case 1: return i ? t(e[0]) : t.call(n, e[0]); case 2: return i ? t(e[0], e[1]) : t.call(n, e[0], e[1]); case 3: return i ? t(e[0], e[1], e[2]) : t.call(n, e[0], e[1], e[2]); case 4: return i ? t(e[0], e[1], e[2], e[3]) : t.call(n, e[0], e[1], e[2], e[3]); } return t.apply(n, e); }; },
  '32a6': function (t, e, n) { const i = n('241e'); const r = n('c3a1'); n('ce7e')('keys', () => function (t) { return r(i(t)); }); },
  '32e9': function (t, e, n) { const i = n('86cc'); const r = n('4630'); t.exports = n('9e1e') ? function (t, e, n) { return i.f(t, e, r(1, n)); } : function (t, e, n) { return t[e] = n, t; }; },
  '32fc': function (t, e, n) { const i = n('e53d').document; t.exports = i && i.documentElement; },
  '335c': function (t, e, n) { const i = n('6b4c'); t.exports = Object('z').propertyIsEnumerable(0) ? Object : function (t) { return i(t) == 'String' ? t.split('') : Object(t); }; },
  3385(t, e, n) {},
  '33a4': function (t, e, n) { const i = n('84f2'); const r = n('2b4c')('iterator'); const o = Array.prototype; t.exports = function (t) { return void 0 !== t && (i.Array === t || o[r] === t); }; },
  '355d': function (t, e) { e.f = {}.propertyIsEnumerable; },
  '35e8': function (t, e, n) { const i = n('d9f6'); const r = n('aebd'); t.exports = n('8e60') ? function (t, e, n) { return i.f(t, e, r(1, n)); } : function (t, e, n) { return t[e] = n, t; }; },
  '365b': function (t, e, n) {
    const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; }; function r(t) { return typeof t === 'function' ? t() : t; } function o() { const t = {}; return t.promise = new Promise(((e, n) => { t.resolve = e, t.reject = n; })), t; }t.exports = function (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; let s = void 0; let a = void 0; let u = void 0; let c = []; return function () { const l = r(e); const f = (new Date()).getTime(); const p = !s || f - s > l; s = f; for (var d = arguments.length, v = Array(d), g = 0; g < d; g++)v[g] = arguments[g]; if (p && n.leading) return n.accumulate ? Promise.resolve(t.call(this, [v])).then(t => t[0]) : Promise.resolve(t.call(...[this].concat(v))); if (a ? clearTimeout(u) : a = o(), c.push(v), u = setTimeout(h.bind(this), l), n.accumulate) { const y = (function () { const t = c.length - 1; return { v: a.promise.then(e => e[t]) }; }()); if ((typeof y === 'undefined' ? 'undefined' : i(y)) === 'object') return y.v; } return a.promise; }; function h() { const e = a; clearTimeout(u), Promise.resolve(n.accumulate ? t.call(this, c) : t.apply(this, c[c.length - 1])).then(e.resolve, e.reject), c = [], a = null; } };
  },
  '36c3': function (t, e, n) { const i = n('335c'); const r = n('25eb'); t.exports = function (t) { return i(r(t)); }; },
  3702(t, e, n) { const i = n('481b'); const r = n('5168')('iterator'); const o = Array.prototype; t.exports = function (t) { return void 0 !== t && (i.Array === t || o[r] === t); }; },
  '387f': function (t, e, n) {
    t.exports = function (t, e, n, i, r) { return t.config = e, n && (t.code = n), t.request = i, t.response = r, t; };
  },
  '38fd': function (t, e, n) { const i = n('69a8'); const r = n('4bf8'); const o = n('613b')('IE_PROTO'); const s = Object.prototype; t.exports = Object.getPrototypeOf || function (t) { return t = r(t), i(t, o) ? t[o] : typeof t.constructor === 'function' && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? s : null; }; },
  3934(t, e, n) {
    const i = n('c532'); t.exports = i.isStandardBrowserEnv() ? (function () {
      let t; const e = /(msie|trident)/i.test(navigator.userAgent); const n = document.createElement('a'); function r(t) {
        let i = t; return e && (n.setAttribute('href', i), i = n.href), n.setAttribute('href', i), {
          href: n.href, protocol: n.protocol ? n.protocol.replace(/:$/, '') : '', host: n.host, search: n.search ? n.search.replace(/^\?/, '') : '', hash: n.hash ? n.hash.replace(/^#/, '') : '', hostname: n.hostname, port: n.port, pathname: n.pathname.charAt(0) === '/' ? n.pathname : `/${n.pathname}`,
        };
      } return t = r(window.location.href), function (e) { const n = i.isString(e) ? r(e) : e; return n.protocol === t.protocol && n.host === t.host; };
    }()) : (function () { return function () { return !0; }; }());
  },
  '3a38': function (t, e) { const n = Math.ceil; const i = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? i : n)(t); }; },
  '3c11': function (t, e, n) {
    const i = n('63b6'); const r = n('584a'); const o = n('e53d'); const s = n('f201'); const a = n('cd78'); i(i.P + i.R, 'Promise', { finally(t) { const e = s(this, r.Promise || o.Promise); const n = typeof t === 'function'; return this.then(n ? n => a(e, t()).then(() => n) : t, n ? n => a(e, t()).then(() => { throw n; }) : t); } });
  },
  '40c3': function (t, e, n) { const i = n('6b4c'); const r = n('5168')('toStringTag'); const o = i(function () { return arguments; }()) == 'Arguments'; const s = function (t, e) { try { return t[e]; } catch (n) {} }; t.exports = function (t) { let e; let n; let a; return void 0 === t ? 'Undefined' : t === null ? 'Null' : typeof (n = s(e = Object(t), r)) === 'string' ? n : o ? i(e) : (a = i(e)) == 'Object' && typeof e.callee === 'function' ? 'Arguments' : a; }; },
  4178(t, e, n) { let i; let r; let o; const s = n('d864'); const a = n('3024'); const u = n('32fc'); const c = n('1ec9'); const h = n('e53d'); const l = h.process; let f = h.setImmediate; let p = h.clearImmediate; const d = h.MessageChannel; const v = h.Dispatch; let g = 0; const y = {}; const m = 'onreadystatechange'; const _ = function () { const t = +this; if (y.hasOwnProperty(t)) { const e = y[t]; delete y[t], e(); } }; const b = function (t) { _.call(t.data); }; f && p || (f = function (t) { const e = []; let n = 1; while (arguments.length > n)e.push(arguments[n++]); return y[++g] = function () { a(typeof t === 'function' ? t : Function(t), e); }, i(g), g; }, p = function (t) { delete y[t]; }, n('6b4c')(l) == 'process' ? i = function (t) { l.nextTick(s(_, t, 1)); } : v && v.now ? i = function (t) { v.now(s(_, t, 1)); } : d ? (r = new d(), o = r.port2, r.port1.onmessage = b, i = s(o.postMessage, o, 1)) : h.addEventListener && typeof postMessage === 'function' && !h.importScripts ? (i = function (t) { h.postMessage(`${t}`, '*'); }, h.addEventListener('message', b, !1)) : i = m in c('script') ? function (t) { u.appendChild(c('script'))[m] = function () { u.removeChild(this), _.call(t); }; } : function (t) { setTimeout(s(_, t, 1), 0); }), t.exports = { set: f, clear: p }; },
  '41a0': function (t, e, n) {
    const i = n('2aeb'); const r = n('4630'); const o = n('7f20'); const s = {}; n('32e9')(s, n('2b4c')('iterator'), function () { return this; }), t.exports = function (t, e, n) { t.prototype = i(s, { next: r(1, n) }), o(t, `${e} Iterator`); };
  },
  4362(t, e, n) { e.nextTick = function (t) { setTimeout(t, 0); }, e.platform = e.arch = e.execPath = e.title = 'browser', e.pid = 1, e.browser = !0, e.env = {}, e.argv = [], e.binding = function (t) { throw new Error('No such module. (Possibly not yet loaded)'); }, (function () { let t; let i = '/'; e.cwd = function () { return i; }, e.chdir = function (e) { t || (t = n('df7c')), i = t.resolve(e, i); }; }()), e.exit = e.kill = e.umask = e.dlopen = e.uptime = e.memoryUsage = e.uvCounters = function () {}, e.features = {}; },
  '43fc': function (t, e, n) {
    const i = n('63b6'); const r = n('656e'); const o = n('4439'); i(i.S, 'Promise', { try(t) { const e = r.f(this); const n = o(t); return (n.e ? e.reject : e.resolve)(n.v), e.promise; } });
  },
  4439(t, e) { t.exports = function (t) { try { return { e: !1, v: t() }; } catch (e) { return { e: !0, v: e }; } }; },
  '44dc': function (t, e, n) {},
  4517(t, e, n) { const i = n('a22a'); t.exports = function (t, e) { const n = []; return i(t, !1, n.push, n, e), n; }; },
  '454f': function (t, e, n) { n('46a7'); const i = n('584a').Object; t.exports = function (t, e, n) { return i.defineProperty(t, e, n); }; },
  4588(t, e) { const n = Math.ceil; const i = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? i : n)(t); }; },
  '45f2': function (t, e, n) { const i = n('d9f6').f; const r = n('07e3'); const o = n('5168')('toStringTag'); t.exports = function (t, e, n) { t && !r(t = n ? t : t.prototype, o) && i(t, o, { configurable: !0, value: e }); }; },
  4630(t, e) {
    t.exports = function (t, e) {
      return {
        enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e,
      };
    };
  },
  '467f': function (t, e, n) {
    const i = n('2d83'); t.exports = function (t, e, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? e(i(`Request failed with status code ${n.status}`, n.config, null, n.request, n)) : t(n); };
  },
  '469f': function (t, e, n) { n('6c1c'), n('1654'), t.exports = n('7d7b'); },
  '46a7': function (t, e, n) { const i = n('63b6'); i(i.S + i.F * !n('8e60'), 'Object', { defineProperty: n('d9f6').f }); },
  '47ee': function (t, e, n) { const i = n('c3a1'); const r = n('9aa9'); const o = n('355d'); t.exports = function (t) { const e = i(t); const n = r.f; if (n) { let s; const a = n(t); const u = o.f; let c = 0; while (a.length > c)u.call(t, s = a[c++]) && e.push(s); } return e; }; },
  '481b': function (t, e) { t.exports = {}; },
  '48da': function (t, e, n) {
    const i = n('16c5'); t.exports = function (t) {
      let e; let n; let r; let o; if (e = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(t)) { const s = e[1]; var a = s.replace(/a$/, ''); var u = a === 'cmyk' ? 4 : 3; n = i[a], r = e[2].replace(/^\s+|\s+$/g, '').split(/\s*,\s*/).map((t, e) => (/%$/.test(t) && e === u ? parseFloat(t) / 100 : (/%$/.test(t), parseFloat(t)))), s === a && r.push(1), o = void 0 === r[u] ? 1 : r[u], r = r.slice(0, u), n[a] = function () { return r; }; } else if (/^#[A-Fa-f0-9]+$/.test(t)) { a = t.replace(/^#/, ''), u = a.length; n = i.rgb, r = a.split(u === 3 ? /(.)/ : /(..)/), r = r.filter(Boolean).map(t => (u === 3 ? parseInt(t + t, 16) : parseInt(t, 16))), o = 1, n.rgb = function () { return r; }, r[0] || (r[0] = 0), r[1] || (r[1] = 0), r[2] || (r[2] = 0); } else n = i.keyword, n.keyword = function () { return t; }, r = t, o = 1; const c = {
        rgb: void 0, hsl: void 0, hsv: void 0, cmyk: void 0, keyword: void 0, hex: void 0,
      }; try { c.rgb = n.rgb(r); } catch (h) {} try { c.hsl = n.hsl(r); } catch (h) {} try { c.hsv = n.hsv(r); } catch (h) {} try { c.cmyk = n.cmyk(r); } catch (h) {} try { c.keyword = n.keyword(r); } catch (h) {} return c.rgb && (c.hex = `#${c.rgb.map((t) => { const e = t.toString(16); return e.length === 1 ? `0${e}` : e; }).join('')}`), c.rgb && (c.rgba = c.rgb.concat(o)), c.hsl && (c.hsla = c.hsl.concat(o)), c.hsv && (c.hsva = c.hsv.concat(o)), c.cmyk && (c.cmyka = c.cmyk.concat(o)), c;
    };
  },
  4910(t, e, n) { n('1cb7'), t.exports = n('584a').Reflect.get; },
  '4a59': function (t, e, n) { const i = n('9b43'); const r = n('1fa8'); const o = n('33a4'); const s = n('cb7c'); const a = n('9def'); const u = n('27ee'); const c = {}; const h = {}; e = t.exports = function (t, e, n, l, f) { let p; let d; let v; let g; const y = f ? function () { return t; } : u(t); const m = i(n, l, e ? 2 : 1); let _ = 0; if (typeof y !== 'function') throw TypeError(`${t} is not iterable!`); if (o(y)) { for (p = a(t.length); p > _; _++) if (g = e ? m(s(d = t[_])[0], d[1]) : m(t[_]), g === c || g === h) return g; } else for (v = y.call(t); !(d = v.next()).done;) if (g = r(v, m, d.value, e), g === c || g === h) return g; }; e.BREAK = c, e.RETURN = h; },
  '4aa6': function (t, e, n) { t.exports = n('dc62'); },
  '4bf8': function (t, e, n) { const i = n('be13'); t.exports = function (t) { return Object(i(t)); }; },
  '4c34': function (t, e, n) {},
  '4c94': function (t, e, n) {},
  '4c95': function (t, e, n) {
    const i = n('e53d'); const r = n('584a'); const o = n('d9f6'); const s = n('8e60'); const a = n('5168')('species'); t.exports = function (t) { const e = typeof r[t] === 'function' ? r[t] : i[t]; s && e && !e[a] && o.f(e, a, { configurable: !0, get() { return this; } }); };
  },
  '4d16': function (t, e, n) { t.exports = n('25b0'); },
  '4ee1': function (t, e, n) { const i = n('5168')('iterator'); let r = !1; try { const o = [7][i](); o.return = function () { r = !0; }, Array.from(o, () => { throw 2; }); } catch (s) {}t.exports = function (t, e) { if (!e && !r) return !1; let n = !1; try { const o = [7]; const a = o[i](); a.next = function () { return { done: n = !0 }; }, o[i] = function () { return a; }, t(o); } catch (s) {} return n; }; },
  5037(t, e, n) { n('c207'), n('1654'), n('6c1c'), n('837d'), n('5cb6'), n('fe1e'), n('7554'), t.exports = n('584a').Map; },
  '50ed': function (t, e) { t.exports = function (t, e) { return { value: e, done: !!t }; }; },
  5168(t, e, n) { const i = n('dbdb')('wks'); const r = n('62a0'); const o = n('e53d').Symbol; const s = typeof o === 'function'; const a = t.exports = function (t) { return i[t] || (i[t] = s && o[t] || (s ? o : r)(`Symbol.${t}`)); }; a.store = i; },
  5176(t, e, n) { t.exports = n('51b6'); },
  '51b6': function (t, e, n) { n('a3c3'), t.exports = n('584a').Object.assign; },
  5270(t, e, n) {
    const i = n('c532'); const r = n('c401'); const o = n('2e67'); const s = n('2444'); const a = n('d925'); const u = n('e683'); function c(t) { t.cancelToken && t.cancelToken.throwIfRequested(); }t.exports = function (t) { c(t), t.baseURL && !a(t.url) && (t.url = u(t.baseURL, t.url)), t.headers = t.headers || {}, t.data = r(t.data, t.headers, t.transformRequest), t.headers = i.merge(t.headers.common || {}, t.headers[t.method] || {}, t.headers || {}), i.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (e) => { delete t.headers[e]; }); const e = t.adapter || s.adapter; return e(t).then(e => c(t), e.data = r(e.data, e.headers, t.transformResponse), e, e => o(e) || (c(t), e && e.response && (e.response.data = r(e.response.data, e.response.headers, t.transformResponse))), Promise.reject(e)); };
  },
  '53e2': function (t, e, n) { const i = n('07e3'); const r = n('241e'); const o = n('5559')('IE_PROTO'); const s = Object.prototype; t.exports = Object.getPrototypeOf || function (t) { return t = r(t), i(t, o) ? t[o] : typeof t.constructor === 'function' && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? s : null; }; },
  '549b': function (t, e, n) {
    const i = n('d864'); const r = n('63b6'); const o = n('241e'); const s = n('b0dc'); const a = n('3702'); const u = n('b447'); const c = n('20fd'); const h = n('7cd6'); r(r.S + r.F * !n('4ee1')((t) => { Array.from(t); }), 'Array', { from(t) { let e; let n; let r; let l; const f = o(t); const p = typeof this === 'function' ? this : Array; const d = arguments.length; let v = d > 1 ? arguments[1] : void 0; const g = void 0 !== v; let y = 0; const m = h(f); if (g && (v = i(v, d > 2 ? arguments[2] : void 0, 2)), void 0 == m || p == Array && a(m)) for (e = u(f.length), n = new p(e); e > y; y++)c(n, y, g ? v(f[y], y) : f[y]); else for (l = m.call(f), n = new p(); !(r = l.next()).done; y++)c(n, y, g ? s(l, v, [r.value, y], !0) : r.value); return n.length = y, n; } });
  },
  '549c': function (t, e, n) {
    n('f134'); const i = n('b57a'); e.a = {
      name: 'v-content',
      mixins: [i.a],
      props: { tag: { type: String, default: 'main' } },
      computed: {
        styles() {
          const t = this.$vuetify.application; const e = t.bar; const n = t.top; const i = t.right; const r = t.footer; const o = t.insetFooter; const s = t.bottom; const a = t.left; return {
            paddingTop: `${n + e}px`, paddingRight: `${i}px`, paddingBottom: `${r + o + s}px`, paddingLeft: `${a}px`,
          };
        },
      },
      render(t) { const e = { staticClass: 'v-content', style: this.styles, ref: 'content' }; return t(this.tag, e, [t('div', { staticClass: 'v-content__wrap' }, this.$slots.default)]); },
    };
  },
  '54a1': function (t, e, n) { n('6c1c'), n('1654'), t.exports = n('95d5'); },
  '551c': function (t, e, n) {
    let i; let r; let o; let s; const a = n('2d00'); const u = n('7726'); const c = n('9b43'); const h = n('23c6'); const l = n('5ca1'); const f = n('d3f4'); const p = n('d8e8'); const d = n('f605'); const v = n('4a59'); const g = n('ebd6'); const y = n('1991').set; const m = n('8079')(); const _ = n('a5b8'); const b = n('9c80'); const w = n('a25f'); const x = n('bcaa'); const E = 'Promise'; const S = u.TypeError; const T = u.process; const O = T && T.versions; const C = O && O.v8 || ''; let R = u[E]; const I = h(T) == 'process'; const P = function () {}; let L = r = _.f; const A = !!(function () { try { const t = R.resolve(1); const e = (t.constructor = {})[n('2b4c')('species')] = function (t) { t(P, P); }; return (I || typeof PromiseRejectionEvent === 'function') && t.then(P) instanceof e && C.indexOf('6.6') !== 0 && w.indexOf('Chrome/66') === -1; } catch (i) {} }()); const F = function (t) { let e; return !(!f(t) || typeof (e = t.then) !== 'function') && e; }; const j = function (t, e) { if (!t._n) { t._n = !0; const n = t._c; m(() => { const i = t._v; const r = t._s == 1; let o = 0; const s = function (e) { let n; let o; let s; const a = r ? e.ok : e.fail; const u = e.resolve; const c = e.reject; const h = e.domain; try { a ? (r || (t._h == 2 && N(t), t._h = 1), !0 === a ? n = i : (h && h.enter(), n = a(i), h && (h.exit(), s = !0)), n === e.promise ? c(S('Promise-chain cycle')) : (o = F(n)) ? o.call(n, u, c) : u(n)) : c(i); } catch (l) { h && !s && h.exit(), c(l); } }; while (n.length > o)s(n[o++]); t._c = [], t._n = !1, e && !t._h && k(t); }); } }; var k = function (t) { y.call(u, () => { let e; let n; let i; const r = t._v; const o = M(t); if (o && (e = b(() => { I ? T.emit('unhandledRejection', r, t) : (n = u.onunhandledrejection) ? n({ promise: t, reason: r }) : (i = u.console) && i.error && i.error('Unhandled promise rejection', r); }), t._h = I || M(t) ? 2 : 1), t._a = void 0, o && e.e) throw e.v; }); }; var M = function (t) { return t._h !== 1 && (t._a || t._c).length === 0; }; var N = function (t) { y.call(u, () => { let e; I ? T.emit('rejectionHandled', t) : (e = u.onrejectionhandled) && e({ promise: t, reason: t._v }); }); }; const D = function (t) { let e = this; e._d || (e._d = !0, e = e._w || e, e._v = t, e._s = 2, e._a || (e._a = e._c.slice()), j(e, !0)); }; var $ = function (t) { let e; let n = this; if (!n._d) { n._d = !0, n = n._w || n; try { if (n === t) throw S("Promise can't be resolved itself"); (e = F(t)) ? m(() => { const i = { _w: n, _d: !1 }; try { e.call(t, c($, i, 1), c(D, i, 1)); } catch (r) { D.call(i, r); } }) : (n._v = t, n._s = 1, j(n, !1)); } catch (i) { D.call({ _w: n, _d: !1 }, i); } } }; A || (R = function (t) { d(this, R, E, '_h'), p(t), i.call(this); try { t(c($, this, 1), c(D, this, 1)); } catch (e) { D.call(this, e); } }, i = function (t) { this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1; }, i.prototype = n('dcbc')(R.prototype, { then(t, e) { const n = L(g(this, R)); return n.ok = typeof t !== 'function' || t, n.fail = typeof e === 'function' && e, n.domain = I ? T.domain : void 0, this._c.push(n), this._a && this._a.push(n), this._s && j(this, !1), n.promise; }, catch(t) { return this.then(void 0, t); } }), o = function () { const t = new i(); this.promise = t, this.resolve = c($, t, 1), this.reject = c(D, t, 1); }, _.f = L = function (t) { return t === R || t === s ? new o(t) : r(t); }), l(l.G + l.W + l.F * !A, { Promise: R }), n('7f20')(R, E), n('7a56')(E), s = n('8378')[E], l(l.S + l.F * !A, E, { reject(t) { const e = L(this); const n = e.reject; return n(t), e.promise; } }), l(l.S + l.F * (a || !A), E, { resolve(t) { return x(a && this === s ? R : this, t); } }), l(l.S + l.F * !(A && n('5cc5')((t) => { R.all(t).catch(P); })), E, { all(t) { const e = this; const n = L(e); const i = n.resolve; const r = n.reject; const o = b(() => { const n = []; let o = 0; let s = 1; v(t, !1, (t) => { const a = o++; let u = !1; n.push(void 0), s++, e.resolve(t).then((t) => { u || (u = !0, n[a] = t, --s || i(n)); }, r); }), --s || i(n); }); return o.e && r(o.v), n.promise; }, race(t) { const e = this; const n = L(e); const i = n.reject; const r = b(() => { v(t, !1, (t) => { e.resolve(t).then(n.resolve, i); }); }); return r.e && i(r.v), n.promise; } });
  },
  5537(t, e, n) { const i = n('8378'); const r = n('7726'); const o = '__core-js_shared__'; const s = r[o] || (r[o] = {}); (t.exports = function (t, e) { return s[t] || (s[t] = void 0 !== e ? e : {}); })('versions', []).push({ version: i.version, mode: n('2d00') ? 'pure' : 'global', copyright: '© 2018 Denis Pushkarev (zloirock.ru)' }); },
  5559(t, e, n) { const i = n('dbdb')('keys'); const r = n('62a0'); t.exports = function (t) { return i[t] || (i[t] = r(t)); }; },
  '57b1': function (t, e, n) { const i = n('d864'); const r = n('335c'); const o = n('241e'); const s = n('b447'); const a = n('bfac'); t.exports = function (t, e) { const n = t == 1; const u = t == 2; const c = t == 3; const h = t == 4; const l = t == 6; const f = t == 5 || l; const p = e || a; return function (e, a, d) { for (var v, g, y = o(e), m = r(y), _ = i(a, d, 3), b = s(m.length), w = 0, x = n ? p(e, b) : u ? p(e, 0) : void 0; b > w; w++) if ((f || w in m) && (v = m[w], g = _(v, w, y), t)) if (n)x[w] = g; else if (g) switch (t) { case 3: return !0; case 5: return v; case 6: return w; case 2: x.push(v); } else if (h) return !1; return l ? -1 : c || h ? h : x; }; }; },
  '584a': function (t, e) { const n = t.exports = { version: '2.6.0' }; typeof __e === 'number' && (__e = n); },
  '58db': function (t, e, n) {},
  '58db6': function (t, e, n) {},
  '58df': function (t, e, n) {
    n.d(e, 'a', () => r); const i = n('2b0e'); function r() { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return i.a.extend({ mixins: e }); }
  },
  '59ad': function (t, e, n) { t.exports = n('7be7'); },
  '5aee': function (t, e, n) {
    const i = n('d9f6').f; const r = n('a159'); const o = n('5c95'); const s = n('d864'); const a = n('1173'); const u = n('a22a'); const c = n('30f1'); const h = n('50ed'); const l = n('4c95'); const f = n('8e60'); const p = n('ebfd').fastKey; const d = n('9f79'); const v = f ? '_s' : 'size'; const g = function (t, e) { let n; const i = p(e); if (i !== 'F') return t._i[i]; for (n = t._f; n; n = n.n) if (n.k == e) return n; }; t.exports = {
      getConstructor(t, e, n, c) {
        var h = t((t, i) => { a(t, h, e, '_i'), t._t = e, t._i = r(null), t._f = void 0, t._l = void 0, t[v] = 0, void 0 != i && u(i, n, t[c], t); }); return o(h.prototype, {
          clear() { for (var t = d(this, e), n = t._i, i = t._f; i; i = i.n)i.r = !0, i.p && (i.p = i.p.n = void 0), delete n[i.i]; t._f = t._l = void 0, t[v] = 0; }, delete(t) { const n = d(this, e); const i = g(n, t); if (i) { const r = i.n; const o = i.p; delete n._i[i.i], i.r = !0, o && (o.n = r), r && (r.p = o), n._f == i && (n._f = r), n._l == i && (n._l = o), n[v]--; } return !!i; }, forEach(t) { d(this, e); let n; const i = s(t, arguments.length > 1 ? arguments[1] : void 0, 3); while (n = n ? n.n : this._f) { i(n.v, n.k, this); while (n && n.r)n = n.p; } }, has(t) { return !!g(d(this, e), t); },
        }), f && i(h.prototype, 'size', { get() { return d(this, e)[v]; } }), h;
      },
      def(t, e, n) {
        let i; let r; let o = g(t, e); return o ? o.v = n : (t._l = o = {
          i: r = p(e, !0), k: e, v: n, p: i = t._l, n: void 0, r: !1,
        }, t._f || (t._f = o), i && (i.n = o), t[v]++, r !== 'F' && (t._i[r] = o)), t;
      },
      getEntry: g,
      setStrong(t, e, n) { c(t, e, function (t, n) { this._t = d(t, e), this._k = n, this._l = void 0; }, function () { const t = this; const e = t._k; let n = t._l; while (n && n.r)n = n.p; return t._t && (t._l = n = n ? n.n : t._t._f) ? h(0, e == 'keys' ? n.k : e == 'values' ? n.v : [n.k, n.v]) : (t._t = void 0, h(1)); }, n ? 'entries' : 'values', !n, !0), l(e); },
    };
  },
  '5b4e': function (t, e, n) { const i = n('36c3'); const r = n('b447'); const o = n('0fc9'); t.exports = function (t) { return function (e, n, s) { let a; const u = i(e); const c = r(u.length); let h = o(s, c); if (t && n != n) { while (c > h) if (a = u[h++], a != a) return !0; } else for (;c > h; h++) if ((t || h in u) && u[h] === n) return t || h || 0; return !t && -1; }; }; },
  '5bba': function (t, e, n) { n('9d98'); const i = n('584a').Object; t.exports = function (t, e) { return i.defineProperties(t, e); }; },
  '5c95': function (t, e, n) { const i = n('35e8'); t.exports = function (t, e, n) { for (const r in e)n && t[r] ? t[r] = e[r] : i(t, r, e[r]); return t; }; },
  '5ca1': function (t, e, n) { const i = n('7726'); const r = n('8378'); const o = n('32e9'); const s = n('2aba'); const a = n('9b43'); const u = 'prototype'; var c = function (t, e, n) { let h; let l; let f; let p; const d = t & c.F; const v = t & c.G; const g = t & c.S; const y = t & c.P; const m = t & c.B; const _ = v ? i : g ? i[e] || (i[e] = {}) : (i[e] || {})[u]; const b = v ? r : r[e] || (r[e] = {}); const w = b[u] || (b[u] = {}); for (h in v && (n = e), n)l = !d && _ && void 0 !== _[h], f = (l ? _ : n)[h], p = m && l ? a(f, i) : y && typeof f === 'function' ? a(Function.call, f) : f, _ && s(_, h, f, t & c.U), b[h] != f && o(b, h, p), y && w[h] != f && (w[h] = f); }; i.core = r, c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, t.exports = c; },
  '5cb6': function (t, e, n) { const i = n('63b6'); i(i.P + i.R, 'Map', { toJSON: n('f228')('Map') }); },
  '5cc5': function (t, e, n) { const i = n('2b4c')('iterator'); let r = !1; try { const o = [7][i](); o.return = function () { r = !0; }, Array.from(o, () => { throw 2; }); } catch (s) {}t.exports = function (t, e) { if (!e && !r) return !1; let n = !1; try { const o = [7]; const a = o[i](); a.next = function () { return { done: n = !0 }; }, o[i] = function () { return a; }, t(o); } catch (s) {} return n; }; },
  '5d58': function (t, e, n) { t.exports = n('d8d6'); },
  '5d73': function (t, e, n) { t.exports = n('469f'); },
  '613b': function (t, e, n) { const i = n('5537')('keys'); const r = n('ca5a'); t.exports = function (t) { return i[t] || (i[t] = r(t)); }; },
  '61ca': function (t, e, n) {
    (function (e, n) { t.exports = n(); }(0, () => {
      function t(t, n, r, o, s) { e(t, n, r || 0, o || t.length - 1, s || i); } function e(t, i, r, o, s) { while (o > r) { if (o - r > 600) { const a = o - r + 1; const u = i - r + 1; const c = Math.log(a); const h = 0.5 * Math.exp(2 * c / 3); const l = 0.5 * Math.sqrt(c * h * (a - h) / a) * (u - a / 2 < 0 ? -1 : 1); const f = Math.max(r, Math.floor(i - u * h / a + l)); const p = Math.min(o, Math.floor(i + (a - u) * h / a + l)); e(t, i, f, p, s); } const d = t[i]; let v = r; let g = o; n(t, r, i), s(t[o], d) > 0 && n(t, r, o); while (v < g) { n(t, v, g), v++, g--; while (s(t[v], d) < 0)v++; while (s(t[g], d) > 0)g--; }s(t[r], d) === 0 ? n(t, r, g) : (g++, n(t, g, o)), g <= i && (r = g + 1), i <= g && (o = g - 1); } } function n(t, e, n) { const i = t[e]; t[e] = t[n], t[n] = i; } function i(t, e) { return t < e ? -1 : t > e ? 1 : 0; } return t;
    }));
  },
  '626a': function (t, e, n) { const i = n('2d95'); t.exports = Object('z').propertyIsEnumerable(0) ? Object : function (t) { return i(t) == 'String' ? t.split('') : Object(t); }; },
  '62a0': function (t, e) { let n = 0; const i = Math.random(); t.exports = function (t) { return 'Symbol('.concat(void 0 === t ? '' : t, ')_', (++n + i).toString(36)); }; },
  '63b6': function (t, e, n) { const i = n('e53d'); const r = n('584a'); const o = n('d864'); const s = n('35e8'); const a = n('07e3'); const u = 'prototype'; var c = function (t, e, n) { let h; let l; let f; const p = t & c.F; const d = t & c.G; const v = t & c.S; const g = t & c.P; const y = t & c.B; const m = t & c.W; const _ = d ? r : r[e] || (r[e] = {}); const b = _[u]; const w = d ? i : v ? i[e] : (i[e] || {})[u]; for (h in d && (n = e), n)l = !p && w && void 0 !== w[h], l && a(_, h) || (f = l ? w[h] : n[h], _[h] = d && typeof w[h] !== 'function' ? n[h] : y && l ? o(f, i) : m && w[h] == f ? (function (t) { const e = function (e, n, i) { if (this instanceof t) { switch (arguments.length) { case 0: return new t(); case 1: return new t(e); case 2: return new t(e, n); } return new t(e, n, i); } return t.apply(this, arguments); }; return e[u] = t[u], e; }(f)) : g && typeof f === 'function' ? o(Function.call, f) : f, g && ((_.virtual || (_.virtual = {}))[h] = f, t & c.R && b && !b[h] && s(b, h, f))); }; c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, t.exports = c; },
  6544(t, e) { t.exports = function (t, e) { const n = typeof t.exports === 'function' ? t.exports.extendOptions : t.options; for (const i in typeof t.exports === 'function' && (n.components = t.exports.options.components), n.components = n.components || {}, e)n.components[i] = n.components[i] || e[i]; }; },
  '656a': function (t, e, n) {
    (function (t) { n.d(e, 't', () => C), n.d(e, 'c', () => R), n.d(e, 'z', () => I), n.d(e, 'h', () => P), n.d(e, 'm', () => A), n.d(e, 'p', () => F), n.d(e, 'k', () => M), n.d(e, 'l', () => N), n.d(e, 'n', () => D), n.d(e, 'o', () => G), n.d(e, 'b', () => V), n.d(e, 'v', () => B), n.d(e, 'y', () => U), n.d(e, 'j', () => z), n.d(e, 'i', () => Y), n.d(e, 'f', () => W), n.d(e, 'x', () => K), n.d(e, 'r', () => q), n.d(e, 's', () => Z), n.d(e, 'e', () => J), n.d(e, 'u', () => Q), n.d(e, 'A', () => tt), n.d(e, 'q', () => et), n.d(e, 'w', () => nt), n.d(e, 'g', () => it), n.d(e, 'd', () => ot), n.d(e, 'a', () => st); let i; const r = n('967e'); const o = n.n(r); const s = n('a4bb'); const a = n.n(s); const u = n('061b'); const c = n.n(u); const h = n('7618'); const l = n('59ad'); const f = n.n(l); const p = n('a745'); const d = n.n(p); const v = (n('774e'), o.a.mark(nt)); const g = typeof t !== 'undefined' ? t : typeof window !== 'undefined' ? window : {}; const y = g.isFinite || C; const m = Object.prototype; const _ = Object.prototype; const b = m.toString; const w = _.toString; const x = (i = {}, b).call(i); const E = (i = 0, b).call(i); const S = (i = '', b).call(i); const T = (i = !0, b).call(i); const O = w.call(Object); function C() {} function R(t) { return function () { return t; }; } function I() { return []; } function P(t) { return t; } function L(t) { return b.call(t) === T; } function A(t) { return b.call(t) === E; } function F(t) { return b.call(t) === S; } function j(t) { return d()(t); } function k(t) { return $(t) && t.hasOwnProperty('length'); } function M(t) { return typeof t === 'number' && y(t); } function N(t) { return typeof t === 'function'; } function D(t) { return !isNaN(f()(t)) && y(t); } function $(t) { return t != null && Object(h.a)(t) === 'object'; } function G(t) { if (!$(t) || b.call(t) !== x) return !1; const e = c()(t); if (e == null) return !0; const n = e.constructor; return typeof n === 'function' && n instanceof n && w.call(n) === O; } function V() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return e.find(t => t != null); } function B(t) { const e = {}; const n = function (t) { return D(t) || F(t) || j(t) || L(t) || G(t); }; return a()(t).forEach((i) => { n(t[i]) && (e[i] = t[i]); }), e; } function U(t, e) { const n = new RegExp(a()(e).map(t => `(\\{${t}\\})`).join('|'), 'ig'); return t.replace(n, t => e[t.substr(1, t.length - 2)] || ''); } function z(t, e) { if (t === e) return !0; if (t == null || e == null || !$(t) && !$(e)) return t !== t && e !== e; const n = a()(t); const i = a()(e); if (n.length !== i.length) return !1; const r = []; const o = function (n, i) { for (let o = 0, s = n.length; o < s; o++) { const a = n[o]; if (!r.includes(a)) { if (!1 === e.hasOwnProperty(a)) return !1; const u = i[o]; if (!z(t[a], e[u])) return !1; r.push(u); } } return !0; }; return !1 !== o(n, i) && o(i, n); } function Y(t) { return !t || k(t) && t.length === 0 || $(t) && a()(t).length === 0; } function X(t) { return !Y(t); } function W(t, e) { for (let n = a()(t), i = 0, r = n.length; i < r; i++) { const o = n[i]; const s = t[o]; if (!1 === e(s, o)) return; } } function K(t, e, n) { let i = n; return W(t, (t, n) => { i = e(i, t, n); }), i; } function H(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X; return K(t, (t, n, i) => e(n, i) && (j(t) ? t.push(n) : t[i] = n), t, j(t) ? [] : {}); } function q(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : P; return K(t, (t, n, i) => t[i] = e(n, i), t, j(t) ? [] : {}); } function Z(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : P; return q(t, e); } function J(t) { if (k(t)) return t[0]; } function Q(t, e) { for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)i[r - 2] = arguments[r]; return i = d()(e) ? e : [e].concat(i), K(i, (e, n) => e[n] = t[n], e, {}); } function tt(t) { return t = String(t), t.length === 0 ? '' : t[0].toUpperCase() + t.slice(1); } function et(t) { return t = String(t), t.length === 0 ? '' : t[0].toLowerCase() + t.slice(1); } function nt(t, e) { let n; let i; const r = arguments; return o.a.wrap((o) => { while (1) switch (o.prev = o.next) { case 0: n = r.length > 2 && void 0 !== r[2] ? r[2] : 1, i = t; case 2: if (!(i < e)) { o.next = 8; break; } return o.next = 5, i; case 5: i += n, o.next = 2; break; case 8: case 'end': return o.stop(); } }, v, this); } function it(t, e, n) { const i = new Function('object', 'try { return object.'.concat(e, ' } catch (e) {}')); return V(i(t), n); } function rt(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : z; const i = H(t, t => n(t, e)); return i.shift(); } function ot(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : z; return H(t, t => !rt(e, t, n)); } function st(t) { const e = /([-_]\w)/g; return t.replace(e, t => t[1].toUpperCase()); } }).call(this, n('c8ba'));
  },
  '656e': function (t, e, n) {
    const i = n('79aa'); function r(t) { let e; let n; this.promise = new t(((t, i) => { if (void 0 !== e || void 0 !== n) throw TypeError('Bad Promise constructor'); e = t, n = i; })), this.resolve = i(e), this.reject = i(n); }t.exports.f = function (t) { return new r(t); };
  },
  6718(t, e, n) { const i = n('e53d'); const r = n('584a'); const o = n('b8e3'); const s = n('ccb9'); const a = n('d9f6').f; t.exports = function (t) { const e = r.Symbol || (r.Symbol = o ? {} : i.Symbol || {}); t.charAt(0) == '_' || t in e || a(e, t, { value: s.f(t) }); }; },
  '67bb': function (t, e, n) { t.exports = n('f921'); },
  6821(t, e, n) { const i = n('626a'); const r = n('be13'); t.exports = function (t) { return i(r(t)); }; },
  '68f7': function (t, e, n) {
    const i = n('63b6'); const r = n('79aa'); const o = n('d864'); const s = n('a22a'); t.exports = function (t) { i(i.S, t, { from(t) { let e; let n; let i; let a; const u = arguments[1]; return r(this), e = void 0 !== u, e && r(u), void 0 == t ? new this() : (n = [], e ? (i = 0, a = o(u, arguments[2], 2), s(t, !1, (t) => { n.push(a(t, i++)); })) : s(t, !1, n.push, n), new this(n)); } }); };
  },
  '696e': function (t, e, n) { n('c207'), n('1654'), n('6c1c'), n('24c5'), n('3c11'), n('43fc'), t.exports = n('584a').Promise; },
  '69a8': function (t, e) { const n = {}.hasOwnProperty; t.exports = function (t, e) { return n.call(t, e); }; },
  '69d3': function (t, e, n) { n('6718')('asyncIterator'); },
  '6a18': function (t, e, n) {
    const i = n('2b0e'); Object.assign; const r = i.a.extend().extend({
      name: 'themeable',
      provide() { return { theme: this.themeableProvide }; },
      inject: { theme: { default: { isDark: !1 } } },
      props: { dark: { type: Boolean, default: null }, light: { type: Boolean, default: null } },
      data() { return { themeableProvide: { isDark: !1 } }; },
      computed: {
        isDark() { return !0 === this.dark || !0 !== this.light && this.theme.isDark; }, themeClasses() { return { 'theme--dark': this.isDark, 'theme--light': !this.isDark }; }, rootIsDark() { return !0 === this.dark || !0 !== this.light && this.$vuetify.dark; }, rootThemeClasses() { return { 'theme--dark': this.rootIsDark, 'theme--light': !this.rootIsDark }; },
      },
      watch: { isDark: { handler(t, e) { t !== e && (this.themeableProvide.isDark = this.isDark); }, immediate: !0 } },
    }); e.a = r;
  },
  '6a99': function (t, e, n) { const i = n('d3f4'); t.exports = function (t, e) { if (!i(t)) return t; let n; let r; if (e && typeof (n = t.toString) === 'function' && !i(r = n.call(t))) return r; if (typeof (n = t.valueOf) === 'function' && !i(r = n.call(t))) return r; if (!e && typeof (n = t.toString) === 'function' && !i(r = n.call(t))) return r; throw TypeError("Can't convert object to primitive value"); }; },
  '6abf': function (t, e, n) { const i = n('e6f3'); const r = n('1691').concat('length', 'prototype'); e.f = Object.getOwnPropertyNames || function (t) { return i(t, r); }; },
  '6b4c': function (t, e) { const n = {}.toString; t.exports = function (t) { return n.call(t).slice(8, -1); }; },
  '6c1c': function (t, e, n) { n('c367'); for (let i = n('e53d'), r = n('35e8'), o = n('481b'), s = n('5168')('toStringTag'), a = 'CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList'.split(','), u = 0; u < a.length; u++) { const c = a[u]; const h = i[c]; const l = h && h.prototype; l && !l[s] && r(l, s, c), o[c] = o.Array; } },
  7075(t, e, n) {
    const i = n('63b6'); t.exports = function (t) { i(i.S, t, { of() { let t = arguments.length; const e = new Array(t); while (t--)e[t] = arguments[t]; return new this(e); } }); };
  },
  '71c1': function (t, e, n) { const i = n('3a38'); const r = n('25eb'); t.exports = function (t) { return function (e, n) { let o; let s; const a = String(r(e)); const u = i(n); const c = a.length; return u < 0 || u >= c ? t ? '' : void 0 : (o = a.charCodeAt(u), o < 55296 || o > 56319 || u + 1 === c || (s = a.charCodeAt(u + 1)) < 56320 || s > 57343 ? t ? a.charAt(u) : o : t ? a.slice(u, u + 2) : s - 56320 + (o - 55296 << 10) + 65536); }; }; },
  '71d9': function (t, e, n) {
    n('ae8d'); const i = n('c6f7'); const r = n('b64a'); const o = n('6a18'); const s = n('b57a'); function a(t, e) { const n = e.value; const i = e.options || { passive: !0 }; const r = e.arg ? document.querySelector(e.arg) : window; r && (r.addEventListener('scroll', n, i), t._onScroll = { callback: n, options: i, target: r }); } function u(t) { if (t._onScroll) { const e = t._onScroll; const n = e.callback; const i = e.options; const r = e.target; r.removeEventListener('scroll', n, i), delete t._onScroll; } } const c = { inserted: a, unbind: u }; const h = n('d9bd'); const l = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; e.a = {
      name: 'v-toolbar',
      directives: { Scroll: c },
      mixins: [Object(i.a)('top', ['clippedLeft', 'clippedRight', 'computedHeight', 'invertedScroll', 'manualScroll']), r.a, s.a, o.a],
      props: {
        card: Boolean, clippedLeft: Boolean, clippedRight: Boolean, dense: Boolean, extended: Boolean, extensionHeight: { type: [Number, String], validator(t) { return !isNaN(parseInt(t)); } }, flat: Boolean, floating: Boolean, height: { type: [Number, String], validator(t) { return !isNaN(parseInt(t)); } }, invertedScroll: Boolean, manualScroll: Boolean, prominent: Boolean, scrollOffScreen: Boolean, scrollToolbarOffScreen: Boolean, scrollTarget: String, scrollThreshold: { type: Number, default: 300 }, tabs: Boolean,
      },
      data() {
        return {
          activeTimeout: null,
          currentScroll: 0,
          heights: {
            mobileLandscape: 48, mobile: 56, desktop: 64, dense: 48,
          },
          isActive: !0,
          isExtended: !1,
          isScrollingUp: !1,
          previousScroll: null,
          previousScrollDirection: null,
          savedScroll: 0,
          target: null,
        };
      },
      computed: {
        canScroll() { return this.scrollToolbarOffScreen ? (Object(h.c)('scrollToolbarOffScreen', 'scrollOffScreen', this), !0) : this.scrollOffScreen || this.invertedScroll; },
        computedContentHeight() { return this.height ? parseInt(this.height) : this.dense ? this.heights.dense : this.prominent || this.$vuetify.breakpoint.mdAndUp ? this.heights.desktop : this.$vuetify.breakpoint.smAndDown && this.$vuetify.breakpoint.width > this.$vuetify.breakpoint.height ? this.heights.mobileLandscape : this.heights.mobile; },
        computedExtensionHeight() { return this.tabs ? 48 : this.extensionHeight ? parseInt(this.extensionHeight) : this.computedContentHeight; },
        computedHeight() { return this.isExtended ? this.computedContentHeight + this.computedExtensionHeight : this.computedContentHeight; },
        computedMarginTop() { return this.app ? this.$vuetify.application.bar : 0; },
        classes() {
          return l({
            'v-toolbar': !0, 'elevation-0': this.flat || !this.isActive && !this.tabs && this.canScroll, 'v-toolbar--absolute': this.absolute, 'v-toolbar--card': this.card, 'v-toolbar--clipped': this.clippedLeft || this.clippedRight, 'v-toolbar--dense': this.dense, 'v-toolbar--extended': this.isExtended, 'v-toolbar--fixed': !this.absolute && (this.app || this.fixed), 'v-toolbar--floating': this.floating, 'v-toolbar--prominent': this.prominent,
          }, this.themeClasses);
        },
        computedPaddingLeft() { return !this.app || this.clippedLeft ? 0 : this.$vuetify.application.left; },
        computedPaddingRight() { return !this.app || this.clippedRight ? 0 : this.$vuetify.application.right; },
        computedTransform() { return this.isActive ? 0 : this.canScroll ? -this.computedContentHeight : -this.computedHeight; },
        currentThreshold() { return Math.abs(this.currentScroll - this.savedScroll); },
        styles() {
          return {
            marginTop: `${this.computedMarginTop}px`, paddingRight: `${this.computedPaddingRight}px`, paddingLeft: `${this.computedPaddingLeft}px`, transform: `translateY(${this.computedTransform}px)`,
          };
        },
      },
      watch: {
        currentThreshold(t) { if (this.invertedScroll) return this.isActive = this.currentScroll > this.scrollThreshold; t < this.scrollThreshold || !this.isBooted || (this.isActive = this.isScrollingUp, this.savedScroll = this.currentScroll); }, isActive() { this.savedScroll = 0; }, invertedScroll(t) { this.isActive = !t; }, manualScroll(t) { this.isActive = !t; }, isScrollingUp() { this.savedScroll = this.savedScroll || this.currentScroll; },
      },
      created() { (this.invertedScroll || this.manualScroll) && (this.isActive = !1); },
      mounted() { this.scrollTarget && (this.target = document.querySelector(this.scrollTarget)); },
      methods: { onScroll() { if (this.canScroll && !this.manualScroll && typeof window !== 'undefined') { const t = this.target || window; this.currentScroll = this.scrollTarget ? t.scrollTop : t.pageYOffset || document.documentElement.scrollTop, this.isScrollingUp = this.currentScroll < this.previousScroll, this.previousScroll = this.currentScroll; } }, updateApplication() { return this.invertedScroll || this.manualScroll ? 0 : this.computedHeight; } },
      render(t) { this.isExtended = this.extended || !!this.$slots.extension; const e = []; const n = this.setBackgroundColor(this.color, { class: this.classes, style: this.styles, on: this.$listeners }); return n.directives = [{ arg: this.scrollTarget, name: 'scroll', value: this.onScroll }], e.push(t('div', { staticClass: 'v-toolbar__content', style: { height: `${this.computedContentHeight}px` }, ref: 'content' }, this.$slots.default)), this.isExtended && e.push(t('div', { staticClass: 'v-toolbar__extension', style: { height: `${this.computedExtensionHeight}px` } }, this.$slots.extension)), t('nav', n, e); },
    };
  },
  '733c': function (t, e, n) { const i = n('63b6'); const r = n('a159'); const o = n('79aa'); const s = n('e4ae'); const a = n('f772'); const u = n('294c'); const c = n('c189'); const h = (n('e53d').Reflect || {}).construct; const l = u(() => { function t() {} return !(h(() => {}, [], t) instanceof t); }); const f = !u(() => { h(() => {}); }); i(i.S + i.F * (l || f), 'Reflect', { construct(t, e) { o(t), s(e); const n = arguments.length < 3 ? t : o(arguments[2]); if (f && !l) return h(t, e, n); if (t == n) { switch (e.length) { case 0: return new t(); case 1: return new t(e[0]); case 2: return new t(e[0], e[1]); case 3: return new t(e[0], e[1], e[2]); case 4: return new t(e[0], e[1], e[2], e[3]); } const i = [null]; return i.push(...e), new (c.apply(t, i))(); } const u = n.prototype; const p = r(a(u) ? u : Object.prototype); const d = Function.apply.call(t, p, e); return a(d) ? d : p; } }); },
  7496(t, e, n) {
    n('3385'); const i = n('d9bd'); function r(t) { let e = void 0; if (typeof t === 'number')e = t; else { if (typeof t !== 'string') throw new TypeError(`Colors can only be numbers or strings, recieved ${t == null ? t : t.constructor.name} instead`); let n = t[0] === '#' ? t.substring(1) : t; n.length === 3 && (n = n.split('').map(t => t + t).join('')), n.length !== 6 && Object(i.b)(`'${t}' is not a valid rgb color`), e = parseInt(n, 16); } return e < 0 ? (Object(i.b)(`Colors cannot be negative: '${t}'`), e = 0) : (e > 16777215 || isNaN(e)) && (Object(i.b)(`'${t}' is not a valid rgb color`), e = 16777215), e; } function o(t) { let e = t.toString(16); return e.length < 6 && (e = '0'.repeat(6 - e.length) + e), `#${e}`; } function s(t) { return o(r(t)); } const a = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]]; const u = function (t) { return t <= 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055; }; const c = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]]; const h = function (t) { return t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4); }; function l(t) { return Math.max(0, Math.min(1, t)); } function f(t) { for (var e = Array(3), n = u, i = a, r = 0; r < 3; ++r)e[r] = Math.round(255 * l(n(i[r][0] * t[0] + i[r][1] * t[1] + i[r][2] * t[2]))); return (e[0] << 16) + (e[1] << 8) + (e[2] << 0); } function p(t) { for (var e = [0, 0, 0], n = h, i = c, r = n((t >> 16 & 255) / 255), o = n((t >> 8 & 255) / 255), s = n((t >> 0 & 255) / 255), a = 0; a < 3; ++a)e[a] = i[a][0] * r + i[a][1] * o + i[a][2] * s; return e; } const d = 0.20689655172413793; const v = function (t) { return t > Math.pow(d, 3) ? Math.cbrt(t) : t / (3 * Math.pow(d, 2)) + 4 / 29; }; const g = function (t) { return t > d ? Math.pow(t, 3) : 3 * Math.pow(d, 2) * (t - 4 / 29); }; function y(t) { const e = v; const n = e(t[1]); return [116 * n - 16, 500 * (e(t[0] / 0.95047) - n), 200 * (n - e(t[2] / 1.08883))]; } function m(t) { const e = g; const n = (t[0] + 16) / 116; return [0.95047 * e(n + t[1] / 500), e(n), 1.08883 * e(n - t[2] / 200)]; } const _ = (function () { function t(t, e) { const n = []; let i = !0; let r = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done); i = !0) if (n.push(s.value), e && n.length === e) break; } catch (u) { r = !0, o = u; } finally { try { !i && a.return && a.return(); } finally { if (r) throw o; } } return n; } return function (e, n) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, n); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); const b = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; }; function w(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = Object.keys(t), i = {}, o = 0; o < n.length; ++o) { const a = n[o]; const u = t[a]; e ? (a === 'base' || a.startsWith('lighten') || a.startsWith('darken')) && (i[a] = s(u)) : (typeof u === 'undefined' ? 'undefined' : b(u)) === 'object' ? i[a] = w(u, !0) : i[a] = C(a, r(u)); } return i; } const x = function (t, e) { return `\n.${t} {\n  background-color: ${e} !important;\n  border-color: ${e} !important;\n}\n.${t}--text {\n  color: ${e} !important;\n  caret-color: ${e} !important;\n}`; }; const E = function (t, e, n) { const i = e.split(/(\d)/, 2); const r = _(i, 2); const o = r[0]; const s = r[1]; return `\n.${t}.${o}-${s} {\n  background-color: ${n} !important;\n  border-color: ${n} !important;\n}\n.${t}--text.text--${o}-${s} {\n  color: ${n} !important;\n  caret-color: ${n} !important;\n}`; }; const S = function (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'base'; return `--v-${t}-${e}`; }; const T = function (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'base'; return `var(${S(t, e)})`; }; function O(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = Object.keys(t); if (!n.length) return ''; let i = ''; let r = ''; const o = e ? T('primary') : t.primary.base; r += `a { color: ${o}; }`; for (let s = 0; s < n.length; ++s) { const a = n[s]; const u = t[a]; if ((typeof u === 'undefined' ? 'undefined' : b(u)) === 'object') { r += x(a, e ? T(a) : u.base), e && (i += `  ${S(a)}: ${u.base};\n`); for (let c = Object.keys(u), h = 0; h < c.length; ++h) { const l = c[h]; const f = u[l]; l !== 'base' && (r += E(a, l, e ? T(a, l) : f), e && (i += `  ${S(a, l)}: ${f};\n`)); } } } return e && (i = `:root {\n${i}}\n\n`), i + r; } function C(t, e) { for (var n = { base: o(e) }, i = 5; i > 0; --i)n[`lighten${i}`] = o(R(e, i)); for (let r = 1; r <= 4; ++r)n[`darken${r}`] = o(I(e, r)); return n; } function R(t, e) { const n = y(p(t)); return n[0] += 10 * e, f(m(n)); } function I(t, e) { const n = y(p(t)); return n[0] -= 10 * e, f(m(n)); } const P = {
      data() { return { style: null }; }, computed: { parsedTheme() { return w(this.$vuetify.theme); }, generatedStyles() { const t = this.parsedTheme; let e = void 0; return this.$vuetify.options.themeCache != null && (e = this.$vuetify.options.themeCache.get(t), e != null) ? e : (e = O(t, this.$vuetify.options.customProperties), this.$vuetify.options.minifyTheme != null && (e = this.$vuetify.options.minifyTheme(e)), this.$vuetify.options.themeCache != null && this.$vuetify.options.themeCache.set(t, e), e); }, vueMeta() { if (!1 === this.$vuetify.theme) return {}; const t = { cssText: this.generatedStyles, id: 'vuetify-theme-stylesheet', type: 'text/css' }; return this.$vuetify.options.cspNonce && (t.nonce = this.$vuetify.options.cspNonce), { style: [t] }; } }, metaInfo() { return this.vueMeta; }, head() { return this.vueMeta; }, watch: { generatedStyles() { !this.meta && this.applyTheme(); } }, created() { if (!1 !== this.$vuetify.theme) if (this.$meta);else if (typeof document === 'undefined' && this.$ssrContext) { const t = this.$vuetify.options.cspNonce ? ` nonce="${this.$vuetify.options.cspNonce}"` : ''; this.$ssrContext.head = this.$ssrContext.head || '', this.$ssrContext.head += `<style type="text/css" id="vuetify-theme-stylesheet"${t}>${this.generatedStyles}</style>`; } else typeof document !== 'undefined' && (this.genStyle(), this.applyTheme()); }, methods: { applyTheme() { this.style && (this.style.innerHTML = this.generatedStyles); }, genStyle() { let t = document.getElementById('vuetify-theme-stylesheet'); t || (t = document.createElement('style'), t.type = 'text/css', t.id = 'vuetify-theme-stylesheet', this.$vuetify.options.cspNonce && t.setAttribute('nonce', this.$vuetify.options.cspNonce), document.head.appendChild(t)), this.style = t; } },
    }; const L = n('6a18'); function A(t, e) { const n = e.value; const i = e.options || { passive: !0 }; window.addEventListener('resize', n, i), t._onResize = { callback: n, options: i }, e.modifiers && e.modifiers.quiet || n(); } function F(t) { if (t._onResize) { const e = t._onResize; const n = e.callback; const i = e.options; window.removeEventListener('resize', n, i), delete t._onResize; } } const j = { inserted: A, unbind: F }; const k = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; e.a = {
      name: 'v-app',
      directives: { Resize: j },
      mixins: [P, L.a],
      props: { id: { type: String, default: 'app' }, dark: Boolean },
      computed: { classes() { return k({ 'application--is-rtl': this.$vuetify.rtl }, this.themeClasses); } },
      watch: { dark() { this.$vuetify.dark = this.dark; } },
      mounted() { this.$vuetify.dark = this.dark; },
      render(t) {
        const e = {
          staticClass: 'application', class: this.classes, attrs: { 'data-app': !0 }, domProps: { id: this.id },
        }; const n = t('div', { staticClass: 'application--wrap' }, this.$slots.default); return t('div', e, [n]);
      },
    };
  },
  7554(t, e, n) { n('68f7')('Map'); },
  7618(t, e, n) {
    n.d(e, 'a', () => u); const i = n('5d58'); const r = n.n(i); const o = n('67bb'); const s = n.n(o); function a(t) { return a = typeof s.a === 'function' && typeof r.a === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof s.a === 'function' && t.constructor === s.a && t !== s.a.prototype ? 'symbol' : typeof t; }, a(t); } function u(t) { return u = typeof s.a === 'function' && a(r.a) === 'symbol' ? function (t) { return a(t); } : function (t) { return t && typeof s.a === 'function' && t.constructor === s.a && t !== s.a.prototype ? 'symbol' : a(t); }, u(t); }
  },
  '765d': function (t, e, n) { n('6718')('observable'); },
  7726(t, e) { const n = t.exports = typeof window !== 'undefined' && window.Math == Math ? window : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); typeof __g === 'number' && (__g = n); },
  '774e': function (t, e, n) { t.exports = n('d2d5'); },
  '77f1': function (t, e, n) { const i = n('4588'); const r = Math.max; const o = Math.min; t.exports = function (t, e) { return t = i(t), t < 0 ? r(t + e, 0) : o(t, e); }; },
  7915(t, e, n) {
    t.exports = r; const i = n('9152'); function r(t) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length; }r.Varint = 0, r.Fixed64 = 1, r.Bytes = 2, r.Fixed32 = 5; const o = 4294967296; const s = 1 / o; function a(t, e, n) { let i; let r; const o = n.buf; if (r = o[n.pos++], i = (112 & r) >> 4, r < 128) return c(t, i, e); if (r = o[n.pos++], i |= (127 & r) << 3, r < 128) return c(t, i, e); if (r = o[n.pos++], i |= (127 & r) << 10, r < 128) return c(t, i, e); if (r = o[n.pos++], i |= (127 & r) << 17, r < 128) return c(t, i, e); if (r = o[n.pos++], i |= (127 & r) << 24, r < 128) return c(t, i, e); if (r = o[n.pos++], i |= (1 & r) << 31, r < 128) return c(t, i, e); throw new Error('Expected varint not more than 10 bytes'); } function u(t) { return t.type === r.Bytes ? t.readVarint() + t.pos : t.pos + 1; } function c(t, e, n) { return n ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0); } function h(t, e) { let n; let i; if (t >= 0 ? (n = t % 4294967296 | 0, i = t / 4294967296 | 0) : (n = ~(-t % 4294967296), i = ~(-t / 4294967296), 4294967295 ^ n ? n = n + 1 | 0 : (n = 0, i = i + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); e.realloc(10), l(n, i, e), f(i, e); } function l(t, e, n) { n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos++] = 127 & t | 128, t >>>= 7, n.buf[n.pos] = 127 & t; } function f(t, e) { const n = (7 & t) << 4; e.buf[e.pos++] |= n | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t))))); } function p(t, e, n) { const i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.ceil(Math.log(e) / (7 * Math.LN2)); n.realloc(i); for (let r = n.pos - 1; r >= t; r--)n.buf[r + i] = n.buf[r]; } function d(t, e) { for (let n = 0; n < t.length; n++)e.writeVarint(t[n]); } function v(t, e) { for (let n = 0; n < t.length; n++)e.writeSVarint(t[n]); } function g(t, e) { for (let n = 0; n < t.length; n++)e.writeFloat(t[n]); } function y(t, e) { for (let n = 0; n < t.length; n++)e.writeDouble(t[n]); } function m(t, e) { for (let n = 0; n < t.length; n++)e.writeBoolean(t[n]); } function _(t, e) { for (let n = 0; n < t.length; n++)e.writeFixed32(t[n]); } function b(t, e) { for (let n = 0; n < t.length; n++)e.writeSFixed32(t[n]); } function w(t, e) { for (let n = 0; n < t.length; n++)e.writeFixed64(t[n]); } function x(t, e) { for (let n = 0; n < t.length; n++)e.writeSFixed64(t[n]); } function E(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3]; } function S(t, e, n) { t[n] = e, t[n + 1] = e >>> 8, t[n + 2] = e >>> 16, t[n + 3] = e >>> 24; } function T(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24); } function O(t, e, n) { let i = ''; let r = e; while (r < n) { var o; var s; var a; const u = t[r]; let c = null; let h = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1; if (r + h > n) break; h === 1 ? u < 128 && (c = u) : h === 2 ? (o = t[r + 1], (192 & o) === 128 && (c = (31 & u) << 6 | 63 & o, c <= 127 && (c = null))) : h === 3 ? (o = t[r + 1], s = t[r + 2], (192 & o) === 128 && (192 & s) === 128 && (c = (15 & u) << 12 | (63 & o) << 6 | 63 & s, (c <= 2047 || c >= 55296 && c <= 57343) && (c = null))) : h === 4 && (o = t[r + 1], s = t[r + 2], a = t[r + 3], (192 & o) === 128 && (192 & s) === 128 && (192 & a) === 128 && (c = (15 & u) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a, (c <= 65535 || c >= 1114112) && (c = null))), c === null ? (c = 65533, h = 1) : c > 65535 && (c -= 65536, i += String.fromCharCode(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), i += String.fromCharCode(c), r += h; } return i; } function C(t, e, n) { for (var i, r, o = 0; o < e.length; o++) { if (i = e.charCodeAt(o), i > 55295 && i < 57344) { if (!r) { i > 56319 || o + 1 === e.length ? (t[n++] = 239, t[n++] = 191, t[n++] = 189) : r = i; continue; } if (i < 56320) { t[n++] = 239, t[n++] = 191, t[n++] = 189, r = i; continue; }i = r - 55296 << 10 | i - 56320 | 65536, r = null; } else r && (t[n++] = 239, t[n++] = 191, t[n++] = 189, r = null); i < 128 ? t[n++] = i : (i < 2048 ? t[n++] = i >> 6 | 192 : (i < 65536 ? t[n++] = i >> 12 | 224 : (t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128), t[n++] = i >> 6 & 63 | 128), t[n++] = 63 & i | 128); } return n; }r.prototype = {
      destroy() { this.buf = null; }, readFields(t, e, n) { n = n || this.length; while (this.pos < n) { const i = this.readVarint(); const r = i >> 3; const o = this.pos; this.type = 7 & i, t(r, e, this), this.pos === o && this.skip(i); } return e; }, readMessage(t, e) { return this.readFields(t, e, this.readVarint() + this.pos); }, readFixed32() { const t = E(this.buf, this.pos); return this.pos += 4, t; }, readSFixed32() { const t = T(this.buf, this.pos); return this.pos += 4, t; }, readFixed64() { const t = E(this.buf, this.pos) + E(this.buf, this.pos + 4) * o; return this.pos += 8, t; }, readSFixed64() { const t = E(this.buf, this.pos) + T(this.buf, this.pos + 4) * o; return this.pos += 8, t; }, readFloat() { const t = i.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, t; }, readDouble() { const t = i.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, t; }, readVarint(t) { let e; let n; const i = this.buf; return n = i[this.pos++], e = 127 & n, n < 128 ? e : (n = i[this.pos++], e |= (127 & n) << 7, n < 128 ? e : (n = i[this.pos++], e |= (127 & n) << 14, n < 128 ? e : (n = i[this.pos++], e |= (127 & n) << 21, n < 128 ? e : (n = i[this.pos], e |= (15 & n) << 28, a(e, t, this))))); }, readVarint64() { return this.readVarint(!0); }, readSVarint() { const t = this.readVarint(); return t % 2 === 1 ? (t + 1) / -2 : t / 2; }, readBoolean() { return Boolean(this.readVarint()); }, readString() { const t = this.readVarint() + this.pos; const e = O(this.buf, this.pos, t); return this.pos = t, e; }, readBytes() { const t = this.readVarint() + this.pos; const e = this.buf.subarray(this.pos, t); return this.pos = t, e; }, readPackedVarint(t, e) { const n = u(this); t = t || []; while (this.pos < n)t.push(this.readVarint(e)); return t; }, readPackedSVarint(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readSVarint()); return t; }, readPackedBoolean(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readBoolean()); return t; }, readPackedFloat(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readFloat()); return t; }, readPackedDouble(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readDouble()); return t; }, readPackedFixed32(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readFixed32()); return t; }, readPackedSFixed32(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readSFixed32()); return t; }, readPackedFixed64(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readFixed64()); return t; }, readPackedSFixed64(t) { const e = u(this); t = t || []; while (this.pos < e)t.push(this.readSFixed64()); return t; }, skip(t) { const e = 7 & t; if (e === r.Varint) while (this.buf[this.pos++] > 127);else if (e === r.Bytes) this.pos = this.readVarint() + this.pos; else if (e === r.Fixed32) this.pos += 4; else { if (e !== r.Fixed64) throw new Error(`Unimplemented type: ${e}`); this.pos += 8; } }, writeTag(t, e) { this.writeVarint(t << 3 | e); }, realloc(t) { let e = this.length || 16; while (e < this.pos + t)e *= 2; if (e !== this.length) { const n = new Uint8Array(e); n.set(this.buf), this.buf = n, this.length = e; } }, finish() { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length); }, writeFixed32(t) { this.realloc(4), S(this.buf, t, this.pos), this.pos += 4; }, writeSFixed32(t) { this.realloc(4), S(this.buf, t, this.pos), this.pos += 4; }, writeFixed64(t) { this.realloc(8), S(this.buf, -1 & t, this.pos), S(this.buf, Math.floor(t * s), this.pos + 4), this.pos += 8; }, writeSFixed64(t) { this.realloc(8), S(this.buf, -1 & t, this.pos), S(this.buf, Math.floor(t * s), this.pos + 4), this.pos += 8; }, writeVarint(t) { t = +t || 0, t > 268435455 || t < 0 ? h(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127)))); }, writeSVarint(t) { this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t); }, writeBoolean(t) { this.writeVarint(Boolean(t)); }, writeString(t) { t = String(t), this.realloc(4 * t.length), this.pos++; const e = this.pos; this.pos = C(this.buf, t, this.pos); const n = this.pos - e; n >= 128 && p(e, n, this), this.pos = e - 1, this.writeVarint(n), this.pos += n; }, writeFloat(t) { this.realloc(4), i.write(this.buf, t, this.pos, !0, 23, 4), this.pos += 4; }, writeDouble(t) { this.realloc(8), i.write(this.buf, t, this.pos, !0, 52, 8), this.pos += 8; }, writeBytes(t) { const e = t.length; this.writeVarint(e), this.realloc(e); for (let n = 0; n < e; n++) this.buf[this.pos++] = t[n]; }, writeRawMessage(t, e) { this.pos++; const n = this.pos; t(e, this); const i = this.pos - n; i >= 128 && p(n, i, this), this.pos = n - 1, this.writeVarint(i), this.pos += i; }, writeMessage(t, e, n) { this.writeTag(t, r.Bytes), this.writeRawMessage(e, n); }, writePackedVarint(t, e) { this.writeMessage(t, d, e); }, writePackedSVarint(t, e) { this.writeMessage(t, v, e); }, writePackedBoolean(t, e) { this.writeMessage(t, m, e); }, writePackedFloat(t, e) { this.writeMessage(t, g, e); }, writePackedDouble(t, e) { this.writeMessage(t, y, e); }, writePackedFixed32(t, e) { this.writeMessage(t, _, e); }, writePackedSFixed32(t, e) { this.writeMessage(t, b, e); }, writePackedFixed64(t, e) { this.writeMessage(t, w, e); }, writePackedSFixed64(t, e) { this.writeMessage(t, x, e); }, writeBytesField(t, e) { this.writeTag(t, r.Bytes), this.writeBytes(e); }, writeFixed32Field(t, e) { this.writeTag(t, r.Fixed32), this.writeFixed32(e); }, writeSFixed32Field(t, e) { this.writeTag(t, r.Fixed32), this.writeSFixed32(e); }, writeFixed64Field(t, e) { this.writeTag(t, r.Fixed64), this.writeFixed64(e); }, writeSFixed64Field(t, e) { this.writeTag(t, r.Fixed64), this.writeSFixed64(e); }, writeVarintField(t, e) { this.writeTag(t, r.Varint), this.writeVarint(e); }, writeSVarintField(t, e) { this.writeTag(t, r.Varint), this.writeSVarint(e); }, writeStringField(t, e) { this.writeTag(t, r.Bytes), this.writeString(e); }, writeFloatField(t, e) { this.writeTag(t, r.Fixed32), this.writeFloat(e); }, writeDoubleField(t, e) { this.writeTag(t, r.Fixed64), this.writeDouble(e); }, writeBooleanField(t, e) { this.writeVarintField(t, Boolean(e)); },
    };
  },
  '794b': function (t, e, n) { t.exports = !n('8e60') && !n('294c')(() => Object.defineProperty(n('1ec9')('div'), 'a', { get() { return 7; } }).a != 7); },
  '795b': function (t, e, n) { t.exports = n('696e'); },
  '79aa': function (t, e) { t.exports = function (t) { if (typeof t !== 'function') throw TypeError(`${t} is not a function!`); return t; }; },
  '79e5': function (t, e) { t.exports = function (t) { try { return !!t(); } catch (e) { return !0; } }; },
  '7a56': function (t, e, n) {
    const i = n('7726'); const r = n('86cc'); const o = n('9e1e'); const s = n('2b4c')('species'); t.exports = function (t) { const e = i[t]; o && e && !e[s] && r.f(e, s, { configurable: !0, get() { return this; } }); };
  },
  '7a77': function (t, e, n) {
    function i(t) { this.message = t; }i.prototype.toString = function () { return `Cancel${this.message ? `: ${this.message}` : ''}`; }, i.prototype.__CANCEL__ = !0, t.exports = i;
  },
  '7aac': function (t, e, n) {
    const i = n('c532'); t.exports = i.isStandardBrowserEnv() ? (function () { return { write(t, e, n, r, o, s) { const a = []; a.push(`${t}=${encodeURIComponent(e)}`), i.isNumber(n) && a.push(`expires=${new Date(n).toGMTString()}`), i.isString(r) && a.push(`path=${r}`), i.isString(o) && a.push(`domain=${o}`), !0 === s && a.push('secure'), document.cookie = a.join('; '); }, read(t) { const e = document.cookie.match(new RegExp(`(^|;\\s*)(${t})=([^;]*)`)); return e ? decodeURIComponent(e[3]) : null; }, remove(t) { this.write(t, '', Date.now() - 864e5); } }; }()) : (function () { return { write() {}, read() { return null; }, remove() {} }; }());
  },
  '7be7': function (t, e, n) { n('0a90'), t.exports = n('584a').parseFloat; },
  '7cd6': function (t, e, n) { const i = n('40c3'); const r = n('5168')('iterator'); const o = n('481b'); t.exports = n('584a').getIteratorMethod = function (t) { if (void 0 != t) return t[r] || t['@@iterator'] || o[i(t)]; }; },
  '7d6d': function (t, e, n) { const i = n('63b6'); const r = n('13c8')(!1); i(i.S, 'Object', { values(t) { return r(t); } }); },
  '7d7b': function (t, e, n) { const i = n('e4ae'); const r = n('7cd6'); t.exports = n('584a').getIterator = function (t) { const e = r(t); if (typeof e !== 'function') throw TypeError(`${t} is not iterable!`); return i(e.call(t)); }; },
  '7e90': function (t, e, n) { const i = n('d9f6'); const r = n('e4ae'); const o = n('c3a1'); t.exports = n('8e60') ? Object.defineProperties : function (t, e) { r(t); let n; const s = o(e); const a = s.length; let u = 0; while (a > u)i.f(t, n = s[u++], e[n]); return t; }; },
  '7f20': function (t, e, n) { const i = n('86cc').f; const r = n('69a8'); const o = n('2b4c')('toStringTag'); t.exports = function (t, e, n) { t && !r(t = n ? t : t.prototype, o) && i(t, o, { configurable: !0, value: e }); }; },
  8079(t, e, n) { const i = n('7726'); const r = n('1991').set; const o = i.MutationObserver || i.WebKitMutationObserver; const s = i.process; const a = i.Promise; const u = n('2d95')(s) == 'process'; t.exports = function () { let t; let e; let n; const c = function () { let i; let r; u && (i = s.domain) && i.exit(); while (t) { r = t.fn, t = t.next; try { r(); } catch (o) { throw t ? n() : e = void 0, o; } }e = void 0, i && i.enter(); }; if (u)n = function () { s.nextTick(c); }; else if (!o || i.navigator && i.navigator.standalone) if (a && a.resolve) { const h = a.resolve(void 0); n = function () { h.then(c); }; } else n = function () { r.call(i, c); }; else { let l = !0; const f = document.createTextNode(''); new o(c).observe(f, { characterData: !0 }), n = function () { f.data = l = !l; }; } return function (i) { const r = { fn: i, next: void 0 }; e && (e.next = r), t || (t = r, n()), e = r; }; }; },
  '80d2': function (t, e, n) {
    n.d(e, 'b', () => i), n.d(e, 'd', () => o), n.d(e, 'c', () => s), n.d(e, 'a', () => a), n.d(e, 'f', () => c), n.d(e, 'e', () => h); typeof Symbol === 'function' && Symbol.iterator, Object.assign; function i(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'div'; const
        n = arguments[2]; return { name: n || t.replace(/__/g, '-'), functional: !0, render(n, i) { const r = i.data; const o = i.children; return r.staticClass = (`${t} ${r.staticClass || ''}`).trim(), n(e, r, o); } };
    } function r(t, e, n) { const i = e.length - 1; if (i < 0) return void 0 === t ? n : t; for (let r = 0; r < i; r++) { if (t == null) return n; t = t[e[r]]; } return t == null ? n : void 0 === t[e[i]] ? n : t[e[i]]; } function o(t, e, n) { return e && e.constructor === String ? (e = e.replace(/\[(\w+)\]/g, '.$1'), e = e.replace(/^\./, ''), r(t, e.split('.'), n)) : n; } function s(t, e) { for (var n = {}, i = 0; i < e.length; i++) { const r = e[i]; typeof t[r] !== 'undefined' && (n[r] = t[r]); } return n; } function a(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'px'; return t == null || t === '' ? void 0 : isNaN(+t) ? String(t) : `${Number(t)}${e}`; }Object.freeze({
      enter: 13, tab: 9, delete: 46, esc: 27, space: 32, up: 38, down: 40, left: 37, right: 39, end: 35, home: 36, del: 46, backspace: 8, insert: 45, pageup: 33, pagedown: 34,
    }); const u = '$vuetify.icons.'; function c(t, e) { return e.startsWith(u) ? o(t, e, e) : e; } function h(t) { return Object.keys(t); }
  },
  8336(t, e, n) {
    n('bced'); const i = n('58df'); const r = (n('2074'), n('b64a')); const o = Object(i.a)(r.a).extend({
      name: 'v-progress-circular',
      props: {
        button: Boolean, indeterminate: Boolean, rotate: { type: Number, default: 0 }, size: { type: [Number, String], default: 32 }, width: { type: Number, default: 4 }, value: { type: [Number, String], default: 0 },
      },
      computed: {
        calculatedSize() { return Number(this.size) + (this.button ? 8 : 0); }, circumference() { return 2 * Math.PI * this.radius; }, classes() { return { 'v-progress-circular--indeterminate': this.indeterminate, 'v-progress-circular--button': this.button }; }, normalizedValue() { return this.value < 0 ? 0 : this.value > 100 ? 100 : parseFloat(this.value); }, radius() { return 20; }, strokeDashArray() { return Math.round(1e3 * this.circumference) / 1e3; }, strokeDashOffset() { return `${(100 - this.normalizedValue) / 100 * this.circumference}px`; }, strokeWidth() { return this.width / +this.size * this.viewBoxSize * 2; }, styles() { return { height: `${this.calculatedSize}px`, width: `${this.calculatedSize}px` }; }, svgStyles() { return { transform: `rotate(${this.rotate}deg)` }; }, viewBoxSize() { return this.radius / (1 - this.width / +this.size); },
      },
      methods: {
        genCircle(t, e, n) {
          return t('circle', {
            class: `v-progress-circular__${e}`,
            attrs: {
              fill: 'transparent', cx: 2 * this.viewBoxSize, cy: 2 * this.viewBoxSize, r: this.radius, 'stroke-width': this.strokeWidth, 'stroke-dasharray': this.strokeDashArray, 'stroke-dashoffset': n,
            },
          });
        },
        genSvg(t) { const e = [this.indeterminate || this.genCircle(t, 'underlay', 0), this.genCircle(t, 'overlay', this.strokeDashOffset)]; return t('svg', { style: this.svgStyles, attrs: { xmlns: 'http://www.w3.org/2000/svg', viewBox: `${this.viewBoxSize} ${this.viewBoxSize} ${2 * this.viewBoxSize} ${2 * this.viewBoxSize}` } }, e); },
      },
      render(t) {
        const e = t('div', { staticClass: 'v-progress-circular__info' }, [this.$slots.default]); const n = this.genSvg(t); return t('div', this.setTextColor(this.color, {
          staticClass: 'v-progress-circular',
          attrs: {
            role: 'progressbar', 'aria-valuemin': 0, 'aria-valuemax': 100, 'aria-valuenow': this.indeterminate ? void 0 : this.normalizedValue,
          },
          class: this.classes,
          style: this.styles,
          on: this.$listeners,
        }), [n, e]);
      },
    }); const s = o; const a = n('2b0e'); const u = n('d9bd'); function c(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function h(t, e) { return function () { return Object(u.b)(`The ${t} component must be used inside a ${e}`); }; } function l(t, e, n) { const i = e && n ? { register: h(e, n), unregister: h(e, n) } : null; return a.a.extend({ name: 'registrable-inject', inject: c({}, t, { default: i }) }); } function f(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function p(t, e, n) {
      return l(t, e, n).extend({
        name: 'groupable', props: { activeClass: { type: String, default() { if (this[t]) return this[t].activeClass; } }, disabled: Boolean }, data() { return { isActive: !1 }; }, computed: { groupClasses() { return this.activeClass ? f({}, this.activeClass, this.isActive) : {}; } }, created() { this[t] && this[t].register(this); }, beforeDestroy() { this[t] && this[t].unregister(this); }, methods: { toggle() { this.$emit('change'); } },
      });
    }p('itemGroup'); const d = n('c22b'); const v = n('0d01'); const g = n('6a18'); function y(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function m() {
      let t; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'value'; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'input'; return a.a.extend({
        name: 'toggleable', model: { prop: e, event: n }, props: y({}, e, { required: !1 }), data() { return { isActive: !!this[e] }; }, watch: (t = {}, y(t, e, function (t) { this.isActive = !!t; }), y(t, 'isActive', function (t) { !!t !== this[e] && this.$emit(n, t); }), t),
      });
    }m(); const _ = n('80d2'); const b = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; }; const w = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; function x(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    }e.a = Object(i.a)(r.a, v.a, d.a, g.a, p('btnToggle'), m('inputValue')).extend({
      name: 'v-btn',
      props: {
        activeClass: { type: String, default: 'v-btn--active' }, block: Boolean, depressed: Boolean, fab: Boolean, flat: Boolean, icon: Boolean, large: Boolean, loading: Boolean, outline: Boolean, ripple: { type: [Boolean, Object], default: null }, round: Boolean, small: Boolean, tag: { type: String, default: 'button' }, type: { type: String, default: 'button' }, value: null,
      },
      computed: { classes() { let t; return w((t = { 'v-btn': !0 }, x(t, this.activeClass, this.isActive), x(t, 'v-btn--absolute', this.absolute), x(t, 'v-btn--block', this.block), x(t, 'v-btn--bottom', this.bottom), x(t, 'v-btn--disabled', this.disabled), x(t, 'v-btn--flat', this.flat), x(t, 'v-btn--floating', this.fab), x(t, 'v-btn--fixed', this.fixed), x(t, 'v-btn--icon', this.icon), x(t, 'v-btn--large', this.large), x(t, 'v-btn--left', this.left), x(t, 'v-btn--loader', this.loading), x(t, 'v-btn--outline', this.outline), x(t, 'v-btn--depressed', this.depressed && !this.flat || this.outline), x(t, 'v-btn--right', this.right), x(t, 'v-btn--round', this.round), x(t, 'v-btn--router', this.to), x(t, 'v-btn--small', this.small), x(t, 'v-btn--top', this.top), t), this.themeClasses); }, computedRipple() { const t = !this.icon && !this.fab || { circle: !0 }; return !this.disabled && (this.ripple !== null ? this.ripple : t); } },
      watch: { $route: 'onRouteChange' },
      methods: {
        click(t) { !this.fab && t.detail && this.$el.blur(), this.$emit('click', t), this.btnToggle && this.toggle(); }, genContent() { return this.$createElement('div', { class: 'v-btn__content' }, [this.$slots.default]); }, genLoader() { const t = []; return this.$slots.loader ? t.push(this.$slots.loader) : t.push(this.$createElement(s, { props: { indeterminate: !0, size: 23, width: 2 } })), this.$createElement('span', { class: 'v-btn__loading' }, t); }, onRouteChange() { const t = this; if (this.to && this.$refs.link) { const e = `_vnode.data.class.${this.activeClass}`; this.$nextTick(() => { Object(_.d)(t.$refs.link, e) && t.toggle(); }); } },
      },
      render(t) { const e = this.outline || this.flat || this.disabled ? this.setTextColor : this.setBackgroundColor; const n = this.generateRouteLink(this.classes); const i = n.tag; const r = n.data; const o = [this.genContent()]; return i === 'button' && (r.attrs.type = this.type), this.loading && o.push(this.genLoader()), r.attrs.value = ['string', 'number'].includes(b(this.value)) ? this.value : JSON.stringify(this.value), this.btnToggle && (r.ref = 'link'), t(i, e(this.color, r), o); },
    });
  },
  8378(t, e) { const n = t.exports = { version: '2.6.0' }; typeof __e === 'number' && (__e = n); },
  '837d': function (t, e, n) {
    const i = n('5aee'); const r = n('9f79'); const o = 'Map'; t.exports = n('ada4')(o, t => function () { return t(this, arguments.length > 0 ? arguments[0] : void 0); }, { get(t) { const e = i.getEntry(r(this, o), t); return e && e.v; }, set(t, e) { return i.def(r(this, o), t === 0 ? 0 : t, e); } }, i, !0);
  },
  8436(t, e) { t.exports = function () {}; },
  '84f2': function (t, e) { t.exports = {}; },
  '85f2': function (t, e, n) { t.exports = n('454f'); },
  '86cc': function (t, e, n) { const i = n('cb7c'); const r = n('c69a'); const o = n('6a99'); const s = Object.defineProperty; e.f = n('9e1e') ? Object.defineProperty : function (t, e, n) { if (i(t), e = o(e, !0), i(n), r) try { return s(t, e, n); } catch (a) {} if ('get' in n || 'set' in n) throw TypeError('Accessors not supported!'); return 'value' in n && (t[e] = n.value), t; }; },
  '887a': function (t, e, n) {
    n('1069'); const i = n('c6f7'); const r = (n('58db'), n('2b0e')); function o(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function s() {
      const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'value'; const
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'change'; return r.a.extend({
        name: 'proxyable', model: { prop: t, event: e }, props: o({}, t, { required: !1 }), data() { return { internalLazyValue: this[t] }; }, computed: { internalValue: { get() { return this.internalLazyValue; }, set(t) { t !== this.internalLazyValue && (this.internalLazyValue = t, this.$emit(e, t)); } } }, watch: o({}, t, function (t) { this.internalLazyValue = t; }),
      });
    } const a = s(); const u = a; const c = n('6a18'); const h = n('58df'); const l = n('d9bd'); const f = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; const p = Object(h.a)(u, c.a).extend({
      name: 'base-item-group',
      props: {
        activeClass: { type: String, default: 'v-item--active' }, mandatory: Boolean, max: { type: [Number, String], default: null }, multiple: Boolean,
      },
      data() { return { internalLazyValue: void 0 !== this.value ? this.value : this.multiple ? [] : void 0, items: [] }; },
      computed: {
        classes() { return f({}, this.themeClasses); }, selectedItems() { const t = this; return this.items.filter((e, n) => t.toggleMethod(t.getValue(e, n))); }, selectedValues() { return Array.isArray(this.internalValue) ? this.internalValue : [this.internalValue]; }, toggleMethod() { const t = this; if (!this.multiple) return function (e) { return t.internalValue === e; }; const e = this.internalValue; return Array.isArray(e) ? function (t) { return e.includes(t); } : function () { return !1; }; },
      },
      watch: { internalValue() { this.$nextTick(this.updateItemsState); } },
      created() { this.multiple && !Array.isArray(this.internalValue) && Object(l.b)('Model must be bound to an array if the multiple property is true.', this); },
      methods: {
        getValue(t, e) { return t.value == null || t.value === '' ? e : t.value; }, onClick(t, e) { this.updateInternalValue(this.getValue(t, e)); }, register(t) { const e = this; const n = this.items.push(t) - 1; t.$on('change', () => e.onClick(t, n)), this.mandatory && this.internalLazyValue == null && this.updateMandatory(), this.updateItem(t, n); }, unregister(t) { if (!this._isDestroyed) { const e = this.items.indexOf(t); const n = this.getValue(t, e); this.items.splice(e, 1); const i = this.selectedValues.indexOf(n); if (!(i < 0)) { if (!this.mandatory) return this.updateInternalValue(n); this.multiple && Array.isArray(this.internalValue) ? this.internalValue = this.internalValue.filter(t => t !== n) : this.internalValue = void 0, this.selectedItems.length || this.updateMandatory(!0); } } }, updateItem(t, e) { const n = this.getValue(t, e); t.isActive = this.toggleMethod(n); }, updateItemsState() { if (this.mandatory && !this.selectedItems.length) return this.updateMandatory(); this.items.forEach(this.updateItem); }, updateInternalValue(t) { this.multiple ? this.updateMultiple(t) : this.updateSingle(t); }, updateMandatory(t) { if (this.items.length) { const e = t ? this.items.length - 1 : 0; this.updateInternalValue(this.getValue(this.items[e], e)); } }, updateMultiple(t) { const e = Array.isArray(this.internalValue) ? this.internalValue : []; const n = e.slice(); const i = n.findIndex(e => e === t); this.mandatory && i > -1 && n.length - 1 < 1 || this.max != null && i < 0 && n.length + 1 > this.max || (i > -1 ? n.splice(i, 1) : n.push(t), this.internalValue = n); }, updateSingle(t) { const e = t === this.internalValue; this.mandatory && e || (this.internalValue = e ? void 0 : t); },
      },
      render(t) { return t('div', { staticClass: 'v-item-group', class: this.classes }, this.$slots.default); },
    }); const d = (p.extend({ name: 'v-item-group', provide() { return { itemGroup: this }; } }), p.extend({
      name: 'button-group', provide() { return { btnToggle: this }; }, props: { activeClass: { type: String, default: 'v-btn--active' } }, computed: { classes() { return p.options.computed.classes.call(this); } },
    })); const v = n('b64a'); e.a = Object(h.a)(Object(i.a)('bottom', ['height', 'value']), v.a).extend({
      name: 'v-bottom-nav',
      props: {
        active: [Number, String], mandatory: Boolean, height: { default: 56, type: [Number, String], validator(t) { return !isNaN(parseInt(t)); } }, shift: Boolean, value: null,
      },
      computed: {
        classes() {
          return {
            'v-bottom-nav--absolute': this.absolute, 'v-bottom-nav--fixed': !this.absolute && (this.app || this.fixed), 'v-bottom-nav--shift': this.shift, 'v-bottom-nav--active': this.value,
          };
        },
        computedHeight() { return parseInt(this.height); },
      },
      methods: { updateApplication() { return this.value ? this.computedHeight : 0; }, updateValue(t) { this.$emit('update:active', t); } },
      render(t) {
        return t(d, this.setBackgroundColor(this.color, {
          staticClass: 'v-bottom-nav', class: this.classes, style: { height: `${parseInt(this.computedHeight)}px` }, props: { mandatory: Boolean(this.mandatory || void 0 !== this.active), value: this.active }, on: { change: this.updateValue },
        }), this.$slots.default);
      },
    });
  },
  '8aae': function (t, e, n) { n('32a6'), t.exports = n('584a').Object.keys; },
  '8c4f': function (t, e, n) {
    /*!
  * vue-router v3.0.2
  * (c) 2018 Evan You
  * @license MIT
  */function i(t, e) { 0; } function r(t) { return Object.prototype.toString.call(t).indexOf('Error') > -1; } function o(t, e) { for (const n in e)t[n] = e[n]; return t; } const s = {
      name: 'RouterView', functional: !0, props: { name: { type: String, default: 'default' } }, render(t, e) { const n = e.props; const i = e.children; let r = e.parent; const s = e.data; s.routerView = !0; const u = r.$createElement; const c = n.name; const h = r.$route; const l = r._routerViewCache || (r._routerViewCache = {}); let f = 0; let p = !1; while (r && r._routerRoot !== r)r.$vnode && r.$vnode.data.routerView && f++, r._inactive && (p = !0), r = r.$parent; if (s.routerViewDepth = f, p) return u(l[c], s, i); const d = h.matched[f]; if (!d) return l[c] = null, u(); const v = l[c] = d.components[c]; s.registerRouteInstance = function (t, e) { const n = d.instances[c]; (e && n !== t || !e && n === t) && (d.instances[c] = e); }, (s.hook || (s.hook = {})).prepatch = function (t, e) { d.instances[c] = e.componentInstance; }; let g = s.props = a(h, d.props && d.props[c]); if (g) { g = s.props = o({}, g); const y = s.attrs = s.attrs || {}; for (const m in g)v.props && m in v.props || (y[m] = g[m], delete g[m]); } return u(v, s, i); },
    }; function a(t, e) { switch (typeof e) { case 'undefined': return; case 'object': return e; case 'function': return e(t); case 'boolean': return e ? t.params : void 0; default: 0; } } const u = /[!'()*]/g; const c = function (t) { return `%${t.charCodeAt(0).toString(16)}`; }; const h = /%2C/g; const l = function (t) { return encodeURIComponent(t).replace(u, c).replace(h, ','); }; const f = decodeURIComponent; function p(t, e, n) { void 0 === e && (e = {}); let i; const r = n || d; try { i = r(t || ''); } catch (s) { i = {}; } for (const o in e)i[o] = e[o]; return i; } function d(t) { const e = {}; return t = t.trim().replace(/^(\?|#|&)/, ''), t ? (t.split('&').forEach((t) => { const n = t.replace(/\+/g, ' ').split('='); const i = f(n.shift()); const r = n.length > 0 ? f(n.join('=')) : null; void 0 === e[i] ? e[i] = r : Array.isArray(e[i]) ? e[i].push(r) : e[i] = [e[i], r]; }), e) : e; } function v(t) { const e = t ? Object.keys(t).map((e) => { const n = t[e]; if (void 0 === n) return ''; if (n === null) return l(e); if (Array.isArray(n)) { const i = []; return n.forEach((t) => { void 0 !== t && (t === null ? i.push(l(e)) : i.push(`${l(e)}=${l(t)}`)); }), i.join('&'); } return `${l(e)}=${l(n)}`; }).filter(t => t.length > 0).join('&') : null; return e ? `?${e}` : ''; } const g = /\/?$/; function y(t, e, n, i) {
      const r = i && i.options.stringifyQuery; let o = e.query || {}; try { o = m(o); } catch (a) {} const s = {
        name: e.name || t && t.name, meta: t && t.meta || {}, path: e.path || '/', hash: e.hash || '', query: o, params: e.params || {}, fullPath: w(e, r), matched: t ? b(t) : [],
      }; return n && (s.redirectedFrom = w(n, r)), Object.freeze(s);
    } function m(t) { if (Array.isArray(t)) return t.map(m); if (t && typeof t === 'object') { const e = {}; for (const n in t)e[n] = m(t[n]); return e; } return t; } const _ = y(null, { path: '/' }); function b(t) { const e = []; while (t)e.unshift(t), t = t.parent; return e; } function w(t, e) { const n = t.path; let i = t.query; void 0 === i && (i = {}); let r = t.hash; void 0 === r && (r = ''); const o = e || v; return (n || '/') + o(i) + r; } function x(t, e) { return e === _ ? t === e : !!e && (t.path && e.path ? t.path.replace(g, '') === e.path.replace(g, '') && t.hash === e.hash && E(t.query, e.query) : !(!t.name || !e.name) && (t.name === e.name && t.hash === e.hash && E(t.query, e.query) && E(t.params, e.params))); } function E(t, e) { if (void 0 === t && (t = {}), void 0 === e && (e = {}), !t || !e) return t === e; const n = Object.keys(t); const i = Object.keys(e); return n.length === i.length && n.every((n) => { const i = t[n]; const r = e[n]; return typeof i === 'object' && typeof r === 'object' ? E(i, r) : String(i) === String(r); }); } function S(t, e) { return t.path.replace(g, '/').indexOf(e.path.replace(g, '/')) === 0 && (!e.hash || t.hash === e.hash) && T(t.query, e.query); } function T(t, e) { for (const n in e) if (!(n in t)) return !1; return !0; } let O; const C = [String, Object]; const R = [String, Array]; const I = {
      name: 'RouterLink',
      props: {
        to: { type: C, required: !0 }, tag: { type: String, default: 'a' }, exact: Boolean, append: Boolean, replace: Boolean, activeClass: String, exactActiveClass: String, event: { type: R, default: 'click' },
      },
      render(t) { const e = this; const n = this.$router; const i = this.$route; const r = n.resolve(this.to, i, this.append); const s = r.location; const a = r.route; const u = r.href; const c = {}; const h = n.options.linkActiveClass; const l = n.options.linkExactActiveClass; const f = h == null ? 'router-link-active' : h; const p = l == null ? 'router-link-exact-active' : l; const d = this.activeClass == null ? f : this.activeClass; const v = this.exactActiveClass == null ? p : this.exactActiveClass; const g = s.path ? y(null, s, null, n) : a; c[v] = x(i, g), c[d] = this.exact ? c[v] : S(i, g); const m = function (t) { P(t) && (e.replace ? n.replace(s) : n.push(s)); }; const _ = { click: P }; Array.isArray(this.event) ? this.event.forEach((t) => { _[t] = m; }) : _[this.event] = m; const b = { class: c }; if (this.tag === 'a')b.on = _, b.attrs = { href: u }; else { const w = L(this.$slots.default); if (w) { w.isStatic = !1; const E = w.data = o({}, w.data); E.on = _; const T = w.data.attrs = o({}, w.data.attrs); T.href = u; } else b.on = _; } return t(this.tag, b, this.$slots.default); },
    }; function P(t) { if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && (void 0 === t.button || t.button === 0)) { if (t.currentTarget && t.currentTarget.getAttribute) { const e = t.currentTarget.getAttribute('target'); if (/\b_blank\b/i.test(e)) return; } return t.preventDefault && t.preventDefault(), !0; } } function L(t) { if (t) for (var e, n = 0; n < t.length; n++) { if (e = t[n], e.tag === 'a') return e; if (e.children && (e = L(e.children))) return e; } } function A(t) { if (!A.installed || O !== t) { A.installed = !0, O = t; const e = function (t) { return void 0 !== t; }; const n = function (t, n) { let i = t.$options._parentVnode; e(i) && e(i = i.data) && e(i = i.registerRouteInstance) && i(t, n); }; t.mixin({ beforeCreate() { e(this.$options.router) ? (this._routerRoot = this, this._router = this.$options.router, this._router.init(this), t.util.defineReactive(this, '_route', this._router.history.current)) : this._routerRoot = this.$parent && this.$parent._routerRoot || this, n(this, this); }, destroyed() { n(this); } }), Object.defineProperty(t.prototype, '$router', { get() { return this._routerRoot._router; } }), Object.defineProperty(t.prototype, '$route', { get() { return this._routerRoot._route; } }), t.component('RouterView', s), t.component('RouterLink', I); const i = t.config.optionMergeStrategies; i.beforeRouteEnter = i.beforeRouteLeave = i.beforeRouteUpdate = i.created; } } const F = typeof window !== 'undefined'; function j(t, e, n) { const i = t.charAt(0); if (i === '/') return t; if (i === '?' || i === '#') return e + t; const r = e.split('/'); n && r[r.length - 1] || r.pop(); for (let o = t.replace(/^\//, '').split('/'), s = 0; s < o.length; s++) { const a = o[s]; a === '..' ? r.pop() : a !== '.' && r.push(a); } return r[0] !== '' && r.unshift(''), r.join('/'); } function k(t) { let e = ''; let n = ''; const i = t.indexOf('#'); i >= 0 && (e = t.slice(i), t = t.slice(0, i)); const r = t.indexOf('?'); return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { path: t, query: n, hash: e }; } function M(t) { return t.replace(/\/\//g, '/'); } const N = Array.isArray || function (t) { return Object.prototype.toString.call(t) == '[object Array]'; }; const D = it; const $ = z; const G = Y; const V = K; const B = nt; const U = new RegExp(['(\\\\.)', '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g'); function z(t, e) {
      let n; const i = []; let r = 0; let o = 0; let s = ''; const a = e && e.delimiter || '/'; while ((n = U.exec(t)) != null) {
        const u = n[0]; const c = n[1]; const h = n.index; if (s += t.slice(o, h), o = h + u.length, c)s += c[1]; else {
          const l = t[o]; const f = n[2]; const p = n[3]; const d = n[4]; const v = n[5]; const g = n[6]; const y = n[7]; s && (i.push(s), s = ''); const m = f != null && l != null && l !== f; const _ = g === '+' || g === '*'; const b = g === '?' || g === '*'; const w = n[2] || a; const x = d || v; i.push({
            name: p || r++, prefix: f || '', delimiter: w, optional: b, repeat: _, partial: m, asterisk: !!y, pattern: x ? q(x) : y ? '.*' : `[^${H(w)}]+?`,
          });
        }
      } return o < t.length && (s += t.substr(o)), s && i.push(s), i;
    } function Y(t, e) { return K(z(t, e)); } function X(t) { return encodeURI(t).replace(/[\/?#]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`); } function W(t) { return encodeURI(t).replace(/[?#]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`); } function K(t) { for (var e = new Array(t.length), n = 0; n < t.length; n++) typeof t[n] === 'object' && (e[n] = new RegExp(`^(?:${t[n].pattern})$`)); return function (n, i) { for (var r = '', o = n || {}, s = i || {}, a = s.pretty ? X : encodeURIComponent, u = 0; u < t.length; u++) { const c = t[u]; if (typeof c !== 'string') { var h; const l = o[c.name]; if (l == null) { if (c.optional) { c.partial && (r += c.prefix); continue; } throw new TypeError(`Expected "${c.name}" to be defined`); } if (N(l)) { if (!c.repeat) throw new TypeError(`Expected "${c.name}" to not repeat, but received \`${JSON.stringify(l)}\``); if (l.length === 0) { if (c.optional) continue; throw new TypeError(`Expected "${c.name}" to not be empty`); } for (let f = 0; f < l.length; f++) { if (h = a(l[f]), !e[u].test(h)) throw new TypeError(`Expected all "${c.name}" to match "${c.pattern}", but received \`${JSON.stringify(h)}\``); r += (f === 0 ? c.prefix : c.delimiter) + h; } } else { if (h = c.asterisk ? W(l) : a(l), !e[u].test(h)) throw new TypeError(`Expected "${c.name}" to match "${c.pattern}", but received "${h}"`); r += c.prefix + h; } } else r += c; } return r; }; } function H(t) { return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1'); } function q(t) { return t.replace(/([=!:$\/()])/g, '\\$1'); } function Z(t, e) { return t.keys = e, t; } function J(t) { return t.sensitive ? '' : 'i'; } function Q(t, e) {
      const n = t.source.match(/\((?!\?)/g); if (n) {
        for (let i = 0; i < n.length; i++) {
          e.push({
            name: i, prefix: null, delimiter: null, optional: !1, repeat: !1, partial: !1, asterisk: !1, pattern: null,
          });
        }
      } return Z(t, e);
    } function tt(t, e, n) { for (var i = [], r = 0; r < t.length; r++)i.push(it(t[r], e, n).source); const o = new RegExp(`(?:${i.join('|')})`, J(n)); return Z(o, e); } function et(t, e, n) { return nt(z(t, n), e, n); } function nt(t, e, n) { N(e) || (n = e || n, e = []), n = n || {}; for (var i = n.strict, r = !1 !== n.end, o = '', s = 0; s < t.length; s++) { const a = t[s]; if (typeof a === 'string')o += H(a); else { const u = H(a.prefix); let c = `(?:${a.pattern})`; e.push(a), a.repeat && (c += `(?:${u}${c})*`), c = a.optional ? a.partial ? `${u}(${c})?` : `(?:${u}(${c}))?` : `${u}(${c})`, o += c; } } const h = H(n.delimiter || '/'); const l = o.slice(-h.length) === h; return i || (o = `${l ? o.slice(0, -h.length) : o}(?:${h}(?=$))?`), o += r ? '$' : i && l ? '' : `(?=${h}|$)`, Z(new RegExp(`^${o}`, J(n)), e); } function it(t, e, n) { return N(e) || (n = e || n, e = []), n = n || {}, t instanceof RegExp ? Q(t, e) : N(t) ? tt(t, e, n) : et(t, e, n); }D.parse = $, D.compile = G, D.tokensToFunction = V, D.tokensToRegExp = B; const rt = Object.create(null); function ot(t, e, n) { try { const i = rt[t] || (rt[t] = D.compile(t)); return i(e || {}, { pretty: !0 }); } catch (r) { return ''; } } function st(t, e, n, i) { const r = e || []; const o = n || Object.create(null); const s = i || Object.create(null); t.forEach((t) => { at(r, o, s, t); }); for (let a = 0, u = r.length; a < u; a++)r[a] === '*' && (r.push(r.splice(a, 1)[0]), u--, a--); return { pathList: r, pathMap: o, nameMap: s }; } function at(t, e, n, i, r, o) {
      const s = i.path; const a = i.name; const u = i.pathToRegexpOptions || {}; const c = ct(s, r, u.strict); typeof i.caseSensitive === 'boolean' && (u.sensitive = i.caseSensitive); const h = {
        path: c, regex: ut(c, u), components: i.components || { default: i.component }, instances: {}, name: a, parent: r, matchAs: o, redirect: i.redirect, beforeEnter: i.beforeEnter, meta: i.meta || {}, props: i.props == null ? {} : i.components ? i.props : { default: i.props },
      }; if (i.children && i.children.forEach((i) => { const r = o ? M(`${o}/${i.path}`) : void 0; at(t, e, n, i, h, r); }), void 0 !== i.alias) { const l = Array.isArray(i.alias) ? i.alias : [i.alias]; l.forEach((o) => { const s = { path: o, children: i.children }; at(t, e, n, s, r, h.path || '/'); }); }e[h.path] || (t.push(h.path), e[h.path] = h), a && (n[a] || (n[a] = h));
    } function ut(t, e) { const n = D(t, [], e); return n; } function ct(t, e, n) { return n || (t = t.replace(/\/$/, '')), t[0] === '/' ? t : e == null ? t : M(`${e.path}/${t}`); } function ht(t, e, n, i) {
      let r = typeof t === 'string' ? { path: t } : t; if (r.name || r._normalized) return r; if (!r.path && r.params && e) { r = o({}, r), r._normalized = !0; const s = o(o({}, e.params), r.params); if (e.name)r.name = e.name, r.params = s; else if (e.matched.length) { const a = e.matched[e.matched.length - 1].path; r.path = ot(a, s, `path ${e.path}`); } else 0; return r; } const u = k(r.path || ''); const c = e && e.path || '/'; const h = u.path ? j(u.path, c, n || r.append) : c; const l = p(u.query, r.query, i && i.options.parseQuery); let f = r.hash || u.hash; return f && f.charAt(0) !== '#' && (f = `#${f}`), {
        _normalized: !0, path: h, query: l, hash: f,
      };
    } function lt(t, e) {
      const n = st(t); const i = n.pathList; const r = n.pathMap; const o = n.nameMap; function s(t) { st(t, i, r, o); } function a(t, n, s) { const a = ht(t, n, !1, e); const u = a.name; if (u) { const c = o[u]; if (!c) return h(null, a); const l = c.regex.keys.filter(t => !t.optional).map(t => t.name); if (typeof a.params !== 'object' && (a.params = {}), n && typeof n.params === 'object') for (const f in n.params)!(f in a.params) && l.indexOf(f) > -1 && (a.params[f] = n.params[f]); if (c) return a.path = ot(c.path, a.params, `named route "${u}"`), h(c, a, s); } else if (a.path) { a.params = {}; for (let p = 0; p < i.length; p++) { const d = i[p]; const v = r[d]; if (ft(v.regex, a.path, a.params)) return h(v, a, s); } } return h(null, a); } function u(t, n) {
        const i = t.redirect; let r = typeof i === 'function' ? i(y(t, n, null, e)) : i; if (typeof r === 'string' && (r = { path: r }), !r || typeof r !== 'object') return h(null, n); const s = r; const u = s.name; const c = s.path; let l = n.query; let f = n.hash; let p = n.params; if (l = s.hasOwnProperty('query') ? s.query : l, f = s.hasOwnProperty('hash') ? s.hash : f, p = s.hasOwnProperty('params') ? s.params : p, u) {
          o[u]; return a({
            _normalized: !0, name: u, query: l, hash: f, params: p,
          }, void 0, n);
        } if (c) {
          const d = pt(c, t); const v = ot(d, p, `redirect route with path "${d}"`); return a({
            _normalized: !0, path: v, query: l, hash: f,
          }, void 0, n);
        } return h(null, n);
      } function c(t, e, n) { const i = ot(n, e.params, `aliased route with path "${n}"`); const r = a({ _normalized: !0, path: i }); if (r) { const o = r.matched; const s = o[o.length - 1]; return e.params = r.params, h(s, e); } return h(null, e); } function h(t, n, i) { return t && t.redirect ? u(t, i || n) : t && t.matchAs ? c(t, n, t.matchAs) : y(t, n, i, e); } return { match: a, addRoutes: s };
    } function ft(t, e, n) { const i = e.match(t); if (!i) return !1; if (!n) return !0; for (let r = 1, o = i.length; r < o; ++r) { const s = t.keys[r - 1]; const a = typeof i[r] === 'string' ? decodeURIComponent(i[r]) : i[r]; s && (n[s.name || 'pathMatch'] = a); } return !0; } function pt(t, e) { return j(t, e.parent ? e.parent.path : '/', !0); } const dt = Object.create(null); function vt() { window.history.replaceState({ key: It() }, '', window.location.href.replace(window.location.origin, '')), window.addEventListener('popstate', (t) => { yt(), t.state && t.state.key && Pt(t.state.key); }); } function gt(t, e, n, i) { if (t.app) { const r = t.options.scrollBehavior; r && t.app.$nextTick(() => { const o = mt(); const s = r.call(t, e, n, i ? o : null); s && (typeof s.then === 'function' ? s.then((t) => { St(t, o); }).catch((t) => { 0; }) : St(s, o)); }); } } function yt() { const t = It(); t && (dt[t] = { x: window.pageXOffset, y: window.pageYOffset }); } function mt() { const t = It(); if (t) return dt[t]; } function _t(t, e) { const n = document.documentElement; const i = n.getBoundingClientRect(); const r = t.getBoundingClientRect(); return { x: r.left - i.left - e.x, y: r.top - i.top - e.y }; } function bt(t) { return Et(t.x) || Et(t.y); } function wt(t) { return { x: Et(t.x) ? t.x : window.pageXOffset, y: Et(t.y) ? t.y : window.pageYOffset }; } function xt(t) { return { x: Et(t.x) ? t.x : 0, y: Et(t.y) ? t.y : 0 }; } function Et(t) { return typeof t === 'number'; } function St(t, e) { const n = typeof t === 'object'; if (n && typeof t.selector === 'string') { const i = document.querySelector(t.selector); if (i) { let r = t.offset && typeof t.offset === 'object' ? t.offset : {}; r = xt(r), e = _t(i, r); } else bt(t) && (e = wt(t)); } else n && bt(t) && (e = wt(t)); e && window.scrollTo(e.x, e.y); } const Tt = F && (function () { const t = window.navigator.userAgent; return (t.indexOf('Android 2.') === -1 && t.indexOf('Android 4.0') === -1 || t.indexOf('Mobile Safari') === -1 || t.indexOf('Chrome') !== -1 || t.indexOf('Windows Phone') !== -1) && (window.history && 'pushState' in window.history); }()); const Ot = F && window.performance && window.performance.now ? window.performance : Date; let Ct = Rt(); function Rt() { return Ot.now().toFixed(3); } function It() { return Ct; } function Pt(t) { Ct = t; } function Lt(t, e) { yt(); const n = window.history; try { e ? n.replaceState({ key: Ct }, '', t) : (Ct = Rt(), n.pushState({ key: Ct }, '', t)); } catch (i) { window.location[e ? 'replace' : 'assign'](t); } } function At(t) { Lt(t, !0); } function Ft(t, e, n) { var i = function (r) { r >= t.length ? n() : t[r] ? e(t[r], () => { i(r + 1); }) : i(r + 1); }; i(0); } function jt(t) { return function (e, n, i) { let o = !1; let s = 0; let a = null; kt(t, (t, e, n, u) => { if (typeof t === 'function' && void 0 === t.cid) { o = !0, s++; let c; const h = $t((e) => { Dt(e) && (e = e.default), t.resolved = typeof e === 'function' ? e : O.extend(e), n.components[u] = e, s--, s <= 0 && i(); }); const l = $t((t) => { const e = `Failed to resolve async component ${u}: ${t}`; a || (a = r(t) ? t : new Error(e), i(a)); }); try { c = t(h, l); } catch (p) { l(p); } if (c) if (typeof c.then === 'function')c.then(h, l); else { const f = c.component; f && typeof f.then === 'function' && f.then(h, l); } } }), o || i(); }; } function kt(t, e) { return Mt(t.map(t => Object.keys(t.components).map(n => e(t.components[n], t.instances[n], t, n)))); } function Mt(t) { return Array.prototype.concat.apply([], t); } const Nt = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol'; function Dt(t) { return t.__esModule || Nt && t[Symbol.toStringTag] === 'Module'; } function $t(t) { let e = !1; return function () { const n = []; let i = arguments.length; while (i--)n[i] = arguments[i]; if (!e) return e = !0, t.apply(this, n); }; } const Gt = function (t, e) { this.router = t, this.base = Vt(e), this.current = _, this.pending = null, this.ready = !1, this.readyCbs = [], this.readyErrorCbs = [], this.errorCbs = []; }; function Vt(t) { if (!t) if (F) { const e = document.querySelector('base'); t = e && e.getAttribute('href') || '/', t = t.replace(/^https?:\/\/[^\/]+/, ''); } else t = '/'; return t.charAt(0) !== '/' && (t = `/${t}`), t.replace(/\/$/, ''); } function Bt(t, e) { let n; const i = Math.max(t.length, e.length); for (n = 0; n < i; n++) if (t[n] !== e[n]) break; return { updated: e.slice(0, n), activated: e.slice(n), deactivated: t.slice(n) }; } function Ut(t, e, n, i) { const r = kt(t, (t, i, r, o) => { const s = zt(t, e); if (s) return Array.isArray(s) ? s.map(t => n(t, i, r, o)) : n(s, i, r, o); }); return Mt(i ? r.reverse() : r); } function zt(t, e) { return typeof t !== 'function' && (t = O.extend(t)), t.options[e]; } function Yt(t) { return Ut(t, 'beforeRouteLeave', Wt, !0); } function Xt(t) { return Ut(t, 'beforeRouteUpdate', Wt); } function Wt(t, e) { if (e) return function () { return t.apply(e, arguments); }; } function Kt(t, e, n) { return Ut(t, 'beforeRouteEnter', (t, i, r, o) => Ht(t, r, o, e, n)); } function Ht(t, e, n, i, r) { return function (o, s, a) { return t(o, s, (t) => { a(t), typeof t === 'function' && i.push(() => { qt(t, e.instances, n, r); }); }); }; } function qt(t, e, n, i) { e[n] && !e[n]._isBeingDestroyed ? t(e[n]) : i() && setTimeout(() => { qt(t, e, n, i); }, 16); }Gt.prototype.listen = function (t) { this.cb = t; }, Gt.prototype.onReady = function (t, e) { this.ready ? t() : (this.readyCbs.push(t), e && this.readyErrorCbs.push(e)); }, Gt.prototype.onError = function (t) { this.errorCbs.push(t); }, Gt.prototype.transitionTo = function (t, e, n) { const i = this; const r = this.router.match(t, this.current); this.confirmTransition(r, () => { i.updateRoute(r), e && e(r), i.ensureURL(), i.ready || (i.ready = !0, i.readyCbs.forEach((t) => { t(r); })); }, (t) => { n && n(t), t && !i.ready && (i.ready = !0, i.readyErrorCbs.forEach((e) => { e(t); })); }); }, Gt.prototype.confirmTransition = function (t, e, n) { const o = this; const s = this.current; const a = function (t) { r(t) && (o.errorCbs.length ? o.errorCbs.forEach((e) => { e(t); }) : (i(!1, 'uncaught error during route navigation:'), console.error(t))), n && n(t); }; if (x(t, s) && t.matched.length === s.matched.length) return this.ensureURL(), a(); const u = Bt(this.current.matched, t.matched); const c = u.updated; const h = u.deactivated; const l = u.activated; const f = [].concat(Yt(h), this.router.beforeHooks, Xt(c), l.map(t => t.beforeEnter), jt(l)); this.pending = t; const p = function (e, n) { if (o.pending !== t) return a(); try { e(t, s, (t) => { !1 === t || r(t) ? (o.ensureURL(!0), a(t)) : typeof t === 'string' || typeof t === 'object' && (typeof t.path === 'string' || typeof t.name === 'string') ? (a(), typeof t === 'object' && t.replace ? o.replace(t) : o.push(t)) : n(t); }); } catch (i) { a(i); } }; Ft(f, p, () => { const n = []; const i = function () { return o.current === t; }; const r = Kt(l, n, i); const s = r.concat(o.router.resolveHooks); Ft(s, p, () => { if (o.pending !== t) return a(); o.pending = null, e(t), o.router.app && o.router.app.$nextTick(() => { n.forEach((t) => { t(); }); }); }); }); }, Gt.prototype.updateRoute = function (t) { const e = this.current; this.current = t, this.cb && this.cb(t), this.router.afterHooks.forEach((n) => { n && n(t, e); }); }; const Zt = (function (t) { function e(e, n) { const i = this; t.call(this, e, n); const r = e.options.scrollBehavior; const o = Tt && r; o && vt(); const s = Jt(this.base); window.addEventListener('popstate', (t) => { const n = i.current; const r = Jt(i.base); i.current === _ && r === s || i.transitionTo(r, (t) => { o && gt(e, t, n, !0); }); }); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.go = function (t) { window.history.go(t); }, e.prototype.push = function (t, e, n) { const i = this; const r = this; const o = r.current; this.transitionTo(t, (t) => { Lt(M(i.base + t.fullPath)), gt(i.router, t, o, !1), e && e(t); }, n); }, e.prototype.replace = function (t, e, n) { const i = this; const r = this; const o = r.current; this.transitionTo(t, (t) => { At(M(i.base + t.fullPath)), gt(i.router, t, o, !1), e && e(t); }, n); }, e.prototype.ensureURL = function (t) { if (Jt(this.base) !== this.current.fullPath) { const e = M(this.base + this.current.fullPath); t ? Lt(e) : At(e); } }, e.prototype.getCurrentLocation = function () { return Jt(this.base); }, e; }(Gt)); function Jt(t) { let e = decodeURI(window.location.pathname); return t && e.indexOf(t) === 0 && (e = e.slice(t.length)), (e || '/') + window.location.search + window.location.hash; } const Qt = (function (t) { function e(e, n, i) { t.call(this, e, n), i && te(this.base) || ee(); } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setupListeners = function () { const t = this; const e = this.router; const n = e.options.scrollBehavior; const i = Tt && n; i && vt(), window.addEventListener(Tt ? 'popstate' : 'hashchange', () => { const e = t.current; ee() && t.transitionTo(ne(), (n) => { i && gt(t.router, n, e, !0), Tt || oe(n.fullPath); }); }); }, e.prototype.push = function (t, e, n) { const i = this; const r = this; const o = r.current; this.transitionTo(t, (t) => { re(t.fullPath), gt(i.router, t, o, !1), e && e(t); }, n); }, e.prototype.replace = function (t, e, n) { const i = this; const r = this; const o = r.current; this.transitionTo(t, (t) => { oe(t.fullPath), gt(i.router, t, o, !1), e && e(t); }, n); }, e.prototype.go = function (t) { window.history.go(t); }, e.prototype.ensureURL = function (t) { const e = this.current.fullPath; ne() !== e && (t ? re(e) : oe(e)); }, e.prototype.getCurrentLocation = function () { return ne(); }, e; }(Gt)); function te(t) { const e = Jt(t); if (!/^\/#/.test(e)) return window.location.replace(M(`${t}/#${e}`)), !0; } function ee() { const t = ne(); return t.charAt(0) === '/' || (oe(`/${t}`), !1); } function ne() { const t = window.location.href; const e = t.indexOf('#'); return e === -1 ? '' : decodeURI(t.slice(e + 1)); } function ie(t) { const e = window.location.href; const n = e.indexOf('#'); const i = n >= 0 ? e.slice(0, n) : e; return `${i}#${t}`; } function re(t) { Tt ? Lt(ie(t)) : window.location.hash = t; } function oe(t) { Tt ? At(ie(t)) : window.location.replace(ie(t)); } const se = (function (t) { function e(e, n) { t.call(this, e, n), this.stack = [], this.index = -1; } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.push = function (t, e, n) { const i = this; this.transitionTo(t, (t) => { i.stack = i.stack.slice(0, i.index + 1).concat(t), i.index++, e && e(t); }, n); }, e.prototype.replace = function (t, e, n) { const i = this; this.transitionTo(t, (t) => { i.stack = i.stack.slice(0, i.index).concat(t), e && e(t); }, n); }, e.prototype.go = function (t) { const e = this; const n = this.index + t; if (!(n < 0 || n >= this.stack.length)) { const i = this.stack[n]; this.confirmTransition(i, () => { e.index = n, e.updateRoute(i); }); } }, e.prototype.getCurrentLocation = function () { const t = this.stack[this.stack.length - 1]; return t ? t.fullPath : '/'; }, e.prototype.ensureURL = function () {}, e; }(Gt)); const ae = function (t) { void 0 === t && (t = {}), this.app = null, this.apps = [], this.options = t, this.beforeHooks = [], this.resolveHooks = [], this.afterHooks = [], this.matcher = lt(t.routes || [], this); let e = t.mode || 'hash'; switch (this.fallback = e === 'history' && !Tt && !1 !== t.fallback, this.fallback && (e = 'hash'), F || (e = 'abstract'), this.mode = e, e) { case 'history': this.history = new Zt(this, t.base); break; case 'hash': this.history = new Qt(this, t.base, this.fallback); break; case 'abstract': this.history = new se(this, t.base); break; default: 0; } }; const ue = { currentRoute: { configurable: !0 } }; function ce(t, e) { return t.push(e), function () { const n = t.indexOf(e); n > -1 && t.splice(n, 1); }; } function he(t, e, n) { const i = n === 'hash' ? `#${e}` : e; return t ? M(`${t}/${i}`) : i; }ae.prototype.match = function (t, e, n) { return this.matcher.match(t, e, n); }, ue.currentRoute.get = function () { return this.history && this.history.current; }, ae.prototype.init = function (t) { const e = this; if (this.apps.push(t), !this.app) { this.app = t; const n = this.history; if (n instanceof Zt)n.transitionTo(n.getCurrentLocation()); else if (n instanceof Qt) { const i = function () { n.setupListeners(); }; n.transitionTo(n.getCurrentLocation(), i, i); }n.listen((t) => { e.apps.forEach((e) => { e._route = t; }); }); } }, ae.prototype.beforeEach = function (t) { return ce(this.beforeHooks, t); }, ae.prototype.beforeResolve = function (t) { return ce(this.resolveHooks, t); }, ae.prototype.afterEach = function (t) { return ce(this.afterHooks, t); }, ae.prototype.onReady = function (t, e) { this.history.onReady(t, e); }, ae.prototype.onError = function (t) { this.history.onError(t); }, ae.prototype.push = function (t, e, n) { this.history.push(t, e, n); }, ae.prototype.replace = function (t, e, n) { this.history.replace(t, e, n); }, ae.prototype.go = function (t) { this.history.go(t); }, ae.prototype.back = function () { this.go(-1); }, ae.prototype.forward = function () { this.go(1); }, ae.prototype.getMatchedComponents = function (t) { const e = t ? t.matched ? t : this.resolve(t).route : this.currentRoute; return e ? [].concat.apply([], e.matched.map(t => Object.keys(t.components).map(e => t.components[e]))) : []; }, ae.prototype.resolve = function (t, e, n) {
      const i = ht(t, e || this.history.current, n, this); const r = this.match(i, e); const o = r.redirectedFrom || r.fullPath; const s = this.history.base; const a = he(s, o, this.mode); return {
        location: i, route: r, href: a, normalizedTo: i, resolved: r,
      };
    }, ae.prototype.addRoutes = function (t) { this.matcher.addRoutes(t), this.history.current !== _ && this.history.transitionTo(this.history.getCurrentLocation()); }, Object.defineProperties(ae.prototype, ue), ae.install = A, ae.version = '3.0.2', F && window.Vue && window.Vue.use(ae), e.a = ae;
  },
  '8df4': function (t, e, n) {
    const i = n('7a77'); function r(t) { if (typeof t !== 'function') throw new TypeError('executor must be a function.'); let e; this.promise = new Promise(((t) => { e = t; })); const n = this; t((t) => { n.reason || (n.reason = new i(t), e(n.reason)); }); }r.prototype.throwIfRequested = function () { if (this.reason) throw this.reason; }, r.source = function () { let t; const e = new r(((e) => { t = e; })); return { token: e, cancel: t }; }, t.exports = r;
  },
  '8e60': function (t, e, n) { t.exports = !n('294c')(() => Object.defineProperty({}, 'a', { get() { return 7; } }).a != 7); },
  '8f60': function (t, e, n) {
    const i = n('a159'); const r = n('aebd'); const o = n('45f2'); const s = {}; n('35e8')(s, n('5168')('iterator'), function () { return this; }), t.exports = function (t, e, n) { t.prototype = i(s, { next: r(1, n) }), o(t, `${e} Iterator`); };
  },
  '8feb': function (t, e, n) { t.exports = n('4910'); },
  9003(t, e, n) { const i = n('6b4c'); t.exports = Array.isArray || function (t) { return i(t) == 'Array'; }; },
  9138(t, e, n) { t.exports = n('35e8'); },
  9152(t, e) { e.read = function (t, e, n, i, r) { let o; let s; const a = 8 * r - i - 1; const u = (1 << a) - 1; const c = u >> 1; let h = -7; let l = n ? r - 1 : 0; const f = n ? -1 : 1; let p = t[e + l]; for (l += f, o = p & (1 << -h) - 1, p >>= -h, h += a; h > 0; o = 256 * o + t[e + l], l += f, h -= 8);for (s = o & (1 << -h) - 1, o >>= -h, h += i; h > 0; s = 256 * s + t[e + l], l += f, h -= 8);if (o === 0)o = 1 - c; else { if (o === u) return s ? NaN : 1 / 0 * (p ? -1 : 1); s += Math.pow(2, i), o -= c; } return (p ? -1 : 1) * s * Math.pow(2, o - i); }, e.write = function (t, e, n, i, r, o) { let s; let a; let u; let c = 8 * o - r - 1; const h = (1 << c) - 1; const l = h >> 1; const f = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; let p = i ? 0 : o - 1; const d = i ? 1 : -1; const v = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), e += s + l >= 1 ? f / u : f * Math.pow(2, 1 - l), e * u >= 2 && (s++, u /= 2), s + l >= h ? (a = 0, s = h) : s + l >= 1 ? (a = (e * u - 1) * Math.pow(2, r), s += l) : (a = e * Math.pow(2, l - 1) * Math.pow(2, r), s = 0)); r >= 8; t[n + p] = 255 & a, p += d, a /= 256, r -= 8);for (s = s << r | a, c += r; c > 0; t[n + p] = 255 & s, p += d, s /= 256, c -= 8);t[n + p - d] |= 128 * v; }; },
  9306(t, e, n) {
    const i = n('c3a1'); const r = n('9aa9'); const o = n('355d'); const s = n('241e'); const a = n('335c'); const u = Object.assign; t.exports = !u || n('294c')(() => { const t = {}; const e = {}; const n = Symbol(); const i = 'abcdefghijklmnopqrst'; return t[n] = 7, i.split('').forEach((t) => { e[t] = t; }), u({}, t)[n] != 7 || Object.keys(u({}, e)).join('') != i; }) ? function (t, e) { const n = s(t); const u = arguments.length; let c = 1; const h = r.f; const l = o.f; while (u > c) { var f; const p = a(arguments[c++]); const d = h ? i(p).concat(h(p)) : i(p); const v = d.length; let g = 0; while (v > g)l.call(p, f = d[g++]) && (n[f] = p[f]); } return n; } : u;
  },
  9427(t, e, n) { const i = n('63b6'); i(i.S, 'Object', { create: n('a159') }); },
  9483(t, e, n) {
    n.d(e, 'a', () => r); const i = function () { return Boolean(window.location.hostname === 'localhost' || window.location.hostname === '[::1]' || window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)); }; function r(t, e) { const n = function (t) { const n = []; let i = arguments.length - 1; while (i-- > 0)n[i] = arguments[i + 1]; e && e[t] && e[t](...n); }; 'serviceWorker' in navigator && window.addEventListener('load', () => { i() ? (s(t, n), navigator.serviceWorker.ready.then((t) => { n('ready', t); })) : o(t, n); }); } function o(t, e) { navigator.serviceWorker.register(t).then((t) => { e('registered', t), t.waiting ? e('updated', t) : t.onupdatefound = function () { e('updatefound', t); const n = t.installing; n.onstatechange = function () { n.state === 'installed' && (navigator.serviceWorker.controller ? e('updated', t) : e('cached', t)); }; }; }).catch((t) => { e('error', t); }); } function s(t, e) { fetch(t).then((n) => { n.status === 404 || n.headers.get('content-type').indexOf('javascript') === -1 ? (e('error', new Error(`Service worker not found at ${t}`)), a()) : o(t, e); }).catch((t) => { navigator.onLine ? e('error', t) : e('offline'); }); } function a() { 'serviceWorker' in navigator && navigator.serviceWorker.ready.then((t) => { t.unregister(); }); }
  },
  '95d5': function (t, e, n) { const i = n('40c3'); const r = n('5168')('iterator'); const o = n('481b'); t.exports = n('584a').isIterable = function (t) { const e = Object(t); return void 0 !== e[r] || '@@iterator' in e || o.hasOwnProperty(i(e)); }; },
  '967e': function (t, e, n) { t.exports = n('bbdd'); },
  '96cf': function (t, e) {
    !(function (e) {
      let n; const i = Object.prototype; const r = i.hasOwnProperty; const o = typeof Symbol === 'function' ? Symbol : {}; const s = o.iterator || '@@iterator'; const a = o.asyncIterator || '@@asyncIterator'; const u = o.toStringTag || '@@toStringTag'; const c = typeof t === 'object'; let h = e.regeneratorRuntime; if (h)c && (t.exports = h); else {
        h = e.regeneratorRuntime = c ? t.exports : {}, h.wrap = b; var l = 'suspendedStart'; var f = 'suspendedYield'; var p = 'executing'; var d = 'completed'; var v = {}; let g = {}; g[s] = function () { return this; }; const y = Object.getPrototypeOf; const m = y && y(y(A([]))); m && m !== i && r.call(m, s) && (g = m); const _ = S.prototype = x.prototype = Object.create(g); E.prototype = _.constructor = S, S.constructor = E, S[u] = E.displayName = 'GeneratorFunction', h.isGeneratorFunction = function (t) { const e = typeof t === 'function' && t.constructor; return !!e && (e === E || (e.displayName || e.name) === 'GeneratorFunction'); }, h.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, S) : (t.__proto__ = S, u in t || (t[u] = 'GeneratorFunction')), t.prototype = Object.create(_), t; }, h.awrap = function (t) { return { __await: t }; }, T(O.prototype), O.prototype[a] = function () { return this; }, h.AsyncIterator = O, h.async = function (t, e, n, i) { const r = new O(b(t, e, n, i)); return h.isGeneratorFunction(e) ? r : r.next().then(t => (t.done ? t.value : r.next())); }, T(_), _[u] = 'Generator', _[s] = function () { return this; }, _.toString = function () { return '[object Generator]'; }, h.keys = function (t) { const e = []; for (const n in t)e.push(n); return e.reverse(), function n() { while (e.length) { const i = e.pop(); if (i in t) return n.value = i, n.done = !1, n; } return n.done = !0, n; }; }, h.values = A, L.prototype = {
          constructor: L, reset(t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = n, this.done = !1, this.delegate = null, this.method = 'next', this.arg = n, this.tryEntries.forEach(P), !t) for (const e in this)e.charAt(0) === 't' && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = n); }, stop() { this.done = !0; const t = this.tryEntries[0]; const e = t.completion; if (e.type === 'throw') throw e.arg; return this.rval; }, dispatchException(t) { if (this.done) throw t; const e = this; function i(i, r) { return a.type = 'throw', a.arg = t, e.next = i, r && (e.method = 'next', e.arg = n), !!r; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const s = this.tryEntries[o]; var a = s.completion; if (s.tryLoc === 'root') return i('end'); if (s.tryLoc <= this.prev) { const u = r.call(s, 'catchLoc'); const c = r.call(s, 'finallyLoc'); if (u && c) { if (this.prev < s.catchLoc) return i(s.catchLoc, !0); if (this.prev < s.finallyLoc) return i(s.finallyLoc); } else if (u) { if (this.prev < s.catchLoc) return i(s.catchLoc, !0); } else { if (!c) throw new Error('try statement without catch or finally'); if (this.prev < s.finallyLoc) return i(s.finallyLoc); } } } }, abrupt(t, e) { for (let n = this.tryEntries.length - 1; n >= 0; --n) { const i = this.tryEntries[n]; if (i.tryLoc <= this.prev && r.call(i, 'finallyLoc') && this.prev < i.finallyLoc) { var o = i; break; } }o && (t === 'break' || t === 'continue') && o.tryLoc <= e && e <= o.finallyLoc && (o = null); const s = o ? o.completion : {}; return s.type = t, s.arg = e, o ? (this.method = 'next', this.next = o.finallyLoc, v) : this.complete(s); }, complete(t, e) { if (t.type === 'throw') throw t.arg; return t.type === 'break' || t.type === 'continue' ? this.next = t.arg : t.type === 'return' ? (this.rval = this.arg = t.arg, this.method = 'return', this.next = 'end') : t.type === 'normal' && e && (this.next = e), v; }, finish(t) { for (let e = this.tryEntries.length - 1; e >= 0; --e) { const n = this.tryEntries[e]; if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), P(n), v; } }, catch(t) { for (let e = this.tryEntries.length - 1; e >= 0; --e) { const n = this.tryEntries[e]; if (n.tryLoc === t) { const i = n.completion; if (i.type === 'throw') { var r = i.arg; P(n); } return r; } } throw new Error('illegal catch attempt'); }, delegateYield(t, e, i) { return this.delegate = { iterator: A(t), resultName: e, nextLoc: i }, this.method === 'next' && (this.arg = n), v; },
        };
      } function b(t, e, n, i) { const r = e && e.prototype instanceof x ? e : x; const o = Object.create(r.prototype); const s = new L(i || []); return o._invoke = C(t, n, s), o; } function w(t, e, n) { try { return { type: 'normal', arg: t.call(e, n) }; } catch (i) { return { type: 'throw', arg: i }; } } function x() {} function E() {} function S() {} function T(t) { ['next', 'throw', 'return'].forEach((e) => { t[e] = function (t) { return this._invoke(e, t); }; }); } function O(t) { function e(n, i, o, s) { const a = w(t[n], t, i); if (a.type !== 'throw') { const u = a.arg; const c = u.value; return c && typeof c === 'object' && r.call(c, '__await') ? Promise.resolve(c.__await).then((t) => { e('next', t, o, s); }, (t) => { e('throw', t, o, s); }) : Promise.resolve(c).then((t) => { u.value = t, o(u); }, t => e('throw', t, o, s)); }s(a.arg); } let n; function i(t, i) { function r() { return new Promise(((n, r) => { e(t, i, n, r); })); } return n = n ? n.then(r, r) : r(); } this._invoke = i; } function C(t, e, n) { let i = l; return function (r, o) { if (i === p) throw new Error('Generator is already running'); if (i === d) { if (r === 'throw') throw o; return F(); }n.method = r, n.arg = o; while (1) { const s = n.delegate; if (s) { const a = R(s, n); if (a) { if (a === v) continue; return a; } } if (n.method === 'next')n.sent = n._sent = n.arg; else if (n.method === 'throw') { if (i === l) throw i = d, n.arg; n.dispatchException(n.arg); } else n.method === 'return' && n.abrupt('return', n.arg); i = p; const u = w(t, e, n); if (u.type === 'normal') { if (i = n.done ? d : f, u.arg === v) continue; return { value: u.arg, done: n.done }; }u.type === 'throw' && (i = d, n.method = 'throw', n.arg = u.arg); } }; } function R(t, e) { const i = t.iterator[e.method]; if (i === n) { if (e.delegate = null, e.method === 'throw') { if (t.iterator.return && (e.method = 'return', e.arg = n, R(t, e), e.method === 'throw')) return v; e.method = 'throw', e.arg = new TypeError("The iterator does not provide a 'throw' method"); } return v; } const r = w(i, t.iterator, e.arg); if (r.type === 'throw') return e.method = 'throw', e.arg = r.arg, e.delegate = null, v; const o = r.arg; return o ? o.done ? (e[t.resultName] = o.value, e.next = t.nextLoc, e.method !== 'return' && (e.method = 'next', e.arg = n), e.delegate = null, v) : o : (e.method = 'throw', e.arg = new TypeError('iterator result is not an object'), e.delegate = null, v); } function I(t) { const e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function P(t) { const e = t.completion || {}; e.type = 'normal', delete e.arg, t.completion = e; } function L(t) { this.tryEntries = [{ tryLoc: 'root' }], t.forEach(I, this), this.reset(!0); } function A(t) { if (t) { const e = t[s]; if (e) return e.call(t); if (typeof t.next === 'function') return t; if (!isNaN(t.length)) { let i = -1; const o = function e() { while (++i < t.length) if (r.call(t, i)) return e.value = t[i], e.done = !1, e; return e.value = n, e.done = !0, e; }; return o.next = o; } } return { next: F }; } function F() { return { value: n, done: !0 }; }
    }((function () { return this || typeof self === 'object' && self; }()) || Function('return this')()));
  },
  9910(t, e, n) {
    n.d(e, 'a', () => u); const i = n('80d2'); const r = n('a523'); const o = n('549c'); const s = n('0e8f'); const a = n('a722'); var u = Object(i.b)('spacer', 'div', 'v-spacer'); r.a, o.a, s.a, a.a;
  },
  '99d9': function (t, e, n) {
    const i = n('80d2'); const r = n('b0af'); const o = n('adda'); const s = n('d9bd'); const a = o.a.extend({ name: 'v-card-media', mounted() { Object(s.c)('v-card-media', this.src ? 'v-img' : 'v-responsive', this); } }); const u = n('12b2'); const c = n('2b0e'); n.d(e, 'a', () => h); var h = c.a.extend(Object(i.b)('v-card__actions')); const l = c.a.extend(Object(i.b)('v-card__text')); r.a, u.a;
  },
  '9aa9': function (t, e) { e.f = Object.getOwnPropertySymbols; },
  '9b43': function (t, e, n) { const i = n('d8e8'); t.exports = function (t, e, n) { if (i(t), void 0 === e) return t; switch (n) { case 1: return function (n) { return t.call(e, n); }; case 2: return function (n, i) { return t.call(e, n, i); }; case 3: return function (n, i, r) { return t.call(e, n, i, r); }; } return function () { return t.apply(e, arguments); }; }; },
  '9c6c': function (t, e, n) { const i = n('2b4c')('unscopables'); const r = Array.prototype; void 0 == r[i] && n('32e9')(r, i, {}), t.exports = function (t) { r[i][t] = !0; }; },
  '9c80': function (t, e) { t.exports = function (t) { try { return { e: !1, v: t() }; } catch (e) { return { e: !0, v: e }; } }; },
  '9d98': function (t, e, n) { const i = n('63b6'); i(i.S + i.F * !n('8e60'), 'Object', { defineProperties: n('7e90') }); },
  '9def': function (t, e, n) { const i = n('4588'); const r = Math.min; t.exports = function (t) { return t > 0 ? r(i(t), 9007199254740991) : 0; }; },
  '9e1c': function (t, e, n) { n('7d6d'), t.exports = n('584a').Object.values; },
  '9e1e': function (t, e, n) { t.exports = !n('79e5')(() => Object.defineProperty({}, 'a', { get() { return 7; } }).a != 7); },
  '9f79': function (t, e, n) { const i = n('f772'); t.exports = function (t, e) { if (!i(t) || t._t !== e) throw TypeError(`Incompatible receiver, ${e} required!`); return t; }; },
  '9fa6': function (t, e, n) {
    const i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; function r() { this.message = 'String contains an invalid character'; } function o(t) { for (var e, n, o = String(t), s = '', a = 0, u = i; o.charAt(0 | a) || (u = '=', a % 1); s += u.charAt(63 & e >> 8 - a % 1 * 8)) { if (n = o.charCodeAt(a += 0.75), n > 255) throw new r(); e = e << 8 | n; } return s; }r.prototype = new Error(), r.prototype.code = 5, r.prototype.name = 'InvalidCharacterError', t.exports = o;
  },
  a159(t, e, n) { const i = n('e4ae'); const r = n('7e90'); const o = n('1691'); const s = n('5559')('IE_PROTO'); const a = function () {}; const u = 'prototype'; var c = function () { let t; const e = n('1ec9')('iframe'); let i = o.length; const r = '<'; const s = '>'; e.style.display = 'none', n('32fc').appendChild(e), e.src = 'javascript:', t = e.contentWindow.document, t.open(), t.write(`${r}script${s}document.F=Object${r}/script${s}`), t.close(), c = t.F; while (i--) delete c[u][o[i]]; return c(); }; t.exports = Object.create || function (t, e) { let n; return t !== null ? (a[u] = i(t), n = new a(), a[u] = null, n[s] = t) : n = c(), void 0 === e ? n : r(n, e); }; },
  a1ce(t, e, n) { const i = n('63b6'); const r = n('25eb'); const o = n('294c'); const s = n('e692'); const a = `[${s}]`; const u = '​'; const c = RegExp(`^${a}${a}*`); const h = RegExp(`${a + a}*$`); const l = function (t, e, n) { const r = {}; const a = o(() => !!s[t]() || u[t]() != u); const c = r[t] = a ? e(f) : s[t]; n && (r[n] = c), i(i.P + i.F * a, 'String', r); }; var f = l.trim = function (t, e) { return t = String(r(t)), 1 & e && (t = t.replace(c, '')), 2 & e && (t = t.replace(h, '')), t; }; t.exports = l; },
  a21f(t, e, n) { const i = n('584a'); const r = i.JSON || (i.JSON = { stringify: JSON.stringify }); t.exports = function (t) { return r.stringify(...arguments); }; },
  a22a(t, e, n) { const i = n('d864'); const r = n('b0dc'); const o = n('3702'); const s = n('e4ae'); const a = n('b447'); const u = n('7cd6'); const c = {}; const h = {}; e = t.exports = function (t, e, n, l, f) { let p; let d; let v; let g; const y = f ? function () { return t; } : u(t); const m = i(n, l, e ? 2 : 1); let _ = 0; if (typeof y !== 'function') throw TypeError(`${t} is not iterable!`); if (o(y)) { for (p = a(t.length); p > _; _++) if (g = e ? m(s(d = t[_])[0], d[1]) : m(t[_]), g === c || g === h) return g; } else for (v = y.call(t); !(d = v.next()).done;) if (g = r(v, m, d.value, e), g === c || g === h) return g; }; e.BREAK = c, e.RETURN = h; },
  a25f(t, e, n) { const i = n('7726'); const r = i.navigator; t.exports = r && r.userAgent || ''; },
  a3c3(t, e, n) { const i = n('63b6'); i(i.S + i.F, 'Object', { assign: n('9306') }); },
  a47c(t, e, n) {
    /*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */t.exports = r; const i = Object.prototype.hasOwnProperty; function r(t, e, n) { if (!t) throw new TypeError('argument dest is required'); if (!e) throw new TypeError('argument src is required'); return void 0 === n && (n = !0), Object.getOwnPropertyNames(e).forEach((r) => { if (n || !i.call(t, r)) { const o = Object.getOwnPropertyDescriptor(e, r); Object.defineProperty(t, r, o); } }), t; }
  },
  a4bb(t, e, n) { t.exports = n('8aae'); },
  a523(t, e, n) {
    n('db6d'); const i = n('e8f2'); e.a = Object(i.a)('container');
  },
  a5b2(t, e, n) { t.exports = n('aa28'); },
  a5b8(t, e, n) {
    const i = n('d8e8'); function r(t) { let e; let n; this.promise = new t(((t, i) => { if (void 0 !== e || void 0 !== n) throw TypeError('Bad Promise constructor'); e = t, n = i; })), this.resolve = i(e), this.reject = i(n); }t.exports.f = function (t) { return new r(t); };
  },
  a722(t, e, n) {
    n('db6d'); const i = n('e8f2'); e.a = Object(i.a)('layout');
  },
  a745(t, e, n) { t.exports = n('f410'); },
  aa28(t, e, n) { n('733c'), t.exports = n('584a').Reflect.construct; },
  aba2(t, e, n) { const i = n('e53d'); const r = n('4178').set; const o = i.MutationObserver || i.WebKitMutationObserver; const s = i.process; const a = i.Promise; const u = n('6b4c')(s) == 'process'; t.exports = function () { let t; let e; let n; const c = function () { let i; let r; u && (i = s.domain) && i.exit(); while (t) { r = t.fn, t = t.next; try { r(); } catch (o) { throw t ? n() : e = void 0, o; } }e = void 0, i && i.enter(); }; if (u)n = function () { s.nextTick(c); }; else if (!o || i.navigator && i.navigator.standalone) if (a && a.resolve) { const h = a.resolve(void 0); n = function () { h.then(c); }; } else n = function () { r.call(i, c); }; else { let l = !0; const f = document.createTextNode(''); new o(c).observe(f, { characterData: !0 }), n = function () { f.data = l = !l; }; } return function (i) { const r = { fn: i, next: void 0 }; e && (e.next = r), t || (t = r, n()), e = r; }; }; },
  ada4(t, e, n) {
    const i = n('e53d'); const r = n('63b6'); const o = n('ebfd'); const s = n('294c'); const a = n('35e8'); const u = n('5c95'); const c = n('a22a'); const h = n('1173'); const l = n('f772'); const f = n('45f2'); const p = n('d9f6').f; const d = n('57b1')(0); const v = n('8e60'); t.exports = function (t, e, n, g, y, m) { const _ = i[t]; let b = _; const w = y ? 'set' : 'add'; const x = b && b.prototype; const E = {}; return v && typeof b === 'function' && (m || x.forEach && !s(() => { (new b()).entries().next(); })) ? (b = e((e, n) => { h(e, b, t, '_c'), e._c = new _(), void 0 != n && c(n, y, e[w], e); }), d('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), (t) => { const e = t == 'add' || t == 'set'; t in x && (!m || t != 'clear') && a(b.prototype, t, function (n, i) { if (h(this, b, t), !e && m && !l(n)) return t == 'get' && void 0; const r = this._c[t](n === 0 ? 0 : n, i); return e ? this : r; }); }), m || p(b.prototype, 'size', { get() { return this._c.size; } })) : (b = g.getConstructor(e, t, y, w), u(b.prototype, n), o.NEED = !0), f(b, t), E[t] = b, r(r.G + r.W + r.F, E), m || g.setStrong(b, t, y), b; };
  },
  adda(t, e, n) {
    n('253d'), n('4c34'); const i = n('23bf'); const r = n('58df'); const o = n('80d2'); const s = Object(r.a)(i.a).extend({
      name: 'v-responsive',
      props: { aspectRatio: [String, Number] },
      computed: { computedAspectRatio() { return Number(this.aspectRatio); }, aspectStyle() { return this.computedAspectRatio ? { paddingBottom: `${1 / this.computedAspectRatio * 100}%` } : void 0; }, __cachedSizer() { return this.aspectStyle ? this.$createElement('div', { style: this.aspectStyle, staticClass: 'v-responsive__sizer' }) : []; } },
      methods: { genContent() { return this.$createElement('div', { staticClass: 'v-responsive__content' }, this.$slots.default); } },
      render(t) {
        return t('div', {
          staticClass: 'v-responsive',
          style: {
            height: Object(o.a)(this.height), maxHeight: Object(o.a)(this.maxHeight), maxWidth: Object(o.a)(this.maxWidth), width: Object(o.a)(this.width),
          },
          on: this.$listeners,
        }, [this.__cachedSizer, this.genContent()]);
      },
    }); const a = s; const u = n('d9bd'); e.a = a.extend({
      name: 'v-img',
      props: {
        alt: String, contain: Boolean, src: { type: [String, Object], default: '' }, gradient: String, lazySrc: String, srcset: String, sizes: String, position: { type: String, default: 'center center' }, transition: { type: [Boolean, String], default: 'fade-transition' },
      },
      data() {
        return {
          currentSrc: '', image: null, isLoading: !0, calculatedAspectRatio: void 0,
        };
      },
      computed: {
        computedAspectRatio() { return this.normalisedSrc.aspect; },
        normalisedSrc() {
          return typeof this.src === 'string' ? {
            src: this.src, srcset: this.srcset, lazySrc: this.lazySrc, aspect: Number(this.aspectRatio || this.calculatedAspectRatio),
          } : {
            src: this.src.src, srcset: this.srcset || this.src.srcset, lazySrc: this.lazySrc || this.src.lazySrc, aspect: Number(this.aspectRatio || this.src.aspect || this.calculatedAspectRatio),
          };
        },
        __cachedImage() {
          if (!this.normalisedSrc.src && !this.normalisedSrc.lazySrc) return []; const t = []; const e = this.isLoading ? this.normalisedSrc.lazySrc : this.currentSrc; this.gradient && t.push(`linear-gradient(${this.gradient})`), e && t.push(`url("${e}")`); const n = this.$createElement('div', {
            staticClass: 'v-image__image', class: { 'v-image__image--preload': this.isLoading, 'v-image__image--contain': this.contain, 'v-image__image--cover': !this.contain }, style: { backgroundImage: t.join(', '), backgroundPosition: this.position }, key: +this.isLoading,
          }); return this.transition ? this.$createElement('transition', { attrs: { name: this.transition, mode: 'in-out' } }, [n]) : n;
        },
      },
      watch: { src() { this.isLoading ? this.loadImage() : this.init(); }, '$vuetify.breakpoint.width': 'getSrc' },
      mounted() { this.init(); },
      methods: {
        init() { if (this.normalisedSrc.lazySrc) { const t = new Image(); t.src = this.normalisedSrc.lazySrc, this.pollForSize(t, null); } this.normalisedSrc.src && this.loadImage(); }, onLoad() { this.getSrc(), this.isLoading = !1, this.$emit('load', this.src); }, onError() { Object(u.a)(`Image load failed\n\nsrc: ${this.normalisedSrc.src}`, this), this.$emit('error', this.src); }, getSrc() { this.image && (this.currentSrc = this.image.currentSrc || this.image.src); }, loadImage() { const t = this; const e = new Image(); this.image = e, e.onload = function () { e.decode ? e.decode().catch((e) => { Object(u.b)(`Failed to decode image, trying to render anyway\n\nsrc: ${t.normalisedSrc.src}${e.message ? `\nOriginal error: ${e.message}` : ''}`, t); }).then(t.onLoad) : t.onLoad(); }, e.onerror = this.onError, e.src = this.normalisedSrc.src, this.sizes && (e.sizes = this.sizes), this.normalisedSrc.srcset && (e.srcset = this.normalisedSrc.srcset), this.aspectRatio || this.pollForSize(e), this.getSrc(); }, pollForSize(t) { const e = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100; const i = function i() { const r = t.naturalHeight; const o = t.naturalWidth; r || o ? e.calculatedAspectRatio = o / r : n != null && setTimeout(i, n); }; i(); }, __genPlaceholder() { if (this.$slots.placeholder) { const t = this.isLoading ? [this.$createElement('div', { staticClass: 'v-image__placeholder' }, this.$slots.placeholder)] : []; return this.transition ? this.$createElement('transition', { attrs: { name: this.transition } }, t) : t[0]; } },
      },
      render(t) { const e = a.options.render.call(this, t); return e.data.staticClass += ' v-image', e.data.attrs = { role: this.alt ? 'img' : void 0, 'aria-label': this.alt }, e.children = [this.__cachedSizer, this.__cachedImage, this.__genPlaceholder(), this.genContent()], t(e.tag, e.data, e.children); },
    });
  },
  ae8d(t, e, n) {},
  aebd(t, e) {
    t.exports = function (t, e) {
      return {
        enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e,
      };
    };
  },
  b0af(t, e, n) {
    n('4c94'); const i = n('b64a'); const r = n('23bf'); const o = n('0d01'); const s = n('6a18'); const a = n('80d2'); const u = n('58df'); const c = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; e.a = Object(u.a)(i.a, r.a, o.a, s.a).extend({
      name: 'v-card',
      props: {
        flat: Boolean, hover: Boolean, img: String, raised: Boolean, tag: { type: String, default: 'div' }, tile: Boolean,
      },
      computed: {
        classes() {
          return c({
            'v-card': !0, 'v-card--flat': this.flat, 'v-card--hover': this.hover, 'v-card--raised': this.raised, 'v-card--tile': this.tile,
          }, this.themeClasses);
        },
        styles() { const t = { height: Object(a.a)(this.height) }; return this.img && (t.background = `url("${this.img}") center center / cover no-repeat`), this.height && (t.height = Object(a.a)(this.height)), this.maxHeight && (t.maxHeight = Object(a.a)(this.maxHeight)), this.maxWidth && (t.maxWidth = Object(a.a)(this.maxWidth)), this.width && (t.width = Object(a.a)(this.width)), t; },
      },
      render(t) { const e = this.generateRouteLink(this.classes); const n = e.tag; const i = e.data; return i.style = this.styles, t(n, this.setBackgroundColor(this.color, i), this.$slots.default); },
    });
  },
  b0dc(t, e, n) { const i = n('e4ae'); t.exports = function (t, e, n, r) { try { return r ? e(i(n)[0], n[1]) : e(n); } catch (s) { const o = t.return; throw void 0 !== o && i(o.call(t)), s; } }; },
  b447(t, e, n) { const i = n('3a38'); const r = Math.min; t.exports = function (t) { return t > 0 ? r(i(t), 9007199254740991) : 0; }; },
  b50d(t, e, n) {
    const i = n('c532'); const r = n('467f'); const o = n('30b5'); const s = n('c345'); const a = n('3934'); const u = n('2d83'); const c = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || n('9fa6'); t.exports = function (t) {
      return new Promise(((e, h) => {
        let l = t.data; const f = t.headers; i.isFormData(l) && delete f['Content-Type']; let p = new XMLHttpRequest(); let d = 'onreadystatechange'; let
          v = !1; if (typeof window === 'undefined' || !window.XDomainRequest || 'withCredentials' in p || a(t.url) || (p = new window.XDomainRequest(), d = 'onload', v = !0, p.onprogress = function () {}, p.ontimeout = function () {}), t.auth) { const g = t.auth.username || ''; const y = t.auth.password || ''; f.Authorization = `Basic ${c(`${g}:${y}`)}`; } if (p.open(t.method.toUpperCase(), o(t.url, t.params, t.paramsSerializer), !0), p.timeout = t.timeout, p[d] = function () {
          if (p && (p.readyState === 4 || v) && (p.status !== 0 || p.responseURL && p.responseURL.indexOf('file:') === 0)) {
            const n = 'getAllResponseHeaders' in p ? s(p.getAllResponseHeaders()) : null; const i = t.responseType && t.responseType !== 'text' ? p.response : p.responseText; const o = {
              data: i, status: p.status === 1223 ? 204 : p.status, statusText: p.status === 1223 ? 'No Content' : p.statusText, headers: n, config: t, request: p,
            }; r(e, h, o), p = null;
          }
        }, p.onerror = function () { h(u('Network Error', t, null, p)), p = null; }, p.ontimeout = function () { h(u(`timeout of ${t.timeout}ms exceeded`, t, 'ECONNABORTED', p)), p = null; }, i.isStandardBrowserEnv()) { const m = n('7aac'); const _ = (t.withCredentials || a(t.url)) && t.xsrfCookieName ? m.read(t.xsrfCookieName) : void 0; _ && (f[t.xsrfHeaderName] = _); } if ('setRequestHeader' in p && i.forEach(f, (t, e) => { typeof l === 'undefined' && e.toLowerCase() === 'content-type' ? delete f[e] : p.setRequestHeader(e, t); }), t.withCredentials && (p.withCredentials = !0), t.responseType) try { p.responseType = t.responseType; } catch (b) { if (t.responseType !== 'json') throw b; } typeof t.onDownloadProgress === 'function' && p.addEventListener('progress', t.onDownloadProgress), typeof t.onUploadProgress === 'function' && p.upload && p.upload.addEventListener('progress', t.onUploadProgress), t.cancelToken && t.cancelToken.promise.then((t) => { p && (p.abort(), h(t), p = null); }), void 0 === l && (l = null), p.send(l);
      }));
    };
  },
  b57a(t, e, n) {
    const i = n('2b0e'); e.a = i.a.extend({ name: 'ssr-bootable', data() { return { isBooted: !1 }; }, mounted() { const t = this; window.requestAnimationFrame(() => { t.$el.setAttribute('data-booted', 'true'), t.isBooted = !0; }); } });
  },
  b64a(t, e, n) {
    const i = n('2b0e'); const r = (function () { function t(t, e) { const n = []; let i = !0; let r = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done); i = !0) if (n.push(s.value), e && n.length === e) break; } catch (u) { r = !0, o = u; } finally { try { !i && a.return && a.return(); } finally { if (r) throw o; } } return n; } return function (e, n) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return t(e, n); throw new TypeError('Invalid attempt to destructure non-iterable instance'); }; }()); const o = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; function s(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function a(t) { return !!t && !!t.match(/^(#|(rgb|hsl)a?\()/); }e.a = i.a.extend({ name: 'colorable', props: { color: String }, methods: { setBackgroundColor(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return a(t) ? e.style = o({}, e.style, { 'background-color': `${t}`, 'border-color': `${t}` }) : t && (e.class = o({}, e.class, s({}, t, !0))), e; }, setTextColor(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (a(t))e.style = o({}, e.style, { color: `${t}`, 'caret-color': `${t}` }); else if (t) { const n = t.toString().trim().split(' ', 2); const i = r(n, 2); const u = i[0]; const c = i[1]; e.class = o({}, e.class, s({}, `${u}--text`, !0)), c && (e.class[`text--${c}`] = !0); } return e; } } });
  },
  b8e3(t, e) { t.exports = !0; },
  bb71(t, e, n) {
    const i = {}; n.r(i), n.d(i, 'linear', () => I), n.d(i, 'easeInQuad', () => P), n.d(i, 'easeOutQuad', () => L), n.d(i, 'easeInOutQuad', () => A), n.d(i, 'easeInCubic', () => F), n.d(i, 'easeOutCubic', () => j), n.d(i, 'easeInOutCubic', () => k), n.d(i, 'easeInQuart', () => M), n.d(i, 'easeOutQuart', () => N), n.d(i, 'easeInOutQuart', () => D), n.d(i, 'easeInQuint', () => $), n.d(i, 'easeOutQuint', () => G), n.d(i, 'easeInOutQuint', () => V); const r = n('2b0e'); function o(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } const s = {
      bar: 0,
      bottom: 0,
      footer: 0,
      insetFooter: 0,
      left: 0,
      right: 0,
      top: 0,
      components: {
        bar: {}, bottom: {}, footer: {}, insetFooter: {}, left: {}, right: {}, top: {},
      },
      bind(t, e, n) { this.components[e] && (this.components[e] = o({}, t, n), this.update(e)); },
      unbind(t, e) { this.components[e][t] != null && (delete this.components[e][t], this.update(e)); },
      update(t) { this[t] = Object.values(this.components[t]).reduce((t, e) => t + e, 0); },
    }; const a = r.a.extend({
      data() { return { clientHeight: c(), clientWidth: u(), resizeTimeout: void 0 }; },
      computed: {
        breakpoint() {
          const t = this.clientWidth < 600; const e = this.clientWidth < 960 && !t; const n = this.clientWidth < 1264 && !(e || t); const i = this.clientWidth < 1904 && !(n || e || t); const r = this.clientWidth >= 1904; const o = t; const s = e; const a = (t || e) && !(n || i || r); const u = !t && (e || n || i || r); const c = n; const h = (t || e || n) && !(i || r); const l = !(t || e) && (n || i || r); const f = i; const p = (t || e || n || i) && !r; const d = !(t || e || n) && (i || r); const v = r; let g = void 0; switch (!0) { case t: g = 'xs'; break; case e: g = 'sm'; break; case n: g = 'md'; break; case i: g = 'lg'; break; default: g = 'xl'; break; } return {
            xs: t, sm: e, md: n, lg: i, xl: r, name: g, xsOnly: o, smOnly: s, smAndDown: a, smAndUp: u, mdOnly: c, mdAndDown: h, mdAndUp: l, lgOnly: f, lgAndDown: p, lgAndUp: d, xlOnly: v, width: this.clientWidth, height: this.clientHeight,
          };
        },
      },
      created() { typeof window !== 'undefined' && window.addEventListener('resize', this.onResize, { passive: !0 }); },
      beforeDestroy() { typeof window !== 'undefined' && window.removeEventListener('resize', this.onResize); },
      methods: { onResize() { clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.setDimensions, 200); }, setDimensions() { this.clientHeight = c(), this.clientWidth = u(); } },
    }); function u() { return typeof document === 'undefined' ? 0 : Math.max(document.documentElement.clientWidth, window.innerWidth || 0); } function c() { return typeof document === 'undefined' ? 0 : Math.max(document.documentElement.clientHeight, window.innerHeight || 0); } const h = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; const l = {
      primary: '#1976D2', secondary: '#424242', accent: '#82B1FF', error: '#FF5252', info: '#2196F3', success: '#4CAF50', warning: '#FFC107',
    }; function f() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return !1 !== t && h({}, l, t); } const p = {
      complete: 'check', cancel: 'cancel', close: 'close', delete: 'cancel', clear: 'clear', success: 'check_circle', info: 'info', warning: 'priority_high', error: 'warning', prev: 'chevron_left', next: 'chevron_right', checkboxOn: 'check_box', checkboxOff: 'check_box_outline_blank', checkboxIndeterminate: 'indeterminate_check_box', delimiter: 'fiber_manual_record', sort: 'arrow_upward', expand: 'keyboard_arrow_down', menu: 'menu', subgroup: 'arrow_drop_down', dropdown: 'arrow_drop_down', radioOn: 'radio_button_checked', radioOff: 'radio_button_unchecked', edit: 'edit', ratingEmpty: 'star_border', ratingFull: 'star', ratingHalf: 'star_half', loading: 'cached',
    }; const d = {
      complete: 'mdi-check', cancel: 'mdi-close-circle', close: 'mdi-close', delete: 'mdi-close-circle', clear: 'mdi-close', success: 'mdi-check-circle', info: 'mdi-information', warning: 'mdi-exclamation', error: 'mdi-alert', prev: 'mdi-chevron-left', next: 'mdi-chevron-right', checkboxOn: 'mdi-checkbox-marked', checkboxOff: 'mdi-checkbox-blank-outline', checkboxIndeterminate: 'mdi-minus-box', delimiter: 'mdi-circle', sort: 'mdi-arrow-up', expand: 'mdi-chevron-down', menu: 'mdi-menu', subgroup: 'mdi-menu-down', dropdown: 'mdi-menu-down', radioOn: 'mdi-radiobox-marked', radioOff: 'mdi-radiobox-blank', edit: 'mdi-pencil', ratingEmpty: 'mdi-star-outline', ratingFull: 'mdi-star', ratingHalf: 'mdi-star-half',
    }; const v = {
      complete: 'fa fa-check', cancel: 'fa fa-times-circle', close: 'fa fa-times', delete: 'fa fa-times-circle', clear: 'fa fa-times-circle', success: 'fa fa-check-circle', info: 'fa fa-info-circle', warning: 'fa fa-exclamation', error: 'fa fa-exclamation-triangle', prev: 'fa fa-chevron-left', next: 'fa fa-chevron-right', checkboxOn: 'fa fa-check-square', checkboxOff: 'fa fa-square-o', checkboxIndeterminate: 'fa fa-minus-square', delimiter: 'fa fa-circle', sort: 'fa fa-sort-up', expand: 'fa fa-chevron-down', menu: 'fa fa-bars', subgroup: 'fa fa-caret-down', dropdown: 'fa fa-caret-down', radioOn: 'fa fa-dot-circle', radioOff: 'fa fa-circle-o', edit: 'fa fa-pencil', ratingEmpty: 'fa fa-star-o', ratingFull: 'fa fa-star', ratingHalf: 'fa fa-star-half-o',
    }; const g = {
      complete: 'fas fa-check', cancel: 'fas fa-times-circle', close: 'fas fa-times', delete: 'fas fa-times-circle', clear: 'fas fa-times-circle', success: 'fas fa-check-circle', info: 'fas fa-info-circle', warning: 'fas fa-exclamation', error: 'fas fa-exclamation-triangle', prev: 'fas fa-chevron-left', next: 'fas fa-chevron-right', checkboxOn: 'fas fa-check-square', checkboxOff: 'far fa-square', checkboxIndeterminate: 'fas fa-minus-square', delimiter: 'fas fa-circle', sort: 'fas fa-sort-up', expand: 'fas fa-chevron-down', menu: 'fas fa-bars', subgroup: 'fas fa-caret-down', dropdown: 'fas fa-caret-down', radioOn: 'far fa-dot-circle', radioOff: 'far fa-circle', edit: 'fas fa-edit', ratingEmpty: 'far fa-star', ratingFull: 'fas fa-star', ratingHalf: 'fas fa-star-half',
    }; const y = {
      md: p, mdi: d, fa: g, fa4: v,
    }; function m() {
      const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'md'; const
        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return Object.assign({}, y[t] || y.md, e);
    } const _ = {
      minifyTheme: null, themeCache: null, customProperties: !1, cspNonce: null,
    }; function b() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return Object.assign({}, _, t); } const w = {
      dataIterator: {
        rowsPerPageText: 'Items per page:', rowsPerPageAll: 'All', pageText: '{0}-{1} of {2}', noResultsText: 'No matching records found', nextPage: 'Next page', prevPage: 'Previous page',
      },
      dataTable: { rowsPerPageText: 'Rows per page:' },
      noDataText: 'No data available',
    }; const x = n('80d2'); const E = n('d9bd'); function S(t) { if (Array.isArray(t)) { for (var e = 0, n = Array(t.length); e < t.length; e++)n[e] = t[e]; return n; } return Array.from(t); } const T = '$vuetify.'; const O = Symbol('Lang fallback'); function C(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = e.replace(T, ''); let r = Object(x.d)(t, i, O); return r === O && (n ? (Object(E.a)(`Translation key "${i}" not found in fallback`), r = e) : (Object(E.b)(`Translation key "${i}" not found, falling back to default`), r = C(w, e, !0))), r; } function R() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return { locales: Object.assign({ en: w }, t.locales), current: t.current || 'en', t(e) { for (var n = arguments.length, i = Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)i[r - 1] = arguments[r]; if (!e.startsWith(T)) return e; if (t.t) return t.t(...[e].concat(S(i))); const o = C(this.locales[this.current], e); return o.replace(/\{(\d+)\}/g, (t, e) => String(i[+e])); } }; } var I = function (t) { return t; }; var P = function (t) { return t * t; }; var L = function (t) { return t * (2 - t); }; var A = function (t) { return t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1; }; var F = function (t) { return t * t * t; }; var j = function (t) { return --t * t * t + 1; }; var k = function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }; var M = function (t) { return t * t * t * t; }; var N = function (t) { return 1 - --t * t * t * t; }; var D = function (t) { return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t; }; var $ = function (t) { return t * t * t * t * t; }; var G = function (t) { return 1 + --t * t * t * t * t; }; var V = function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t; }; const B = { duration: 500, offset: 0, easing: 'easeInOutCubic' }; function U() { return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight); } function z() { return window.innerHeight || (document.documentElement || document.body).clientHeight; } function Y(t) { return t != null && t._isVue; } function X(t, e) { let n = void 0; if (Y(t) && (t = t.$el), t instanceof Element)n = t.getBoundingClientRect().top + window.pageYOffset; else if (typeof t === 'string') { const i = document.querySelector(t); if (!i) throw new TypeError(`Target element "${t}" not found.`); n = i.getBoundingClientRect().top + window.pageYOffset; } else { if (typeof t !== 'number') { const r = t == null ? t : t.constructor.name; throw new TypeError(`Target must be a Selector/Number/DOMElement/VueComponent, received ${r} instead.`); }n = t; } return Math.round(Math.min(Math.max(n + e.offset, 0), U() - z())); } function W(t, e) { return new Promise(((n, r) => { if (typeof window === 'undefined') return r('Window is undefined'); const o = Object.assign({}, B, e); const s = performance.now(); const a = window.pageYOffset; const u = X(t, o); const c = u - a; const h = typeof o.easing === 'function' ? o.easing : i[o.easing]; if (!h) throw new TypeError(`Easing function '${o.easing}' not found.`); function l(e) { const i = Math.min(1, (e - s) / o.duration); const r = Math.floor(a + c * h(i)); if (window.scrollTo(0, r), Math.round(window.pageYOffset) === u || i === 1) return n(t); window.requestAnimationFrame(l); }window.requestAnimationFrame(l); })); } const K = {
      install(t) {
        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.installed) {
          this.installed = !0, r.a !== t && Object(E.a)("Multiple instances of Vue detected\nSee https://github.com/vuetifyjs/vuetify/issues/4068\n\nIf you're seeing \"$attrs is readonly\", it's caused by this"), H(t); const n = R(e.lang); if (t.prototype.$vuetify = new t({
            mixins: [a],
            data: {
              application: s, dark: !1, icons: m(e.iconfont, e.icons), lang: n, options: b(e.options), rtl: e.rtl, theme: f(e.theme),
            },
            methods: { goTo: W, t: n.t.bind(n) },
          }), e.directives) for (const i in e.directives)t.directive(i, e.directives[i]); (function e(n) { if (n) { for (const i in n) { const r = n[i]; r && !e(r.$_vuetify_subcomponents) && t.component(i, r); } return !0; } return !1; }(e.components));
        }
      },
      version: '1.3.12',
    }; function H(t, e) { const n = e || '^2.5.10'; const i = n.split('.', 3).map(t => t.replace(/\D/g, '')).map(Number); const r = t.version.split('.', 3).map(t => parseInt(t, 10)); const o = r[0] === i[0] && (r[1] > i[1] || r[1] === i[1] && r[2] >= i[2]); o || Object(E.b)(`Vuetify requires Vue version ${n}`); } const q = K; e.a = q;
  },
  bbdd(t, e, n) { const i = (function () { return this || typeof self === 'object' && self; }()) || Function('return this')(); const r = i.regeneratorRuntime && Object.getOwnPropertyNames(i).indexOf('regeneratorRuntime') >= 0; const o = r && i.regeneratorRuntime; if (i.regeneratorRuntime = void 0, t.exports = n('96cf'), r)i.regeneratorRuntime = o; else try { delete i.regeneratorRuntime; } catch (s) { i.regeneratorRuntime = void 0; } },
  bc13(t, e, n) { const i = n('e53d'); const r = i.navigator; t.exports = r && r.userAgent || ''; },
  bc3a(t, e, n) { t.exports = n('cee4'); },
  bcaa(t, e, n) { const i = n('cb7c'); const r = n('d3f4'); const o = n('a5b8'); t.exports = function (t, e) { if (i(t), r(e) && e.constructor === t) return e; const n = o.f(t); const s = n.resolve; return s(e), n.promise; }; },
  bced(t, e, n) {},
  be13(t, e) { t.exports = function (t) { if (void 0 == t) throw TypeError(`Can't call method on  ${t}`); return t; }; },
  be94(t, e, n) {
    function i(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n, enumerable: !0, configurable: !0, writable: !0,
      }) : t[e] = n, t;
    } function r(t) { for (let e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; let r = Object.keys(n); typeof Object.getOwnPropertySymbols === 'function' && (r = r.concat(Object.getOwnPropertySymbols(n).filter(t => Object.getOwnPropertyDescriptor(n, t).enumerable))), r.forEach((e) => { i(t, e, n[e]); }); } return t; }n.d(e, 'a', () => r);
  },
  bf0b(t, e, n) { const i = n('355d'); const r = n('aebd'); const o = n('36c3'); const s = n('1bc3'); const a = n('07e3'); const u = n('794b'); const c = Object.getOwnPropertyDescriptor; e.f = n('8e60') ? c : function (t, e) { if (t = o(t), e = s(e, !0), u) try { return c(t, e); } catch (n) {} if (a(t, e)) return r(!i.f.call(t, e), t[e]); }; },
  bf90(t, e, n) { const i = n('36c3'); const r = n('bf0b').f; n('ce7e')('getOwnPropertyDescriptor', () => function (t, e) { return r(i(t), e); }); },
  bfac(t, e, n) { const i = n('0b64'); t.exports = function (t, e) { return new (i(t))(e); }; },
  c189(t, e, n) {
    const i = n('79aa'); const r = n('f772'); const o = n('3024'); const s = [].slice; const a = {}; const u = function (t, e, n) { if (!(e in a)) { for (var i = [], r = 0; r < e; r++)i[r] = `a[${r}]`; a[e] = Function('F,a', `return new F(${i.join(',')})`); } return a[e](t, n); }; t.exports = Function.bind || function (t) { const e = i(this); const n = s.call(arguments, 1); var a = function () { const i = n.concat(s.call(arguments)); return this instanceof a ? u(e, i.length, i) : o(e, i, t); }; return r(e.prototype) && (a.prototype = e.prototype), a; };
  },
  c207(t, e) {},
  c22b(t, e, n) {
    n.d(e, 'b', () => s); const i = n('2b0e'); const r = n('80d2'); const o = {
      absolute: Boolean, bottom: Boolean, fixed: Boolean, left: Boolean, right: Boolean, top: Boolean,
    }; function s() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; return i.a.extend({ name: 'positionable', props: t.length ? Object(r.c)(o, t) : o }); }e.a = s();
  },
  c345(t, e, n) {
    const i = n('c532'); const r = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']; t.exports = function (t) { let e; let n; let o; const s = {}; return t ? (i.forEach(t.split('\n'), (t) => { if (o = t.indexOf(':'), e = i.trim(t.substr(0, o)).toLowerCase(), n = i.trim(t.substr(o + 1)), e) { if (s[e] && r.indexOf(e) >= 0) return; s[e] = e === 'set-cookie' ? (s[e] ? s[e] : []).concat([n]) : s[e] ? `${s[e]}, ${n}` : n; } }), s) : s; };
  },
  c366(t, e, n) { const i = n('6821'); const r = n('9def'); const o = n('77f1'); t.exports = function (t) { return function (e, n, s) { let a; const u = i(e); const c = r(u.length); let h = o(s, c); if (t && n != n) { while (c > h) if (a = u[h++], a != a) return !0; } else for (;c > h; h++) if ((t || h in u) && u[h] === n) return t || h || 0; return !t && -1; }; }; },
  c367(t, e, n) {
    const i = n('8436'); const r = n('50ed'); const o = n('481b'); const s = n('36c3'); t.exports = n('30f1')(Array, 'Array', function (t, e) { this._t = s(t), this._i = 0, this._k = e; }, function () { const t = this._t; const e = this._k; const n = this._i++; return !t || n >= t.length ? (this._t = void 0, r(1)) : r(0, e == 'keys' ? n : e == 'values' ? t[n] : [n, t[n]]); }, 'values'), o.Arguments = o.Array, i('keys'), i('values'), i('entries');
  },
  c3a1(t, e, n) { const i = n('e6f3'); const r = n('1691'); t.exports = Object.keys || function (t) { return i(t, r); }; },
  c401(t, e, n) {
    const i = n('c532'); t.exports = function (t, e, n) { return i.forEach(n, (n) => { t = n(t, e); }), t; };
  },
  c532(t, e, n) {
    const i = n('1d2b'); const r = n('044b'); const o = Object.prototype.toString; function s(t) { return o.call(t) === '[object Array]'; } function a(t) { return o.call(t) === '[object ArrayBuffer]'; } function u(t) { return typeof FormData !== 'undefined' && t instanceof FormData; } function c(t) { let e; return e = typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && t.buffer instanceof ArrayBuffer, e; } function h(t) { return typeof t === 'string'; } function l(t) { return typeof t === 'number'; } function f(t) { return typeof t === 'undefined'; } function p(t) { return t !== null && typeof t === 'object'; } function d(t) { return o.call(t) === '[object Date]'; } function v(t) { return o.call(t) === '[object File]'; } function g(t) { return o.call(t) === '[object Blob]'; } function y(t) { return o.call(t) === '[object Function]'; } function m(t) { return p(t) && y(t.pipe); } function _(t) { return typeof URLSearchParams !== 'undefined' && t instanceof URLSearchParams; } function b(t) { return t.replace(/^\s*/, '').replace(/\s*$/, ''); } function w() { return (typeof navigator === 'undefined' || navigator.product !== 'ReactNative') && (typeof window !== 'undefined' && typeof document !== 'undefined'); } function x(t, e) { if (t !== null && typeof t !== 'undefined') if (typeof t !== 'object' && (t = [t]), s(t)) for (let n = 0, i = t.length; n < i; n++)e.call(null, t[n], n, t); else for (const r in t)Object.prototype.hasOwnProperty.call(t, r) && e.call(null, t[r], r, t); } function E() { const t = {}; function e(e, n) { typeof t[n] === 'object' && typeof e === 'object' ? t[n] = E(t[n], e) : t[n] = e; } for (let n = 0, i = arguments.length; n < i; n++)x(arguments[n], e); return t; } function S(t, e, n) { return x(e, (e, r) => { t[r] = n && typeof e === 'function' ? i(e, n) : e; }), t; }t.exports = {
      isArray: s, isArrayBuffer: a, isBuffer: r, isFormData: u, isArrayBufferView: c, isString: h, isNumber: l, isObject: p, isUndefined: f, isDate: d, isFile: v, isBlob: g, isFunction: y, isStream: m, isURLSearchParams: _, isStandardBrowserEnv: w, forEach: x, merge: E, extend: S, trim: b,
    };
  },
  c64e(t, e, n) { const i = n('e1f4'); const r = n('2366'); function o(t, e, n) { const o = e && n || 0; typeof t === 'string' && (e = t === 'binary' ? new Array(16) : null, t = null), t = t || {}; const s = t.random || (t.rng || i)(); if (s[6] = 15 & s[6] | 64, s[8] = 63 & s[8] | 128, e) for (let a = 0; a < 16; ++a)e[o + a] = s[a]; return e || r(s); }t.exports = o; },
  c69a(t, e, n) { t.exports = !n('9e1e') && !n('79e5')(() => Object.defineProperty(n('230e')('div'), 'a', { get() { return 7; } }).a != 7); },
  c6f7(t, e, n) {
    n.d(e, 'a', () => o); const i = n('c22b'); const r = n('58df'); function o(t) {
      const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; return Object(r.a)(Object(i.b)(['absolute', 'fixed'])).extend({
        name: 'applicationable', props: { app: Boolean }, computed: { applicationProperty() { return t; } }, watch: { app(t, e) { e ? this.removeApplication(!0) : this.callUpdate(); }, applicationProperty(t, e) { this.$vuetify.application.unbind(this._uid, e); } }, activated() { this.callUpdate(); }, created() { for (let t = 0, n = e.length; t < n; t++) this.$watch(e[t], this.callUpdate); this.callUpdate(); }, mounted() { this.callUpdate(); }, deactivated() { this.removeApplication(); }, destroyed() { this.removeApplication(); }, methods: { callUpdate() { this.app && this.$vuetify.application.bind(this._uid, this.applicationProperty, this.updateApplication()); }, removeApplication() { const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; (t || this.app) && this.$vuetify.application.unbind(this._uid, this.applicationProperty); }, updateApplication() { return 0; } },
      });
    }
  },
  c8af(t, e, n) {
    const i = n('c532'); t.exports = function (t, e) { i.forEach(t, (n, i) => { i !== e && i.toUpperCase() === e.toUpperCase() && (t[e] = n, delete t[i]); }); };
  },
  c8ba(t, e) { let n; n = (function () { return this; }()); try { n = n || new Function('return this')(); } catch (i) { typeof window === 'object' && (n = window); }t.exports = n; },
  c8bb(t, e, n) { t.exports = n('54a1'); },
  ca5a(t, e) { let n = 0; const i = Math.random(); t.exports = function (t) { return 'Symbol('.concat(void 0 === t ? '' : t, ')_', (++n + i).toString(36)); }; },
  cadf(t, e, n) {
    const i = n('9c6c'); const r = n('d53b'); const o = n('84f2'); const s = n('6821'); t.exports = n('01f9')(Array, 'Array', function (t, e) { this._t = s(t), this._i = 0, this._k = e; }, function () { const t = this._t; const e = this._k; const n = this._i++; return !t || n >= t.length ? (this._t = void 0, r(1)) : r(0, e == 'keys' ? n : e == 'values' ? t[n] : [n, t[n]]); }, 'values'), o.Arguments = o.Array, i('keys'), i('values'), i('entries');
  },
  cb7c(t, e, n) { const i = n('d3f4'); t.exports = function (t) { if (!i(t)) throw TypeError(`${t} is not an object!`); return t; }; },
  ccb9(t, e, n) { e.f = n('5168'); },
  cd78(t, e, n) { const i = n('e4ae'); const r = n('f772'); const o = n('656e'); t.exports = function (t, e) { if (i(t), r(e) && e.constructor === t) return e; const n = o.f(t); const s = n.resolve; return s(e), n.promise; }; },
  ce10(t, e, n) { const i = n('69a8'); const r = n('6821'); const o = n('c366')(!1); const s = n('613b')('IE_PROTO'); t.exports = function (t, e) { let n; const a = r(t); let u = 0; const c = []; for (n in a)n != s && i(a, n) && c.push(n); while (e.length > u)i(a, n = e[u++]) && (~o(c, n) || c.push(n)); return c; }; },
  ce7e(t, e, n) { const i = n('63b6'); const r = n('584a'); const o = n('294c'); t.exports = function (t, e) { const n = (r.Object || {})[t] || Object[t]; const s = {}; s[t] = e(n), i(i.S + i.F * o(() => { n(1); }), 'Object', s); }; },
  ce7e6(t, e, n) {
    n('58db6'); const i = n('6a18'); const r = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; e.a = i.a.extend({ name: 'v-divider', props: { inset: Boolean, vertical: Boolean }, render(t) { return t('hr', { class: r({ 'v-divider': !0, 'v-divider--inset': this.inset, 'v-divider--vertical': this.vertical }, this.themeClasses), attrs: this.$attrs, on: this.$listeners }); } });
  },
  cee4(t, e, n) {
    const i = n('c532'); const r = n('1d2b'); const o = n('0a06'); const s = n('2444'); function a(t) { const e = new o(t); const n = r(o.prototype.request, e); return i.extend(n, o.prototype, e), i.extend(n, e), n; } const u = a(s); u.Axios = o, u.create = function (t) { return a(i.merge(s, t)); }, u.Cancel = n('7a77'), u.CancelToken = n('8df4'), u.isCancel = n('2e67'), u.all = function (t) { return Promise.all(t); }, u.spread = n('0df6'), t.exports = u, t.exports.default = u;
  },
  d2d5(t, e, n) { n('1654'), n('549b'), t.exports = n('584a').Array.from; },
  d3f4(t, e) { t.exports = function (t) { return typeof t === 'object' ? t !== null : typeof t === 'function'; }; },
  d53b(t, e) { t.exports = function (t, e) { return { value: e, done: !!t }; }; },
  d847(t, e, n) { t.exports = n('5bba'); },
  d864(t, e, n) { const i = n('79aa'); t.exports = function (t, e, n) { if (i(t), void 0 === e) return t; switch (n) { case 1: return function (n) { return t.call(e, n); }; case 2: return function (n, i) { return t.call(e, n, i); }; case 3: return function (n, i, r) { return t.call(e, n, i, r); }; } return function () { return t.apply(e, arguments); }; }; },
  d8d6(t, e, n) { n('1654'), n('6c1c'), t.exports = n('ccb9').f('iterator'); },
  d8e8(t, e) { t.exports = function (t) { if (typeof t !== 'function') throw TypeError(`${t} is not a function!`); return t; }; },
  d925(t, e, n) {
    t.exports = function (t) { return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t); };
  },
  d9bd(t, e, n) {
    function i(t, e, n) { if (n && (e = { _isVue: !0, $parent: n, $options: e }), e) { if (e.$_alreadyWarned = e.$_alreadyWarned || [], e.$_alreadyWarned.includes(t)) return; e.$_alreadyWarned.push(t); } return `[Vuetify] ${t}${e ? h(e) : ''}`; } function r(t, e, n) { const r = i(t, e, n); r != null && console.warn(r); } function o(t, e, n) { const r = i(t, e, n); r != null && console.error(r); } function s(t, e, n, i) { r(`'${t}' is deprecated, use '${e}' instead`, n, i); }n.d(e, 'b', () => r), n.d(e, 'a', () => o), n.d(e, 'c', () => s); const a = /(?:^|[-_])(\w)/g; const u = function (t) { return t.replace(a, t => t.toUpperCase()).replace(/[-_]/g, ''); }; function c(t, e) { if (t.$root === t) return '<Root>'; const n = typeof t === 'function' && t.cid != null ? t.options : t._isVue ? t.$options || t.constructor.options : t || {}; let i = n.name || n._componentTag; const r = n.__file; if (!i && r) { const o = r.match(/([^\/\\]+)\.vue$/); i = o && o[1]; } return (i ? `<${u(i)}>` : '<Anonymous>') + (r && !1 !== e ? ` at ${r}` : ''); } function h(t) { if (t._isVue && t.$parent) { const e = []; let n = 0; while (t) { if (e.length > 0) { const i = e[e.length - 1]; if (i.constructor === t.constructor) { n++, t = t.$parent; continue; }n > 0 && (e[e.length - 1] = [i, n], n = 0); }e.push(t), t = t.$parent; } return `\n\nfound in\n\n${e.map((t, e) => `${e === 0 ? '---\x3e ' : ' '.repeat(5 + 2 * e)}${Array.isArray(t) ? `${c(t[0])}... (${t[1]} recursive calls)` : c(t)}`).join('\n')}`; } return `\n\n(found in ${c(t)})`; }
  },
  d9f6(t, e, n) { const i = n('e4ae'); const r = n('794b'); const o = n('1bc3'); const s = Object.defineProperty; e.f = n('8e60') ? Object.defineProperty : function (t, e, n) { if (i(t), e = o(e, !0), i(n), r) try { return s(t, e, n); } catch (a) {} if ('get' in n || 'set' in n) throw TypeError('Accessors not supported!'); return 'value' in n && (t[e] = n.value), t; }; },
  da64(t, e, n) {},
  db0c(t, e, n) { t.exports = n('9e1c'); },
  db6d(t, e, n) {},
  dbdb(t, e, n) { const i = n('584a'); const r = n('e53d'); const o = '__core-js_shared__'; const s = r[o] || (r[o] = {}); (t.exports = function (t, e) { return s[t] || (s[t] = void 0 !== e ? e : {}); })('versions', []).push({ version: i.version, mode: n('b8e3') ? 'pure' : 'global', copyright: '© 2018 Denis Pushkarev (zloirock.ru)' }); },
  dc62(t, e, n) { n('9427'); const i = n('584a').Object; t.exports = function (t, e) { return i.create(t, e); }; },
  dcbc(t, e, n) { const i = n('2aba'); t.exports = function (t, e, n) { for (const r in e)i(t, r, e[r], n); return t; }; },
  df7c(t, e, n) { (function (t) { function n(t, e) { for (var n = 0, i = t.length - 1; i >= 0; i--) { const r = t[i]; r === '.' ? t.splice(i, 1) : r === '..' ? (t.splice(i, 1), n++) : n && (t.splice(i, 1), n--); } if (e) for (;n--; n)t.unshift('..'); return t; } const i = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; const r = function (t) { return i.exec(t).slice(1); }; function o(t, e) { if (t.filter) return t.filter(e); for (var n = [], i = 0; i < t.length; i++)e(t[i], i, t) && n.push(t[i]); return n; }e.resolve = function () { for (var e = '', i = !1, r = arguments.length - 1; r >= -1 && !i; r--) { const s = r >= 0 ? arguments[r] : t.cwd(); if (typeof s !== 'string') throw new TypeError('Arguments to path.resolve must be strings'); s && (e = `${s}/${e}`, i = s.charAt(0) === '/'); } return e = n(o(e.split('/'), t => !!t), !i).join('/'), (i ? '/' : '') + e || '.'; }, e.normalize = function (t) { const i = e.isAbsolute(t); const r = s(t, -1) === '/'; return t = n(o(t.split('/'), t => !!t), !i).join('/'), t || i || (t = '.'), t && r && (t += '/'), (i ? '/' : '') + t; }, e.isAbsolute = function (t) { return t.charAt(0) === '/'; }, e.join = function () { const t = Array.prototype.slice.call(arguments, 0); return e.normalize(o(t, (t, e) => { if (typeof t !== 'string') throw new TypeError('Arguments to path.join must be strings'); return t; }).join('/')); }, e.relative = function (t, n) { function i(t) { for (var e = 0; e < t.length; e++) if (t[e] !== '') break; for (var n = t.length - 1; n >= 0; n--) if (t[n] !== '') break; return e > n ? [] : t.slice(e, n - e + 1); }t = e.resolve(t).substr(1), n = e.resolve(n).substr(1); for (var r = i(t.split('/')), o = i(n.split('/')), s = Math.min(r.length, o.length), a = s, u = 0; u < s; u++) if (r[u] !== o[u]) { a = u; break; } let c = []; for (u = a; u < r.length; u++)c.push('..'); return c = c.concat(o.slice(a)), c.join('/'); }, e.sep = '/', e.delimiter = ':', e.dirname = function (t) { const e = r(t); const n = e[0]; let i = e[1]; return n || i ? (i && (i = i.substr(0, i.length - 1)), n + i) : '.'; }, e.basename = function (t, e) { let n = r(t)[2]; return e && n.substr(-1 * e.length) === e && (n = n.substr(0, n.length - e.length)), n; }, e.extname = function (t) { return r(t)[3]; }; var s = 'ab'.substr(-1) === 'b' ? function (t, e, n) { return t.substr(e, n); } : function (t, e, n) { return e < 0 && (e = t.length + e), t.substr(e, n); }; }).call(this, n('4362')); },
  e11e(t, e) { t.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(','); },
  e1f4(t, e) { const n = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof window.msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto); if (n) { const i = new Uint8Array(16); t.exports = function () { return n(i), i; }; } else { const r = new Array(16); t.exports = function () { for (var t, e = 0; e < 16; e++)(3 & e) === 0 && (t = 4294967296 * Math.random()), r[e] = t >>> ((3 & e) << 3) & 255; return r; }; } },
  e265(t, e, n) { t.exports = n('ed33'); },
  e4ae(t, e, n) { const i = n('f772'); t.exports = function (t) { if (!i(t)) throw TypeError(`${t} is not an object!`); return t; }; },
  e53d(t, e) { const n = t.exports = typeof window !== 'undefined' && window.Math == Math ? window : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); typeof __g === 'number' && (__g = n); },
  e683(t, e, n) {
    t.exports = function (t, e) { return e ? `${t.replace(/\/+$/, '')}/${e.replace(/^\/+/, '')}` : t; };
  },
  e692(t, e) { t.exports = '\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff'; },
  e6f3(t, e, n) { const i = n('07e3'); const r = n('36c3'); const o = n('5b4e')(!1); const s = n('5559')('IE_PROTO'); t.exports = function (t, e) { let n; const a = r(t); let u = 0; const c = []; for (n in a)n != s && i(a, n) && c.push(n); while (e.length > u)i(a, n = e[u++]) && (~o(c, n) || c.push(n)); return c; }; },
  e8f2(t, e, n) {
    function i(t) {
      return {
        name: `v-${t}`, functional: !0, props: { id: String, tag: { type: String, default: 'div' } }, render(e, n) { const i = n.props; const r = n.data; const o = n.children; if (r.staticClass = (`${t} ${r.staticClass || ''}`).trim(), r.attrs) { const s = Object.keys(r.attrs).filter((t) => { if (t === 'slot') return !1; const e = r.attrs[t]; return e || typeof e === 'string'; }); s.length && (r.staticClass += ` ${s.join(' ')}`), delete r.attrs; } return i.id && (r.domProps = r.domProps || {}, r.domProps.id = i.id), e(i.tag, r, o); },
      };
    }n.d(e, 'a', () => i);
  },
  ead6(t, e, n) { const i = n('f772'); const r = n('e4ae'); const o = function (t, e) { if (r(t), !i(e) && e !== null) throw TypeError(`${e}: can't set as prototype!`); }; t.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? (function (t, e, i) { try { i = n('d864')(Function.call, n('bf0b').f(Object.prototype, '__proto__').set, 2), i(t, []), e = !(t instanceof Array); } catch (r) { e = !0; } return function (t, n) { return o(t, n), e ? t.__proto__ = n : i(t, n), t; }; }({}, !1)) : void 0), check: o }; },
  ebd6(t, e, n) { const i = n('cb7c'); const r = n('d8e8'); const o = n('2b4c')('species'); t.exports = function (t, e) { let n; const s = i(t).constructor; return void 0 === s || void 0 == (n = i(s)[o]) ? e : r(n); }; },
  ebfd(t, e, n) {
    const i = n('62a0')('meta'); const r = n('f772'); const o = n('07e3'); const s = n('d9f6').f; let a = 0; const u = Object.isExtensible || function () { return !0; }; const c = !n('294c')(() => u(Object.preventExtensions({}))); const h = function (t) { s(t, i, { value: { i: `O${++a}`, w: {} } }); }; const l = function (t, e) { if (!r(t)) return typeof t === 'symbol' ? t : (typeof t === 'string' ? 'S' : 'P') + t; if (!o(t, i)) { if (!u(t)) return 'F'; if (!e) return 'E'; h(t); } return t[i].i; }; const f = function (t, e) { if (!o(t, i)) { if (!u(t)) return !0; if (!e) return !1; h(t); } return t[i].w; }; const p = function (t) { return c && d.NEED && u(t) && !o(t, i) && h(t), t; }; var d = t.exports = {
      KEY: i, NEED: !1, fastKey: l, getWeak: f, onFreeze: p,
    };
  },
  ed33(t, e, n) { n('014b'), t.exports = n('584a').Object.getOwnPropertySymbols; },
  f134(t, e, n) {},
  f201(t, e, n) { const i = n('e4ae'); const r = n('79aa'); const o = n('5168')('species'); t.exports = function (t, e) { let n; const s = i(t).constructor; return void 0 === s || void 0 == (n = i(s)[o]) ? e : r(n); }; },
  f228(t, e, n) { const i = n('40c3'); const r = n('4517'); t.exports = function (t) { return function () { if (i(this) != t) throw TypeError(`${t}#toJSON isn't generic`); return r(this); }; }; },
  f410(t, e, n) { n('1af6'), t.exports = n('584a').Array.isArray; },
  f499(t, e, n) { t.exports = n('a21f'); },
  f605(t, e) { t.exports = function (t, e, n, i) { if (!(t instanceof e) || void 0 !== i && i in t) throw TypeError(`${n}: incorrect invocation!`); return t; }; },
  f6b4(t, e, n) {
    const i = n('c532'); function r() { this.handlers = []; }r.prototype.use = function (t, e) { return this.handlers.push({ fulfilled: t, rejected: e }), this.handlers.length - 1; }, r.prototype.eject = function (t) { this.handlers[t] && (this.handlers[t] = null); }, r.prototype.forEach = function (t) { i.forEach(this.handlers, (e) => { e !== null && t(e); }); }, t.exports = r;
  },
  f772(t, e) { t.exports = function (t) { return typeof t === 'object' ? t !== null : typeof t === 'function'; }; },
  f921(t, e, n) { n('014b'), n('c207'), n('69d3'), n('765d'), t.exports = n('584a').Symbol; },
  fa99(t, e, n) { n('0293'), t.exports = n('584a').Object.getPrototypeOf; },
  fab2(t, e, n) { const i = n('7726').document; t.exports = i && i.documentElement; },
  fde4(t, e, n) { n('bf90'); const i = n('584a').Object; t.exports = function (t, e) { return i.getOwnPropertyDescriptor(t, e); }; },
  fe1e(t, e, n) { n('7075')('Map'); },
}]);
// # sourceMappingURL=chunk-vendors.4fcb4e1a.js.map
